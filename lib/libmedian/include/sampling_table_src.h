/*INDENT OFF*/

/* Description: C source code for quickselect */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    sampling_table_src.h copyright 2017-2018 Bruce Lilly.   \ sampling_table_src.h $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is sampling_table_src.h version 1.15 dated 2018-08-13T20:57:01Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/include/s.sampling_table_src.h */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and a pair of indices brackets the sub-array
 being processed.  The indices correspond to the ranks of elements.  A similar
 scheme is used by Musser's introsort, described in "Introspective Sorting and
 Selection Algorithms".  The same method is used for the array of desired order
 statistic ranks, similar to that described by Lent & Mahmoud.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.
 Partitioning can still result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by efficient inline swap functions.  No attempt
 is made to optimize for specific array element types, but swapping can be
 performed in units of basic language types.  The swap functions avoid useless
 work (e.g. when given two pointers to the same element).  No specialized macros
 are required.
******************************************************************************/

/* Nothing to configure below this line. */

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
   ID_STRING_PREFIX is suitable for the what(1) and ident(1) utilities.
   MODULE_DATE uses modern SCCS extensions.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: sampling_table_src.h ~|^` @(#)"
#define SOURCE_MODULE "sampling_table_src.h"
#define MODULE_VERSION "1.15"
#define MODULE_DATE "2018-08-13T20:57:01Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
#define COPYRIGHT_DATE "2017-2018"

/* local header files needed */
#include "quickselect_config.h" /* quickselect QSORT_FUNCTION_NAME */
#include "tables.h"     /* sampling_table_struct SAMPLING_TABLE_SIZE */
#if ! QUICKSELECT_BUILD_FOR_SPEED
#include "initialize_src.h"
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* system header files */
#include <assert.h>             /* assert */
#include <limits.h>             /* *_MAX */
#include <math.h>               /* pow */
#include <stddef.h>             /* size_t NULL */

#if (ASSERT_CODE > 0) || ((DEBUG_CODE > 0) && defined(DEBUGGING))
/* not static; referenced by inline functions */
char sampling_table_src_file[PATH_MAX];
char sampling_table_src_file_initialized=0;
#endif

#if ! QUICKSELECT_BUILD_FOR_SPEED
/* klimits declaration */
#include "klimits_decl.h"
;

/* declaration */
#include "sample_index_decl.h"
;
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* sample_index: return index into sampling table psts for nmemb
*/
/* called from sampling_table and quicksort */
#if QUICKSELECT_BUILD_FOR_SPEED
QUICKSELECT_VISIBILITY QUICKSELECT_INLINE
#endif /* QUICKSELECT_BUILD_FOR_SPEED */
#include "sample_index_decl.h"
{
#if (ASSERT_CODE > 0) || ((DEBUG_CODE > 0) && defined(DEBUGGING))
    if ((char)0==sampling_table_src_file_initialized) {
        (V)path_basename(__FILE__,sampling_table_src_file,sizeof(sampling_table_src_file));
        sampling_table_src_file_initialized++;
    }
    if (DEBUGGING(SAMPLING_DEBUG))
        (V)fprintf(stderr,
            "/* %s: %s line %d: idx=%u, nmemb=%lu */\n",
            __func__,sampling_table_src_file,__LINE__,idx,nmemb);
#endif
    if (3UL>nmemb) idx=0U;
    else {
        if (idx>=(SAMPLING_TABLE_SIZE)-1U) idx=(SAMPLING_TABLE_SIZE)-2U;
        while (nmemb>psts[idx].max_nmemb) idx++;
        A((SAMPLING_TABLE_SIZE)>idx);
        while ((0U<idx)&&(nmemb<=psts[idx-1U].max_nmemb)) idx--;
    }
    A((SAMPLING_TABLE_SIZE)>idx);
#if (ASSERT_CODE > 0) || ((DEBUG_CODE > 0) && defined(DEBUGGING))
    if (DEBUGGING(SAMPLING_DEBUG))
        (V)fprintf(stderr,
            "/* %s: %s line %d: idx=%u, nmemb=%lu, max_nmemb=%lu, samples=%lu */\n",
            __func__,sampling_table_src_file,__LINE__,idx,nmemb,psts[idx].max_nmemb,psts[idx].samples);
#endif
    return idx;
}

#if ! QUICKSELECT_BUILD_FOR_SPEED
/* declaration */
#include "sampling_table_decl.h"
;
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* size_t floor of square root of size_t argument */
#if QUICKSELECT_BUILD_FOR_SPEED
static QUICKSELECT_INLINE
#endif
size_t size_t_sqrt(size_t n)
{
    if (1UL<n) {                /* else sqrt(1)=1, sqrt(0)=0 */
        size_t q, r, s, t;

        q=(n>>2);               /* q=n/4 */
        r=size_t_sqrt(q);       /* r=sqrt(n/4) ~ sqrt(n)/2 */
        s=(r<<1);               /* s=2r ~ sqrt(n) */
        t=s+1UL;                /* t=s+1 */
#if DEBUG_CODE
        if (DEBUGGING(SORT_SELECT_DEBUG))
            (V)fprintf(stderr,
                "/* %s line %d: n=%lu, q=%lu, r=%lu, s=%lu, t=%lu t*t=%lu */\n",
                __func__,__LINE__,n,q,r,s,t,t*t);
#endif
        /* s if t^2>n, else t */
        if ((((SIZE_MAX)>>1)<t)||(t*t>n)) return s; else return t;
    }
    return n;                   /* sqrt(1)=1, sqrt(0)=0 */
}

/* floor of base 3 logarithm of size_t argument */
#if QUICKSELECT_BUILD_FOR_SPEED
static QUICKSELECT_INLINE
#endif
size_t floor_log3(register size_t n)
{
    switch (n) {
        default :
            { register size_t l, m, x=floor_log3(SIZE_MAX);
                /* n not an exact power of 3
                   n < SIZE_MAX
                   stop when l==x to avoid overflow of m
                */
                for (l=0UL,m=3UL; (l<x)&&(m<n); l++,m*=3UL) ;
                return l;
            }
        break;
        /* huge case */
        case (SIZE_MAX) :
#if ( SIZE_MAX > 65535 ) /* > 16 bits */
# if ( SIZE_MAX > 4294967295 ) /* > 32 bits */
        return 40UL; /* 64 bits */
# endif /* > 32 bits */
        return 20UL; /* 32 bits */
#else
        return 10UL; /* 16 bits */
#endif /* > 16 bits */
        /* exact cases */
#if ( SIZE_MAX > 65535 ) /* > 16 bits */
# if ( SIZE_MAX > 4294967295 ) /* > 32 bits */
/*    2^64 = 18446744073709551616 */
        case 12157665459056928801UL : return 40UL;
        case 4052555153018976267UL  : return 39UL;
        case 1350851717672992089UL  : return 38UL;
        case 450283905890997363UL   : return 37UL;
        case 150094635296999121UL   : return 36UL;
        case 50031545098999707UL    : return 35UL;
        case 16677181699666569UL    : return 34UL;
        case 5559060566555523UL     : return 33UL;
        case 1853020188851841UL     : return 32UL;
        case 617673396283947UL      : return 31UL;
        case 205891132094649UL      : return 30UL;
        case 68630377364883UL       : return 29UL;
        case 22876792454961UL       : return 28UL;
        case 7625597484987UL        : return 27UL;
        case 2541865828329UL        : return 26UL;
        case 847288609443UL         : return 25UL;
        case 282429536481UL         : return 24UL;
        case 94143178827UL          : return 23UL;
        case 31381059609UL          : return 22UL;
        case 10460353203UL          : return 21UL;
# endif /* > 32 bits */
        case 3486784401UL           : return 20UL;
        case 1162261467UL           : return 19UL;
        case 387420489UL            : return 18UL;
        case 129140163UL            : return 17UL;
        case 43046721UL             : return 16UL;
        case 14348907UL             : return 15UL;
        case 4782969UL              : return 14UL;
        case 1594323UL              : return 13UL;
        case 531441UL               : return 12UL;
        case 177147UL               : return 11UL;
#endif /* > 16 bits */
        case 59049UL                : return 10UL;
        case 19683UL                : return 9UL;
        case 6561UL                 : return 8UL;
        case 2187UL                 : return 7UL;
        case 729UL                  : return 6UL;
        case 243UL                  : return 5UL;
        case 81UL                   : return 4UL;
        case 27UL                   : return 3UL;
        case 9UL                    : return 2UL;
        case 3UL                    : return 1UL;
        case 1UL                    : return 0UL;
        /* argument error */
        case 0UL                    : return 0UL;
    }
}

#if ! __STDC_WANT_LIB_EXT1__ && ! defined(DEBUGGING)
double mos_middle_power = 0.810;
double mos_ends_power = 0.810;
#else
extern double mos_middle_power;
extern double mos_ends_power;
#endif
static double mos_middle_multiplier = 0.0;
static double mos_ends_multiplier = 0.0;

/* determine the number of samples to use for pivot selection */
#if QUICKSELECT_BUILD_FOR_SPEED
static QUICKSELECT_INLINE
#endif
size_t samples(size_t nmemb, int method, unsigned int distribution,
    unsigned int options)
{
    register size_t n, r;
    struct sampling_table_struct *pst;

#if (DEBUG_CODE > 0) && defined(DEBUGGING)
    if (DEBUGGING(SAMPLING_DEBUG))
        (V)fprintf(stderr,
            "/* %s line %d: nmemb=%lu, method=%d, distribution=%u, "
            "options=0x%x */\n",
            __func__,__LINE__,nmemb,method,distribution,options);
#endif
    switch (method) {
        case QUICKSELECT_PIVOT_REMEDIAN_FULL :
            n=floor_log3(n);
        break;
        case QUICKSELECT_PIVOT_REMEDIAN_SAMPLES :
            /* sampling table and initial estimate (binary search) of index */
            switch (distribution) {
                /* separated ranks near ends, none in middle; reduced number of
                   samples because precise split is not necessary -- both
                   regions will be processed, and each of those will have ranks
                   at one end
                */
                case 5U : /*FALLTHROUGH*/
                /* cases 1 and 4 not using median of samples (never happens) */
                case 1U : /*FALLTHROUGH*/ case 4U :
                    pst=ends_sampling_table;
                    r=nmemb<=
#if ( SIZE_MAX < 65535 )
# error "SIZE_MAX < 65535 [C11 draft N1570 7.20.3]"
#elif ( SIZE_MAX == 65535 ) /* 16 bits */
                        pst[1].max_nmemb?1UL:2UL
#elif ( SIZE_MAX == 4294967295 ) /* 32 bits */
                        pst[2].max_nmemb?1UL:3UL
#elif ( SIZE_MAX == 18446744073709551615UL ) /* 64 bits */
                        pst[5].max_nmemb?2UL:7UL
#else
# error "strange SIZE_MAX " SIZE_MAX
#endif /* word size */
                    ;
                break;
                case 2U : /*FALLTHROUGH*/
                    pst=middle_sampling_table;
                    r=nmemb<=
#if ( SIZE_MAX < 65535 )
# error "SIZE_MAX < 65535 [C11 draft N1570 7.20.3]"
#elif ( SIZE_MAX == 65535 ) /* 16 bits */
                        pst[2].max_nmemb?1UL:3UL
#elif ( SIZE_MAX == 4294967295 ) /* 32 bits */
                        pst[5].max_nmemb?2UL:7UL
#elif ( SIZE_MAX == 18446744073709551615UL ) /* 64 bits */
                        pst[9].max_nmemb?5UL:14UL
#else
# error "strange SIZE_MAX " SIZE_MAX
#endif /* word size */
                    ;
                break;
                case 3U : /*FALLTHROUGH*/ case 6U : /* cases 3 and 6 use sorting table */
                case 7U : /*FALLTHROUGH*/ /* case 7 uses sorting table */
                default : /* sorting */
                    pst=sorting_sampling_table;
                    r=nmemb<=
#if ( SIZE_MAX < 65535 )
# error "SIZE_MAX < 65535 [C11 draft N1570 7.20.3]"
#elif ( SIZE_MAX == 65535 ) /* 16 bits */
                        pst[2].max_nmemb?1UL:3UL
#elif ( SIZE_MAX == 4294967295 ) /* 32 bits */
                        pst[5].max_nmemb?2UL:8UL
#elif ( SIZE_MAX == 18446744073709551615UL ) /* 64 bits */
                        pst[9].max_nmemb?5UL:14UL
#else
# error "strange SIZE_MAX " SIZE_MAX
#endif /* word size */
                    ;
                break;
            }
            /* refine index (linear search) */
            r=(size_t)SAMPLE_INDEX_FUNCTION_NAME(pst,(unsigned int)r,nmemb);
            /* # samples from table */
            n=pst[r].samples;
        break;
        case QUICKSELECT_PIVOT_MEDIAN_OF_MEDIANS :
            n = nmemb/3UL; /* number of medians */
        break;
        default :
#if ASSERT_CODE + DEBUG_CODE
            (V)fprintf(stderr,"%s line %d: unrecognized pivot method %d\n",
                __func__,__LINE__,method);
        break;
#else   /*FALLTHROUGH*/
#endif /* ASSERT_CODE + DEBUG_CODE */
        case QUICKSELECT_PIVOT_MEDIAN_OF_SAMPLES :
            switch (distribution) {
                case 3U : /*FALLTHROUGH*/ case 6U : /*FALLTHROUGH*/ /* cases 3 and 6 use middle table */
                case 2U :
                    pst=mos_middle_sampling_table;
                break;
                case 1U : /*FALLTHROUGH*/ case 4U :
                    pst=mos_ends_sampling_table;
                break;
                case 5U : /*FALLTHROUGH*/ /* case 5 uses sorting table */
                /* case 5 uses remedian except for size_ratio 1 */
                case 7U : /*FALLTHROUGH*/ /* case 7 uses sorting table */
                default : /* 000 sorting */
                    pst=mos_sorting_sampling_table;
                break;
            }
            if (pst[SAMPLING_TABLE_SIZE-1].max_nmemb>=nmemb) {
                /* sample sizes differ for small nmemb */
                for (r=0UL; r<SAMPLING_TABLE_SIZE; r++) {
                    if (nmemb<=pst[r].max_nmemb) {
                        n=pst[r].samples;
                        break;
                    }
                }
            } else { /* compute number of samples for nmemb */
                /* odd # samples 2*k+1 for k proportional to sqrt(nmemb) */
                if (pst==mos_middle_sampling_table) {
                    /* Martinez & Roura found optimum samples for median pivot
                       selection to be 1+2*sqrt(nmemb/4/Beta), where Beta is the
                       scaled number of comparisons for median selection.  So,
                       for 2.25N selection cost, use 1+2*sqrt(nmemb/9).  For 2N,
                       use 1+2*sqrt(nmemb/8); for 1.75N, use 1+2*sqrt(nmemb/7);
                       for 1.5N, use 1+2*sqrt(nmemb/6).
                       However, empirical testing shows that the optimum number
                       of samples is much greater for large arrays.
                    */
                    if (0.0==mos_middle_multiplier) {
                        /* Match multiplier to top end of table values. */
                        n=pst[SAMPLING_TABLE_SIZE-2].max_nmemb
                            +pst[SAMPLING_TABLE_SIZE-1].max_nmemb;
                        mos_middle_multiplier
                            =(double)
                            ((pst[SAMPLING_TABLE_SIZE-1].samples-1UL)>>1)
                            /pow(0.5*(double)n,mos_middle_power);
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
                        if (DEBUGGING(SAMPLING_DEBUG))
                            (V)fprintf(stderr,
                                "/* %s line %d: mos_middle_power=%.3f, "
                                "mos_middle_multiplier=%.5f */\n",
                                __func__,__LINE__,mos_middle_power,
                                mos_middle_multiplier);
#endif
                    }
                    n = 1UL +
                        (((size_t)(pow((double)nmemb,mos_middle_power)
                        *mos_middle_multiplier))<<1);
                } else if (pst==mos_ends_sampling_table) {
                    /* Pivot selection for pivot rank near an array end uses
                       about twice as many samples as for a median pivot.
                    */
                    if (0.0==mos_ends_multiplier) {
                        /* Match multiplier to top end of table values. */
                        n=pst[SAMPLING_TABLE_SIZE-2].max_nmemb
                            +pst[SAMPLING_TABLE_SIZE-1].max_nmemb;
                        mos_ends_multiplier
                            =(double)
                            ((pst[SAMPLING_TABLE_SIZE-1].samples-1UL)>>1)
                            /pow(0.5*(double)n,mos_ends_power);
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
                        if (DEBUGGING(SAMPLING_DEBUG))
                            (V)fprintf(stderr,
                                "/* %s line %d: mos_ends_power=%.3f, "
                                "mos_ends_multiplier=%.5f */\n",
                                __func__,__LINE__,mos_ends_power,
                                mos_ends_multiplier);
#endif
                    }
                    n = 1UL +
                        (((size_t)(pow((double)nmemb,mos_ends_power)
                        *mos_ends_multiplier))<<1);
                } else { /* mos_sorting_sampling_table */
                    /* n (the number of samples to use for sorting) depends on
                       Beta (the cost of selecting the median of samples), which
                       varies with n.  A table is used for small nmemb, which
                       uses small n (where Beta varies from 1 to about 2.2).
                       For n roughly from 40 to 256, Beta is a maximum at about
                       2.2, and the corresponding range for nmemb is 4800 to
                       196608 elements.  Beta is ~ 1.98 at n ~ 1800, ~ 1.8 at
                       n ~ 8000, ~ 1.62 at n ~ 60000, and asymptotically
                       approaches 1.5.  Because nmemb increases with the square
                       of the number of samples, the computation using Beta~2.16
                       is used for all but very large arrays (and very small
                       ones using the table values).
                    */
                    if (1340000UL>nmemb) { /* < 651 samples */
                        n = ((size_t_sqrt(nmemb/12UL))<<1) + 1UL; /* sqrt(nmemb/3) [2*beta*ln(2) = 3 for beta=2.16404] */
                    } else if (44011800UL>nmemb) { /* ~4201 samples */
                        n = ((size_t_sqrt(nmemb/11UL))<<1) + 1UL; /* beta ~ 1.98 */
                    } else if (22460000000UL>nmemb) { /* ~100001 samples */
                        n = ((size_t_sqrt(nmemb/10UL))<<1) + 1UL; /* beta ~ 1.8 */
                    } else {
                        n = ((size_t_sqrt(nmemb/9UL))<<1) + 1UL; /* beta ~ 1.62 */
                    }
                }
            }
        break;
    }
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
    if (DEBUGGING(SAMPLING_DEBUG))
        (V)fprintf(stderr,
            "/* %s line %d: nmemb=%lu, n=%lu, r=%lu, method=%d, options=0x%x */\n",
            __func__,__LINE__,nmemb,n,r,method,options);
#endif
    return n;
}

/* Determine a suitable method for pivot selection. */
#if QUICKSELECT_BUILD_FOR_SPEED
static QUICKSELECT_INLINE
#endif
int pivot_method(size_t *pk, size_t nmemb, size_t firstk, size_t beyondk,
    unsigned int raw_distribution, size_t size_ratio, unsigned int options)
{
#if (ASSERT_CODE > 0) || ((DEBUG_CODE > 0) && defined(DEBUGGING))
    if ((char)0==sampling_table_src_file_initialized) {
        (V)path_basename(__FILE__,sampling_table_src_file,sizeof(sampling_table_src_file));
        sampling_table_src_file_initialized++;
    }
    if (DEBUGGING(PIVOT_SELECTION_DEBUG))
        (V)fprintf(stderr,
            "/* %s: %s line %d: pk=%p, distribution=%u, size_ratio=%lu, options"
            "=0x%x */\n",__func__,sampling_table_src_file,__LINE__,
            pk,raw_distribution,size_ratio,options);
#endif /* DEBUG DEBUGGING */
#if QUICKSELECT_STABLE
    /* Stable sorting or selection requires preserving partial order during
       pivot selection. In-place remedian is used.
    */
    if (0U!=(options&(QUICKSELECT_STABLE))) {
        if (0U!=(options&(QUICKSELECT_RESTRICT_RANK)))
            return QUICKSELECT_PIVOT_REMEDIAN_FULL ;
        return QUICKSELECT_PIVOT_REMEDIAN_SAMPLES ;
    } else
#endif /* QUICKSELECT_STABLE */
    /* Pivot selection requiring restricted rank (break-glass) uses
       median-of-medians or full remedian (for stable sorting/selection).
    */
    if (0U!=(options&(QUICKSELECT_RESTRICT_RANK)))
        return QUICKSELECT_PIVOT_MEDIAN_OF_MEDIANS ;
    else {
        /* Might use "median" of samples with offset rank or true median of
           samples. In either case, sample data movement is relatively costly;
           it can introduce disorder into already-sorted input (which will
           have to be undone during partitioning and recursion) and data
           movement for large elements is expensive.  There are a few
           mitigating cases: if comparisons are very costly, median of samples
           yields fewer overall comparisons than remedian of samples (but more
           swaps).  For trivial (basic types) data, the additional data
           movement costs might be acceptable.  Finally, selection (vs. sorting)
           for order statistics which are grouped on one side of the sub-array,
           selection of the pivot from the samples can use a rank other than the
           median of the samples, to (ideally) eliminate more than half of the
           sub-array, reducing recursion (actually iteration) depth.
        */
        if (0U!=(options&(QUICKSELECT_OPTIMIZE_COMPARISONS)))
            return QUICKSELECT_PIVOT_MEDIAN_OF_SAMPLES ;
        if ((NULL!=pk)&&(beyondk>firstk)) { /* maybe offset rank for selection */
        /* Suitable distributions for median of samples (based primarily on
           number of swaps) depends on the partitioning method.
        */
            /* independent of size_ratio */
            if ((1U==raw_distribution)||(4U==raw_distribution))
                return QUICKSELECT_PIVOT_MEDIAN_OF_SAMPLES ;
            /* for basic types (size_ratio==1) because of swaps */
            if (
            (5U!=raw_distribution)
            &&(1UL==size_ratio)
            )
                return QUICKSELECT_PIVOT_MEDIAN_OF_SAMPLES ;
        }
    }
    return QUICKSELECT_PIVOT_REMEDIAN_SAMPLES ;
}

/* kgroups returns the number of groups of contiguous order statistic ranks in
   [pk[firstk],pk[beyondk]).
*/
static QUICKSELECT_INLINE
size_t kgroups(size_t *pk, size_t firstk, size_t beyondk)
{
    register size_t n, p, q;

    if (firstk<beyondk) n=1UL; else n=0UL;
    for (p=pk[firstk++]; firstk<beyondk; p=q,firstk++) {
        q=pk[firstk];
        if (1UL<q-p) n++; /* gap delimits groups */
    }
    return n;
}

/* sampling_table: determine distribution of order statistic ranks */
/* called from select_pivot, quickselect_loop and quickselect public wrapper
   function
*/
#if QUICKSELECT_BUILD_FOR_SPEED
static QUICKSELECT_INLINE
#endif /* QUICKSELECT_BUILD_FOR_SPEED */
#include "sampling_table_decl.h"
/*
unsigned int SAMPLING_TABLE_FUNCTION_NAME(size_t first,
    size_t beyond, const size_t *pk, size_t firstk, size_t beyondk, char **ppeq,
    const size_t **ppk, size_t nmemb, size_t size_ratio, unsigned int options)
*/
{
    unsigned int raw=0U, sort=1U;

#if ! QUICKSELECT_BUILD_FOR_SPEED
    if ((char)0==file_initialized) initialize_file(__FILE__);
#endif /* QUICKSELECT_BUILD_FOR_SPEED */
#if (ASSERT_CODE > 0) || ((DEBUG_CODE > 0) && defined(DEBUGGING))
    if ((char)0==sampling_table_src_file_initialized) {
        (V)path_basename(__FILE__,sampling_table_src_file,sizeof(sampling_table_src_file));
        sampling_table_src_file_initialized++;
    }
#endif
    /* Median-of-medians uses extents to avoid redundant comparisons (by
       rearranging partitioned medians).  Sorting partitions the set of medians
       around a pivot which is not necessarily the median of the medians.  But
       any element in a sorted array partitions that array.  Specifically for
       selection of the median of medians, pk!=NULL (selecting) and ppeq!=NULL
       (extents are desired for the purpose of rearranging the partitioned
       medians to avoid recomparisons).  If the medians are sorted, 1) the pivot
       is not necessarily the median of the medians, 2) the median of medians is
       found via the index corresponding to the middle rank, and 3) the extent
       of ranks of medians (elements) comparing equal to the median-of-medians
       is unknown.  However, a simple linear scan (or binary search) of each
       half of the sub-array of medians can determine the extents.  A pair of
       linear scans is expected to use M/2 comparisons (where M is the number of
       medians), and a pair of binary searches is expected to use 2log(M/2) =
       2logM-2 = 2(logM-1) comparisons.  For P groups of order statistic ranks,
       selection is expected to take (2+logP)M comparisons and sorting is
       expected to take MlogM comparisons.  For median-of-medians, P=1,
       therefore selection is expected to take 2M comparisons for M medians vs.
       sorting which requires MlogM comparisons plus min(M/2,2(logM-1))
       comparisons to find the extents.  Finding the extents at cost
       min(M/2,2(logM-1)) comparisons saves repeating M-1 comparisons of the
       medians vs. the median of medians.  For median-of-medians, the choice is
       between 2M comparisons for selection vs. MlogM+min(M/2,2(logM-1)) for
       sorting plus finding extents.  M is a power of 3.  Sorting plus finding
       extents is more costly because MlogM grows much faster than 2M.
    */
    if ((NULL!=pk)&&(NULL==ppeq) /* selection, no extents required */
    &&(0U==(options&(QUICKSELECT_STRICT_SELECTION))) /* not strict selection */
    ) {
        /* Sort if expected cost 2+logP=log(4P) of selection of P groups of
           order statistic ranks is greater than the expected cost log(nmemb)
           for sorting.  Because log is a monotonic function, it suffices to
           compare 4P vs. nmemb, or equivalently, P vs. nmemb/4.  If this
           simple comparison results in sorting, it is not necessary to
           characterize to distribution of desired order statistics in bands.
        */
        size_t kg=kgroups(pk,firstk,beyondk);
        if (kg>(nmemb>>2)) pk=NULL; /* sort */
    }
    if (NULL!=pk) { /* selection, not sorting */
        size_t bk, fk, m1, m2, nk, nl, nr, x;
        A(beyondk>firstk);
        nk=beyondk-firstk;
        /* Characterize distribution of desired order statistic ranks */
        /* median(s): lower(m1) and upper (m2) */
        m1=first+((nmemb-1UL)>>1); m2=first+(nmemb>>1);
        /* middle range 1/4-3/4 is appropriate for median of samples */
        /* For nmemb=4 (indices 0 1 2 3), m1=1, m2=2
           left 1/4 region is [0,1), middle 1/2 is [1,3), right 1/4 is [3,4)
           x is offset from m1,m2 for regions
           for nmemb=4, x=0; should be 1 starting at nmemb=7
        */
        A(nmemb>2UL);
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
        if (nmemb<3UL) {
            (V)fprintf(stderr,
                "/* %s: %s line %d: nmemb=%lu, nk=%lu, first=%lu, "
                "m1=%lu, m2=%lu, beyond=%lu, firstk=%lu, beyondk=%lu, pk[%lu]="
                "%lu, pk[%lu]=%lu */\n",__func__,sampling_table_src_file,__LINE__,
                (unsigned long)nmemb,(unsigned long)nk,
                (unsigned long)first,(unsigned long)m1,
                (unsigned long)m2,(unsigned long)beyond,(unsigned long)firstk,
                (unsigned long)beyondk,(unsigned long)firstk,
                (unsigned long)pk[firstk],(unsigned long)beyondk-1UL,
                (unsigned long)pk[beyondk-1UL]);
            abort();
        }
#endif
        x=(((nmemb+1UL)>>2)-1UL);
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
        if (DEBUGGING(SAMPLING_DEBUG)
        ||DEBUGGING(REPARTITION_DEBUG)
        ||DEBUGGING(REPIVOT_DEBUG)
        )
            (V)fprintf(stderr,
                "/* %s: %s line %d: nmemb=%lu, nk=%lu, x=%lu, first=%lu, "
                "m1=%lu, m2=%lu, beyond=%lu, firstk=%lu, beyondk=%lu, pk[%lu]="
                "%lu, pk[%lu]=%lu */\n",__func__,sampling_table_src_file,__LINE__,
                (unsigned long)nmemb,(unsigned long)nk,
                (unsigned long)x,(unsigned long)first,(unsigned long)m1,
                (unsigned long)m2,(unsigned long)beyond,(unsigned long)firstk,
                (unsigned long)beyondk,(unsigned long)firstk,
                (unsigned long)pk[firstk],(unsigned long)beyondk-1UL,
                (unsigned long)pk[beyondk-1UL]);
#endif
        /* desired ranks in left region [first,m1-x) */
        KLIMITS_FUNCTION_NAME(first,m1-x,pk,firstk,beyondk,&fk,&bk);
        nl = ((bk>fk)?bk-fk:0UL); /* ranks in left region */
        if (0UL!=nl) raw|=4U; /* there are ranks in the left region */
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
        if (DEBUGGING(SAMPLING_DEBUG)
        ||DEBUGGING(REPARTITION_DEBUG)
        ||DEBUGGING(REPIVOT_DEBUG)
        )
            (V)fprintf(stderr,
                "/* %s: %s line %d: %lu in left\n",
                __func__,sampling_table_src_file,__LINE__,nl);
#endif
        if (nl<nk) {
            /* desired ranks in right region [m2+x+1UL,beyond) */
            KLIMITS_FUNCTION_NAME(m2+x+1UL,beyond,pk,firstk,beyondk,&fk,&bk);
            nr = ((bk>fk)?bk-fk:0UL); /* ranks in right region */
            if (0UL!=nr) raw|=1U; /* there are ranks in the right region */
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
            if (DEBUGGING(SAMPLING_DEBUG)
            ||DEBUGGING(REPARTITION_DEBUG)
            ||DEBUGGING(REPIVOT_DEBUG)
            )
                (V)fprintf(stderr,
                    "/* %s: %s line %d: %lu in right\n",
                    __func__,sampling_table_src_file,__LINE__,nr);
#endif
            if (nl+nr<nk) raw|=2U; /* there are ranks in the middle */
        }
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
        if (DEBUGGING(SAMPLING_DEBUG)
        ||DEBUGGING(REPARTITION_DEBUG)
        ||DEBUGGING(REPIVOT_DEBUG)
        )
            (V)fprintf(stderr,
                "/* %s: %s line %d: first=%lu, beyond=%lu, nmemb=%lu, raw "
                "distribution=%u, ppeq=%p, firstk=%lu, beyondk=%lu, pk[%lu]=%lu"
                ", pk[%lu]=%lu */\n",__func__,sampling_table_src_file,__LINE__,
                (unsigned long)first,(unsigned long)beyond,(unsigned long)nmemb,
                raw,(void *)ppeq,(unsigned long)firstk,(unsigned long)beyondk,
                (unsigned long)firstk,(unsigned long)pk[firstk],
                (unsigned long)beyondk-1UL,(unsigned long)pk[beyondk-1UL]);
#endif
        if (NULL==ppeq) {
            /* Worst-case sort of 3 elements costs 3 comparisons and at most
               2 swaps.  Worst-case selection of minimum or maximum of 3
               elements (with MINMAX) costs 2 comparisons and at most 1 swap.
               Sorting of 3 elements (i.e. selection of both minimum and
               maximum) with MINMAX costs at most 3 comparisons and at most
               2 swaps -- the same as dedicated sorting.
               Therefore, sorting is only advantageous over selection for at
               least 4 elements (depending on the distribution of the
               desired ranks).
               Moreover, simple selection cases exist for selection of order
               statistic ranks in arrays of 3 or fewer elements.
            */
            if ((0U!=(options&(QUICKSELECT_STRICT_SELECTION))) /* strict selection */
            || (0U!=(options&(QUICKSELECT_RESTRICT_RANK))) /* repivoting */
            || (nk<=3UL)) /* only a few order statistics */
                sort=0U;
            else {
                /* preliminary pivot selection method based on selection */
                int m=pivot_method(pk,nmemb,firstk,beyondk,raw,size_ratio,options);
                switch (m) {
                    case QUICKSELECT_PIVOT_REMEDIAN_SAMPLES :
                        if (0U==(options&(QUICKSELECT_OPTIMIZE_COMPARISONS))) {
                            /* run-time */
                            if (7U==raw) { /* distributed ranks */
                                if (nk<=(nmemb>>4)) /* nmemb/16 ranks */
                                    sort=0U;
                            } else { /* middle, extended, separated, ends */
                                if (nk<=(nmemb>>1)+(nmemb>>3)) /* 5/8 nmemb */
                                    sort=0U;
                            }
                        } else { /* minimum comparisons */
                            if (7U==raw) { /* distributed ranks */
                                if (nk<=(nmemb>>3)) /* nmemb/8 ranks */
                                    sort=0U;
                            } else { /* middle, extended, separated, ends */
                                if (nk<=nmemb-(nmemb>>4)) /* 15/16 nmemb */
                                    sort=0U;
                            }
                        }
                    break;
                    default : /* median of samples */
                        if (0U==(options&(QUICKSELECT_OPTIMIZE_COMPARISONS))) {
                            /* run-time */
                            if (7U==raw) { /* distributed ranks */
                                if (nk<=(nmemb/40UL))
                                    sort=0U;
                            } else { /* middle, extended, separated, ends */
                                if (nk<=(nmemb>>1)+(nmemb>>2)) /* 3/4 nmemb */
                                    sort=0U;
                            }
                        } else { /* minimum comparisons */
                            if (7U==raw) { /* distributed ranks */
                                if (nk<=(nmemb>>1)) /* nmemb/2 ranks */
                                    sort=0U;
                            } else { /* middle, extended, separated, ends */
                                sort=0U;
                            }
                        }
                    break;
                }
            }
        } else {
            /* no sort if == region extents are required */
            sort=0U;
            /* Sorting is not possible because the pivot for sorting is not
               necessarily the desired order statistic rank element.
            */
        }
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
        if (DEBUGGING(SAMPLING_DEBUG)
        ||DEBUGGING(REPARTITION_DEBUG)
        ||DEBUGGING(REPIVOT_DEBUG)
        )
            (V)fprintf(stderr,
                "/* %s: %s line %d: nmemb=%lu, distribution=%u */\n",
                __func__,sampling_table_src_file,__LINE__,(unsigned long)nmemb,
                raw);
#endif
    } /* else sorting */
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
    if (DEBUGGING(SAMPLING_DEBUG)
    ||DEBUGGING(REPARTITION_DEBUG)
    ||DEBUGGING(REPIVOT_DEBUG)
    )
        (V)fprintf(stderr,
            "/* %s: %s line %d: nmemb=%lu, sort=%u */\n",
            __func__,sampling_table_src_file,__LINE__,(unsigned long)nmemb,sort);
#endif
    if (0U!=sort) *ppk=NULL; /* sorting */
    return raw;
}
