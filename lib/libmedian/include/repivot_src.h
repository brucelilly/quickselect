/*INDENT OFF*/

/* Description: C source code for quickselect */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    repivot_src.h copyright 2017-2019 Bruce Lilly.   \ repivot_src.h $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is repivot_src.h version 1.23 dated 2019-04-19T19:56:16Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/include/s.repivot_src.h */

/********************** Long description and rationale: ***********************
 Partitioning can result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 The function in this file examines the partition result and determines whether
 or not repartitioning of the large region using a break-glass pivot selection
 method is warranted.
******************************************************************************/

/* Nothing to configure below this line. */

/* Minimum _XOPEN_SOURCE version for C99 (else illumos compilation fails) */
#undef MAX_XOPEN_SOURCE_VERSION
#undef MIN_XOPEN_SOURCE_VERSION
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# define MIN_XOPEN_SOURCE_VERSION 600 /* >=600 for illumos */
#else
# define MAX_XOPEN_SOURCE_VERSION 500 /* <=500 for illumos */
#endif

/* feature test macros defined before any header files are included */
#ifndef _XOPEN_SOURCE
# ifdef MIN_XOPEN_SOURCE_VERSION
#  define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
# else
#  ifdef MAX_XOPEN_SOURCE_VERSION
#   define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#  endif
# endif
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MIN_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE < MIN_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MAX_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE > MAX_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#endif

#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
   ID_STRING_PREFIX is suitable for the what(1) and ident(1) utilities.
   MODULE_DATE uses modern SCCS extensions.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: repivot_src.h ~|^` @(#)"
#define SOURCE_MODULE "repivot_src.h"
#define MODULE_VERSION "1.23"
#define MODULE_DATE "2019-04-19T19:56:16Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
#define COPYRIGHT_DATE "2017-2019"

/* local header files needed */
#include "quickselect_config.h" /* SELECTION_MIN_REPIVOT */
#include "tables.h"             /* struct repivot_table_struct */
#if ! QUICKSELECT_BUILD_FOR_SPEED
#include "initialize_src.h"
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* system header files */
#include <assert.h>             /* assert */
#include <stddef.h>             /* size_t NULL */

#if LIBMEDIAN_TEST_CODE
#include <limits.h>             /* PATH_MAX */
#include "paths_decl.h"         /* path_basename */
#endif

#if ( ! defined(REPIVOT_SRC_FILE_HERE)) || ( REPIVOT_SRC_FILE_HERE == 0) || (LIBMEDIAN_TEST_CODE != 0)
extern char repivot_src_file[];
extern char repivot_src_file_initialized;
#else
/* not static; referenced by inline functions */
char repivot_src_file[PATH_MAX];
char repivot_src_file_initialized=0;
#endif

/* Determine if repivoting is warranted. Return an integer indicating the
   appropriate pivot selection method: 
      0U or QUICKSELECT_RESTRICT_RANK
*/
QUICKSELECT_SHOULD_REPIVOT
{
    size_t q, ratio;
    const struct repivot_table_struct *prt;
    int i;

#if ! QUICKSELECT_BUILD_FOR_SPEED
    if ((char)0==file_initialized) initialize_file(__FILE__);
#endif /* QUICKSELECT_BUILD_FOR_SPEED */
#if LIBMEDIAN_TEST_CODE
    if ((char)0==repivot_src_file_initialized) {
        (V)path_basename(__FILE__,repivot_src_file,PATH_MAX);
        repivot_src_file_initialized++;
    }
#endif
#if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(REPARTITION_DEBUG)
    ||DEBUGGING(SHOULD_REPIVOT_DEBUG))
        (V)fprintf(stderr,"/* %s: %s line %d: nmemb=%lu, n=%lu, samples=%lu, "
            "method=%s(%d), initial options=0x%x, pk=%p */\n",__func__,
            repivot_src_file,__LINE__,nmemb,n,samples,pivot_name(method),method,
            options,(const void *)pk);
#endif
    if ((options&(QUICKSELECT_RESTRICT_RANK))==(QUICKSELECT_RESTRICT_RANK)) {
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(SHOULD_REPIVOT_DEBUG))
            (V)fprintf(stderr,"/* %s: %s line %d: initial options=0x%x "
                "no additional repivot */\n",__func__,repivot_src_file,__LINE__,
                options);
#endif
        return (options & ~(QUICKSELECT_RESTRICT_RANK)); /* not again */
    }
    options &= ~(QUICKSELECT_RESTRICT_RANK); /* clean slate */
    /* repivot factors based on current pivot selection method */
    if (NULL==pk) { /* sorting */
        switch (method) {
#if QUICKSELECT_INCLUDE_FULL_REMEDIAN
            case QUICKSELECT_PIVOT_REMEDIAN_FULL :
            /*FALLTHROUGH*/
#endif
            case QUICKSELECT_PIVOT_REMEDIAN_SAMPLES :
               prt=ros_sorting_repivot_table;
            break;
#if ! QUICKSELECT_NO_MEDIAN_OF_MEDIANS
            case QUICKSELECT_PIVOT_MEDIAN_OF_MEDIANS :
            return options; /* never repivot if already repivoted */
#endif
            case QUICKSELECT_PIVOT_MEDIAN_OF_SAMPLES :
               prt=mos_sorting_repivot_table;
            break;
#if (ASSERT_CODE > 0)
            default :
                (V)fprintf(stderr,"/* %s line %d: invalid method %d */\n",
                    __func__,__LINE__,method);
                abort();
            break;
#endif /* ASSERT_CODE */
        }
    } else { /* order statistic selection */
        switch (method) {
#if QUICKSELECT_INCLUDE_FULL_REMEDIAN
            case QUICKSELECT_PIVOT_REMEDIAN_FULL :
            /*FALLTHROUGH*/
#endif
            case QUICKSELECT_PIVOT_REMEDIAN_SAMPLES :
               prt=ros_selection_repivot_table;
            break;
#if ! QUICKSELECT_NO_MEDIAN_OF_MEDIANS
            case QUICKSELECT_PIVOT_MEDIAN_OF_MEDIANS :
            return options; /* never repivot if already repivoted */
#endif
            case QUICKSELECT_PIVOT_MEDIAN_OF_SAMPLES :
               prt=mos_selection_repivot_table;
            break;
#if (ASSERT_CODE > 0)
            default :
                (V)fprintf(stderr,"/* %s line %d: invalid method %d */\n",
                    __func__,__LINE__,method);
                abort();
            break;
#endif /* ASSERT_CODE */
        }
    }
    A(n<nmemb);
    q=nmemb-n;
    A(0UL<q);
    if (n<=q) { /* ratio 0; return w/o incurring division cost */
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(REPARTITION_DEBUG)
        ||DEBUGGING(SHOULD_REPIVOT_DEBUG))
            (V)fprintf(stderr,"/* %s: %s line %d: nmemb=%lu, n=%lu, samples=%lu"
                ", pk=%p, ratio<1, no repivot */\n",
                __func__,repivot_src_file,__LINE__,nmemb,n,
                samples,(const void *)pk);
#endif
        return options;
    }
    ratio=n/q;
    for (i=0; samples>=prt[i+1].min_samples; i++) ; /* index for table entry */
#if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(REPARTITION_DEBUG))
        (V)fprintf(stderr,"/* %s: %s line %d: i=%d, "
            "samples=%lu>=%lu */\n",
            __func__,repivot_src_file,__LINE__,i,samples,
            prt[i].min_samples);
#endif
    if ((ratio>=prt[i].factor1)
    || ((ratio>=prt[i].factor2)&&(++*pn2>=2))) {
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(REPARTITION_DEBUG)
        ||DEBUGGING(SHOULD_REPIVOT_DEBUG))
            (V)fprintf(stderr,"/* %s: %s line %d: nmemb=%lu, n=%lu, "
                "samples=%lu>=%lu, method=%s(%d), pk=%p, ratio=%lu, "
                "factor1=%d, factor2=%d, count=%d, repivot */\n",
                __func__,repivot_src_file,__LINE__,nmemb,n,samples,
                prt[i].min_samples,pivot_name(method),method,(const void *)pk,
                ratio,prt[i].factor1,prt[i].factor2,
                *pn2-((ratio<prt[i].factor1)&&(ratio>=prt[i].factor2)?1:0));
#endif
        options |= QUICKSELECT_RESTRICT_RANK;
#if LIBMEDIAN_TEST_CODE
    } else {
        if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(REPARTITION_DEBUG)
        ||DEBUGGING(SHOULD_REPIVOT_DEBUG))
            (V)fprintf(stderr,"/* %s: %s line %d: nmemb=%lu, n=%lu, "
                "samples=%lu>=%lu, method=%s(%d), repivot_table=%s, "
                "table index=%d, pk=%p, ratio=%lu, options=0x%x, "
                "factor1=%d, factor2=%d, count=%d, no repivot */\n",
                __func__,repivot_src_file,__LINE__,nmemb,n,samples,
                prt[i].min_samples,pivot_name(method),method,
                repivot_table_name(prt),i,(const void *)pk,
                ratio,options,prt[i].factor1,prt[i].factor2,
                *pn2-((ratio<prt[i].factor1)&&(ratio>=prt[i].factor2)?1:0));
#endif
    }
    return options;
}
