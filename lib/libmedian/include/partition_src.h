#ifndef PARTITION_SRC_H_INCLUDED
# define PARTITION_SRC_H_INCLUDED 1
/*INDENT OFF*/

/* Description: C source code for partition */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    partition_src.h copyright 2017-2019 Bruce Lilly.   \ partition_src.h $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is partition_src.h version 1.24 dated 2019-03-16T15:37:11Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/include/s.partition_src.h */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and a pair of indices brackets the sub-array
 being processed.  The indices correspond to the ranks of elements.  A similar
 scheme is used by Musser's introsort, described in "Introspective Sorting and
 Selection Algorithms".  The same method is used for the array of desired order
 statistic ranks, similar to that described by Lent & Mahmoud.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.
 Partitioning can still result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by efficient inline swap functions.  No attempt
 is made to optimize for specific array element types, but swapping can be
 performed in units of basic language types.  The swap functions avoid useless
 work (e.g. when given two pointers to the same element).  No specialized macros
 are required.
******************************************************************************/

/* Minimum _XOPEN_SOURCE version for C99 (else illumos compilation fails) */
#undef MAX_XOPEN_SOURCE_VERSION
#undef MIN_XOPEN_SOURCE_VERSION
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# define MIN_XOPEN_SOURCE_VERSION 600 /* >=600 for illumos */
#else
# define MAX_XOPEN_SOURCE_VERSION 500 /* <=500 for illumos */
#endif

/* feature test macros defined before any header files are included */
#ifndef _XOPEN_SOURCE
# ifdef MIN_XOPEN_SOURCE_VERSION
#  define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
# else
#  ifdef MAX_XOPEN_SOURCE_VERSION
#   define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#  endif
# endif
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MIN_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE < MIN_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MAX_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE > MAX_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#endif

#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
   ID_STRING_PREFIX is suitable for the what(1) and ident(1) utilities.
   MODULE_DATE uses modern SCCS extensions.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: partition_src.h ~|^` @(#)"
#define SOURCE_MODULE "partition_src.h"
#define MODULE_VERSION "1.24"
#define MODULE_DATE "2019-03-16T15:37:11Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
#define COPYRIGHT_DATE "2017-2019"

/* Although the implementation is different, several concepts are adapted from:
   qsort -- qsort interface implemented by faster quicksort.
   J. L. Bentley and M. D. McIlroy, SPE 23 (1993) 1249-1265.
   Copyright 1993, John Wiley.
   Also using modifications to avoid self-swapping from:
   Partitioning schemes for quicksort and quickselect, Krzysztof C. Kiwiel.
   And avoiding recomparisons as suggested in:
   Optimal Sampling Strategies for Quicksort, McGeoch, C. C. and Tygar, J. D.
*/

/* configuration options */
#ifndef ASSERT_CODE
# define ASSERT_CODE             0 /* for test; 0 for production code */
#endif

/* local header files needed */
#include "median_test_config.h" /* aqcmp pivot_minrank */
#include "quickselect_config.h"
#include "exchange.h"           /* blockmove irotate EXCHANGE_SWAP */
#include "indirect.h"           /* rearrange_array */
#if ! QUICKSELECT_BUILD_FOR_SPEED
#include "initialize_src.h"
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* system header files */
#include <assert.h>             /* assert */
#include <stddef.h>             /* size_t NULL */
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201101L) /* C11 */
# include <stdalign.h>          /* alignas alignof etc. */
#endif /* C11 */
#if ASSERT_CODE
# include <stdio.h>
#endif

#if (QUICKSELECT_STABLE != 0)
/* static data */
static const size_t pointer_and_char = sizeof(char *)+sizeof(char);

/* merge 2 adjacent canonical partitions */
/* +-----------------------------+
   | L< | L= | L> | R< | R= | R> |
   +-----------------------------+
    |    |    |    |    |    |   |
    (l)  eq1  gt1  mid  eq2  gt2  (u)
     |    \       X       /    |
     |     \     / \     /     |
     |      \   /   \   /      |
     |       \ /     \ /       |
     |        X       X        |
     v       / \     / \       v
   +-----------------------------+
   | L< | R< | L= | R= | L> | R> |
   +-----------------------------+
*/
/* Supports both non-stable merge using blockmoves and stable merge using
   permutation or rotations.
*/
static QUICKSELECT_INLINE
void merge_partitions(char *base, size_t first, size_t eq1, size_t gt1,
    size_t mid, size_t eq2, size_t gt2, size_t beyond, size_t size,
    void (*swapf)(char*, char*, size_t), size_t alignsize, size_t size_ratio,
    size_t cachesize, unsigned int options, size_t *peq, size_t *pgt)
{
    A(first<mid);A(mid<beyond);
    A(first<=eq1);A(eq1<=gt1);A(gt1<=mid);A(mid<=eq2);A(eq2<=gt2);A(gt2<=beyond);
    if (((mid>gt1)&&(gt2>mid))||((eq2>mid)&&(mid>eq1))) { /* something to do */
        register size_t leq=gt1-eq1, req=gt2-eq2, rlt=eq2-mid;
        register size_t lgt=mid-gt1, m=(lgt<rlt?lgt:rlt); /* minimum of lgt, rlt */
        size_t n=gt2-eq1; /* maximum number of elements that need to be moved */
        /* +-----------------------+
           | < | = | > | < | = | > |
           +-----------------------+
            |   |   |   |   |   |   |
            (l) eq1 gt1 mid eq2 gt2  (u)
        */
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(PARTITION_DEBUG)) {
            (V)fprintf(stderr,
                "/* %s: %s line %d: first=%lu, mid=%lu, eq1=%lu, gt1=%lu: "
                "left partition: leq=%lu, lgt=%lu */\n",
                __func__,source_file,__LINE__,first,mid,eq1,gt1,leq,lgt);
                if (MAX_ARRAY_PRINT>beyond-first)
                    print_some_array(base,first,mid-1UL, "/* "," */",
                        options);
            (V)fprintf(stderr,
                "/* %s: %s line %d: mid=%lu, beyond=%lu, eq2=%lu, gt2=%lu: "
                "right partition: req=%lu, rgt=%lu, nsw=%lu */\n",
                __func__,source_file,__LINE__,mid,beyond,eq2,gt2,req,rlt,nsw);
                if (MAX_ARRAY_PRINT>beyond-first)
                    print_some_array(base,mid,beyond-1UL, "/* "," */",
                        options);
        }
# endif
        A(first<mid);A(mid<beyond);A(first<=eq1);A(eq1<=gt1);A(gt1<=mid);
        A(mid<=eq2);A(eq2<=gt2);A(gt2<=beyond);
        /* +-----------------------------+ */
        /* | L< | L= | L> | R< | R= | R> | */
        /* +-----------------------------+ */
        /* (l)  eq1  gt1  mid  eq2  gt2  (u) */
        switch (options&(QUICKSELECT_STABLE)) {
            default :
                /* +-----------------------------+
                   | L< | L= | L> | R< | R= | R> |
                   +-----------------------------+
                         a    b    c    d    e
                   A series of 3 blockmoves merges the partitions:
                   1.             X
                   +-----------------------------+
                   | L< | L= | R< | L> | R= | R> |
                   +-----------------------------+
                   2&3.      X     c   X
                   +-----------------------------+
                   | L< | R< | L= | R= | L> | R> |
                   +-----------------------------+
                              b    c    d
                   N.B. blockmoves do not preserve order within blocks.
                */
                {
                    char *pa, *pb, *pc, *pd, *pe;
                    pa=base+size*eq1, pb=base+size*gt1, pc=base+size*mid,
                        pd=base+size*eq2, pe=base+size*gt2;
                    pc=blockmove(pb,pc,pd,swapf);
                    pb=blockmove(pa,pb,pc,swapf);
                    pd=blockmove(pc,pd,pe,swapf);
                    *peq=(pb-base)/size, *pgt=(pd-base)/size;
                }
            break;
            case QUICKSELECT_STABLE :
                if (size+n*sizeof(size_t)<cachesize) {
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201101L) /* C11 */
                    _Alignas((QUICKSELECT_DEFAULT_ALIGNMENT)) /* probably most restrictive cache line size (bytes) */
#endif /* C11 */
                    size_t indices[n];
                    register size_t i=0UL;
                    /* +-----------------------+
                       | < | = | > | < | = | > |
                       +-----------------------+
                        |   |   |   |   |   |   |
                        (l) eq1 gt1 mid eq2 gt2  (u)
                    */
                    for (m=mid; m<eq2; i++,m++) indices[i]=m;
                    for (m=eq1; m<gt1; i++,m++) indices[i]=m;
                    for (m=eq2; m<gt2; i++,m++) indices[i]=m;
                    for (m=gt1; m<mid; i++,m++) indices[i]=m;
                    m=rearrange_array(base,gt2-eq1,size,indices,gt2-eq1,eq1,gt2,
                        alignsize);
                    /* Update count of moves: for direct data sort/select,
                       size_ratio reflects data size compared to alignsize (which
                       is assumed to be the basic move size used by movement); for
                       indirect sort/select, size_ratio==1 because only pointers
                       are moved here.
                    */
# if LIBMEDIAN_TEST_CODE
                    if ((0UL!=m)&&(SIZE_MAX>m))
                        nmoves+=m*size_ratio;
# endif
                    /* +-----------------------------+ */
                    /* | L< | R< | L= | R= | L> | R> | */
                    /* +-----------------------------+ */
                    /* (l)  eq1  gt1  mid  eq2  gt2  (u) */
                    *peq=gt1=eq1+rlt, mid=gt1+leq, *pgt=eq2=mid+req;
                } else {
                    /* +-----------------------------+
                       | L< | L= | L> | R< | R= | R> |
                       +-----------------------------+
                      Preservation of ordering within blocks and between blocks of like
                      types results in stable partitoning, stable sort or selection.
                      3 methods each consisting of 2 rotations may be used:
                      1a. rotate L= through R< by 1 block
                       +-----------------------------+
                       | L< | R< | L= | L> | R= | R> |
                       +-----------------------------+
                      1b. exchange L> and R=
                       +-----------------------------+
                       | L< | R< | L= | R= | L> | R> |
                       +-----------------------------+
                      2a. rotate L> through R= by 1 block
                       +-----------------------------+
                       | L< | L= | R< | R= | L> | R> |
                       +-----------------------------+
                      2b. exchange L= and R<
                       +-----------------------------+
                       | L< | R< | L= | R= | L> | R> |
                       +-----------------------------+
                      3a. rotated L= through R= by 2 blocks
                       +-----------------------------+
                       | L< | R< | R= | L= | R> | R> |
                       +-----------------------------+
                      3b. exchange R= and L=
                       +-----------------------------+
                       | L< | R< | L= | R= | L> | R> |
                       +-----------------------------+
                      One method is chosen depending on the region sizes so as to
                      minimize the total number of swaps.
                    */
                    if ((0UL==leq)||(0UL==req)||(leq+req<m)) { /* method 3 */
# if LIBMEDIAN_TEST_CODE
                        if (DEBUGGING(PARTITION_DEBUG)) {
                            (V)fprintf(stderr,
                                "/* %s: %s line %d: first=%lu, beyond=%lu, "
                                "eq1=%lu, gt1=%lu, mid=%lu, eq2=%lu, gt2=%lu "
                                "*/\n",__func__,source_file,__LINE__,first,
                                beyond,eq1,gt1,mid,eq2,gt2);
                            if (MAX_ARRAY_PRINT>beyond-first)
                                print_some_array(base,first,beyond-1UL,
                                    "/* "," */",options);
                            (V)fprintf(stderr,
                                "/* %s: %s line %d: method 3a: rotate eq1|mid|g"
                                "t2: first=%lu, beyond=%lu, eq1=%lu, gt1=%lu, "
                                "mid=%lu, eq2=%lu, gt2=%lu */\n",__func__,
                                source_file,__LINE__,first,beyond,eq1,gt1,mid,
                                eq2,gt2);
                        }
# endif
                        irotate(base,eq1,mid,gt2,size,swapf,alignsize,size_ratio);
                        /* +-----------------------------+ */
                        /* | L< | R< | R= | L= | R> | R> | */
                        /* +-----------------------------+ */
                        /* (l)  eq1  gt1  mid  eq2  gt2  (u) */
                        if (0UL<leq+req) {
                            gt1=eq1+rlt, mid=gt1+req, eq2=mid+leq;
# if LIBMEDIAN_TEST_CODE
                            if (DEBUGGING(PARTITION_DEBUG)) {
                                (V)fprintf(stderr,
                                    "/* %s: %s line %d: method 3b: exchange = "
                                    "blocks by rotation gt1|mid|eq2: first=%lu,"
                                    " beyond=%lu, eq1=%lu, gt1=%lu, mid=%lu, "
                                    "eq2=%lu, gt2=%lu */\n",__func__,
                                    source_file,__LINE__,first,beyond,eq1,gt1,
                                    mid,eq2,gt2);
                                if (MAX_ARRAY_PRINT>beyond-first)
                                    print_some_array(base,first,beyond-1UL,
                                        "/* "," */",options);
                            }
# endif
                            irotate(base,gt1,mid,eq2,size,swapf,alignsize,
                                size_ratio);
                        }
                    } else if (lgt<rlt) { /* method 2 */
# if LIBMEDIAN_TEST_CODE
                        if (DEBUGGING(PARTITION_DEBUG)) {
                            (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, "
                                "beyond=%lu, eq1=%lu, gt1=%lu, mid=%lu, eq2=%lu"
                                ", gt2=%lu */\n",__func__,source_file,__LINE__,
                                first,beyond,eq1,gt1,mid,eq2,gt2);
                            if (MAX_ARRAY_PRINT>beyond-first)
                                print_some_array(base,first,beyond-1UL,
                                    "/* "," */",options);
                            (V)fprintf(stderr,"/* %s: %s line %d: method 2a: "
                                "rotate gt1|mid|gt2: first=%lu, beyond=%lu, eq1"
                                "=%lu, gt1=%lu, mid=%lu, eq2=%lu, gt2=%lu */\n",
                                __func__,source_file,__LINE__,first,beyond,eq1,
                                gt1,mid,eq2,gt2);
                        }
# endif
                        irotate(base,gt1,mid,gt2,size,swapf,alignsize,
                            size_ratio);
                        /* +-----------------------------+ */
                        /* | L< | L= | R< | R= | L> | R> | */
                        /* +-----------------------------+ */
                        /* (l)  eq1  gt1  mid  eq2  gt2  (u) */
                        mid=gt1+rlt, eq2=mid+req;
# if LIBMEDIAN_TEST_CODE
                        if (DEBUGGING(PARTITION_DEBUG)) {
                            (V)fprintf(stderr,"/* %s: %s line %d: method 2b: "
                                "exchange L=,R< by rotating eq1|gt1|mid first="
                                "%lu, beyond=%lu, eq1=%lu, gt1=%lu, mid=%lu, "
                                "eq2=%lu, gt2=%lu */\n",__func__,source_file,
                                __LINE__,first,beyond,eq1,gt1,mid,eq2,gt2);
                            if (MAX_ARRAY_PRINT>beyond-first)
                                print_some_array(base,first,beyond-1UL,
                                    "/* "," */",options);
                        }
# endif
                        irotate(base,eq1,gt1,mid,size,swapf,alignsize,size_ratio);
                    } else { /* method 1 */
                        /* +-----------------------------+ */
                        /* | L< | L= | L> | R< | R= | R> | */
                        /* +-----------------------------+ */
                        /* (l)  eq1  gt1  mid  eq2  gt2  (u) */
# if LIBMEDIAN_TEST_CODE
                        if (DEBUGGING(PARTITION_DEBUG)) {
                            (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, "
                                "beyond=%lu, eq1=%lu, gt1=%lu, mid=%lu, eq2=%lu"
                                ", gt2=%lu */\n",__func__,source_file,__LINE__,
                                first,beyond,eq1,gt1,mid,eq2,gt2);
                            if (MAX_ARRAY_PRINT>beyond-first)
                                print_some_array(base,first,beyond-1UL,
                                    "/* "," */",options);
                            (V)fprintf(stderr,"/* %s: %s line %d: method 1a: "
                                "rotate eq1|mid|eq2: first=%lu, beyond=%lu, eq1"
                                "=%lu, gt1=%lu, mid=%lu, eq2=%lu, gt2=%lu */\n",
                                __func__,source_file,__LINE__,first,beyond,eq1,
                                gt1,mid,eq2,gt2);
                        }
# endif
                        irotate(base,eq1,mid,eq2,size,swapf,alignsize,size_ratio);
                        /* +-----------------------------+ */
                        /* | L< | R< | L= | L> | R= | R> | */
                        /* +-----------------------------+ */
                        /* (l)  eq1  gt1  mid  eq2  gt2  (u) */
                        gt1=eq1+rlt, mid=gt1+leq;
# if LIBMEDIAN_TEST_CODE
                        if (DEBUGGING(PARTITION_DEBUG)) {
                            (V)fprintf(stderr,"/* %s: %s line %d: method 1b: "
                                "exchange L>,R= by rotating mid|eq2|gt2: first="
                                "%lu, beyond=%lu, eq1=%lu, gt1=%lu, mid=%lu, "
                                "eq2=%lu, gt2=%lu */\n",__func__,source_file,
                                __LINE__,first,beyond,eq1,gt1,mid,eq2,gt2);
                            if (MAX_ARRAY_PRINT>beyond-first)
                                print_some_array(base,first,beyond-1UL,
                                    "/* "," */",options);
                        }
# endif
                        irotate(base,mid,eq2,gt2,size,swapf,alignsize,size_ratio);
                    }
                    /* +-----------------------------+ */
                    /* | L< | R< | L= | R= | L> | R> | */
                    /* +-----------------------------+ */
                    /* (l)  eq1  gt1  mid  eq2  gt2  (u) */
                    *peq=gt1=eq1+rlt, mid=gt1+leq, *pgt=eq2=mid+req;
                }
            break;
        }
# if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(PARTITION_DEBUG)) {
            (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, beyond=%lu, *peq="
                "%lu, *pgt=%lu: merged partition, nsw=%lu */\n",__func__,
                source_file,__LINE__,first,beyond,*peq,*pgt,nsw);
            if (MAX_ARRAY_PRINT>beyond-first)
                print_some_array(base,first,beyond-1UL, "/* "," */",
                    options);
        }
# endif
    } else { /* nothing to do but set *peq and *pgt */
        /* +-----------------------+
           | < | = | > | < | = | > |
           +-----------------------+
            |   |   |   |   |   |   |
            (l) eq1 gt1 mid eq2 gt2  (u)
        */
        if (gt1>eq1) {
            *peq=eq1;
            if (mid>gt1) *pgt=gt1;
            else *pgt=gt2;
        } else if (gt2>eq2) *peq=eq2, *pgt=gt2;
        else if (mid>gt1) *peq=*pgt=gt1;
        else *peq=*pgt=gt2;
    }
}

/* partition by rearranging (permuting) elements */
/* return value is the number of == comparisons (not including already-partitioned) */
static QUICKSELECT_INLINE
void linear_partition(char *base, size_t first, size_t beyond,
    char *pc, char *pd, register char *pivot, char *pe, char *pf,
    register size_t size,
    COMPAR_DECL,
    void (*swapf)(char*, char*, size_t), size_t alignsize, size_t size_ratio,
    unsigned int options, size_t *peq, size_t *pgt)
{
    /* linear-time partition using O(N) extra space */
    size_t nmemb=beyond-first;
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201101L) /* C11 */
    _Alignas((QUICKSELECT_DEFAULT_ALIGNMENT)) /* probably most restrictive cache line size (bytes) */
#endif /* C11 */
    size_t indices[nmemb];
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201101L) /* C11 */
    _Alignas((QUICKSELECT_DEFAULT_ALIGNMENT)) /* probably most restrictive cache line size (bytes) */
#endif /* C11 */
    char conditions[nmemb];
    char *pl, *pu;
    register char *pb, *pg;
    register int c=0;
    register size_t i, ieq, igt;

    pl=base+size*first, pu=base+size*beyond;
# if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
        (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, pc@%lu, pd@%lu, pivot@"
            "%lu, pe@%lu, pf@%lu, beyond=%lu, options=0x%x */\n",__func__,
            source_file,__LINE__,first,(pc-base)/size,(pd-base)/size,
            (pivot-base)/size,(pe-base)/size,(pf-base)/size,beyond,options);
        print_some_array(base,first,beyond-1UL, "/* "," */",options);
    }
# endif
    A(first<beyond);A(pc<=pd);A(pd<=pivot);A(pivot<=pe);A(pe<=pf);
    switch (options&(QUICKSELECT_STABLE)) {
# if 0
        /* linear_partition is used only for stable partitioning.  */
        default : /* non-stable */
            /* Non-stable version is correct, but slower than Kiwiel Alg. L.
               It uses about the same number of comparisons, but about 40% more
               data movement, and takes about 50% more time than sorting using
               Kiwiel Algorithm L for non-stable partitioning.  The additional
               data movement is for merging partial partitions (partitioning
               the entire sub-array (even if it doesn't fit in cache) does not
               require any operations to complete partitioning, whereas partial
               partitions do need to be merged into a canonical partition.
               For infinite cache, indirect mergesort would be used, obviating
               partitioning (and providing stable sorting with about the same
               run time as non-stable sorting using Kiwiel's Algorithm L).
            */
            /* 1st scan: left-to-right to get element partial order */
            /* split into pre-pivot, pivot, post-pivot (if pivot in region) */
            /* further split into direct, indirect for pivot cache */
            if (0U==(options&(QUICKSELECT_INDIRECT))) { /* direct */
                /* Array index for conditions, indices is 0 for "first"
                   base array element.  Value in indices array is overall
                   current index, which will be in [first,beyond).
                */
                if ((pl<=pivot)&&(pivot<pu)) { /* pivot in sub-array */
                    pg=pivot;
                } else pg=pu;
                for (i=ieq=0UL,igt=beyond,pb=pl; pb<pg; pb+=size,i++) {
                    c=COMPAR(pb,pivot);
                    if (0<c) {
                        conditions[i]=(char)1;
                        A(0UL!=igt);
                        igt--; /* track > elements */
                    } else if (0==c) conditions[i]=(char)0;
                    else {
                        conditions[i]=(char)(-1);
                        ieq++; /* count < elements */
                    }
                }
                if (pg!=pu) {
                    A(pb==pg);A(pg==pivot);
                    conditions[i]=(char)0;
                    for (++i,pb+=size; pb<pu; pb+=size,i++) {
                        c=COMPAR(pb,pivot);
                        if (0<c) {
                            conditions[i]=(char)1;
                            A(0UL!=igt);
                            igt--; /* track > elements */
                        } else if (0==c) conditions[i]=(char)0;
                        else {
                            conditions[i]=(char)(-1);
                            ieq++; /* count < elements */
                        }
                    }
                }
            } else { /* indirect; pivot data pointer cached */
                register char *pp=*((char **)pivot);
                if ((pl<=pivot)&&(pivot<pu)) { /* pivot in sub-array */
                    pg=pivot;
                } else pg=pu;
                for (i=ieq=0UL,igt=beyond,pb=pl; pb<pg; pb+=size,i++) {
                    c=COMPAR(*((char **)pb),pp);
                    if (0<c) {
                        conditions[i]=(char)1;
                        A(0UL!=igt);
                        igt--; /* track > elements */
                    } else if (0==c) conditions[i]=(char)0;
                    else {
                        conditions[i]=(char)(-1);
                        ieq++; /* count < elements */
                    }
                }
                if (pg!=pu) {
                    A(pb==pivot);A(pg==pivot);
                    conditions[i]=(char)0;
                    for (++i,pb+=size; pb<pu; pb+=size,i++) {
                        c=COMPAR(*((char **)pb),pp);
                        if (0<c) {
                            conditions[i]=(char)1;
                            A(0UL!=igt);
                            igt--; /* track > elements */
                        } else if (0==c) conditions[i]=(char)0;
                        else {
                            conditions[i]=(char)(-1);
                            ieq++; /* count < elements */
                        }
                    }
                }
            }
#  if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr, "/* %s: %s line %d: conditions:",
                   __func__,source_file,__LINE__);
                for (i=0UL; i<nmemb; i++)
                    (V)fprintf(stderr, " %lu:%d", first+i, conditions[i]);
                (V)fprintf(stderr, " */\n");
            }
#  endif
            *peq=first+ieq;
            *pgt=igt;
#  if ASSERT_CODE + DEBUG_CODE
            if ((*peq>*pgt)||(*peq<first)||(*pgt>beyond))
                (V)fprintf(stderr,"%s: %s line %d: first=%lu, beyond=%lu, *peq="
                    "%lu, *pgt=%lu\n",__func__,source_file,__LINE__,first,
                    beyond,*peq,*pgt);
#  endif
            A(*peq<=*pgt);A(first<=*peq);A(*pgt<=beyond);
#  if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr,"/* ieq=%lu, *peq=%lu, igt=%lu, *pgt=%lu */\n",
                    ieq,*peq,igt,*pgt);
            }
#  endif
            /* scan from ends to middle: elements on correct side of partition
               don't move; out-of-place elements have indices adjusted.
            */
            for (i=0UL,j=nmemb-1UL,k=ieq; ; ) {
                while ((i<ieq)&&(0>conditions[i])) indices[i]=first+i, i++;
                while ((first+j>=igt)&&(0<conditions[j])) indices[j]=first+j, j--;
                while ((first+k<igt)&&(0==conditions[k])) indices[k]=first+k, k++;
#  if LIBMEDIAN_TEST_CODE
                if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                    (V)fprintf(stderr,"/* %s: %s line %d: i=%lu(%d), j=%lu(%d),"
                        " k=%lu(%d) */\n",__func__,source_file,__LINE__,i,
                        conditions[i],j,conditions[j],k,conditions[k]);
                }
#  endif
                if ((i>=ieq)&&(first+j<igt)&&(first+k>=igt)) { break;
                } else if ((i<ieq)&&(first+j>=igt)&&(0<conditions[i])
                          &&(0>conditions[j])
                ) {
                    /* simple case: swap */
                    indices[i]=first+j, indices[j]=first+i, i++,j--;
                } else if ((i<ieq)&&(0==conditions[i])&&(first+k<igt)
                          &&(0>conditions[k])
                ) {
                    indices[i]=first+k, indices[k]=first+i, i++,k++;
                } else if ((first+j>=igt)&&(0==conditions[j])&&(first+k<igt)
                          &&(0<conditions[k])
                ) {
                    indices[j]=first+k, indices[k]=first+j, j--,k++;
                } else if ((i<ieq)&&(0==conditions[i])&&(first+j>=igt)
                          &&(0>conditions[j])&&(first+k<igt)&&(0<conditions[k])
                ) {
                    indices[i]=first+j, indices[j]=first+k, indices[k]=first+i,
                        i++,j--,k++;
                } else if ((i<ieq)&&(0<conditions[i])&&(first+j>=igt)
                          &&(0==conditions[j])&&(first+k<igt)&&(0>conditions[k])
                ) {
                    indices[i]=first+k, indices[j]=first+i, indices[k]=first+j,
                        i++,j--,k++;
                } else { /* case not handled */
                    A(0==1);
                }
            }
#  if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr, "/* *peq=%lu, *pgt= %lu, indices:",*peq,*pgt);
                for (i=0UL; i<nmemb; i++)
                    (V)fprintf(stderr, " %lu:%lu", first+i, indices[i]);
                (V)fprintf(stderr, " */\n");
            }
#  endif
        break;
# endif /* non-stable linear partition */
# if QUICKSELECT_STABLE
        case QUICKSELECT_STABLE :
            /* 1st scan: left-to-right to get element partial order and set
               indices for < elements.
            */
            /* split into pre-pivot, pivot, post-pivot (if pivot in region) */
            /* further split into direct, indirect for pivot cache */
            if (0U==(options&(QUICKSELECT_INDIRECT))) { /* direct */
                /* Array index for conditions, indices is 0 for "first"
                   base array element.  Value in indices array is overall
                   current index, which will be in [first,beyond).
                */
                if ((pl<=pivot)&&(pivot<pu)) { /* pivot in sub-array */
                    pg=pivot;
                } else pg=pu;
                for (i=ieq=0UL,pb=pl; pb<pg; pb+=size,i++) {
                    c=COMPAR(pb,pivot);
                    if (0<c) conditions[i]=(char)1;
                    else if (0==c) conditions[i]=(char)0;
                    else {
                        conditions[i]=(char)(-1);
                        indices[ieq++]=first+i; /* < elements */
                    }
                }
                if (pg!=pu) {
                    A(pb==pg);A(pg==pivot);
                    conditions[i]=(char)0;
                    for (++i,pb+=size; pb<pu; pb+=size,i++) {
                        c=COMPAR(pb,pivot);
                        if (0<c) conditions[i]=(char)1;
                        else if (0==c) conditions[i]=(char)0;
                        else {
                            conditions[i]=(char)(-1);
                            indices[ieq++]=first+i; /* < elements */
                        }
                    }
                }
            } else { /* indirect; pivot data pointer cached */
                register char *pp=*((char **)pivot);
                if ((pl<=pivot)&&(pivot<pu)) { /* pivot in sub-array */
                    pg=pivot;
                } else pg=pu;
                for (i=ieq=0UL,pb=pl; pb<pg; pb+=size,i++) {
                    c=COMPAR(*((char **)pb),pp);
                    if (0<c) conditions[i]=(char)1;
                    else if (0==c) conditions[i]=(char)0;
                    else {
                        conditions[i]=(char)(-1);
                        indices[ieq++]=first+i; /* < elements */
                    }
                }
                if (pg!=pu) {
                    A(pb==pivot);A(pg==pivot);
                    conditions[i]=(char)0;
                    for (++i,pb+=size; pb<pu; pb+=size,i++) {
                        c=COMPAR(*((char **)pb),pp);
                        if (0<c) conditions[i]=(char)1;
                        else if (0==c) conditions[i]=(char)0;
                        else {
                            conditions[i]=(char)(-1);
                            indices[ieq++]=first+i; /* < elements */
                        }
                    }
                }
            }
#  if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr, "/* %s: %s line %d: ieq=%lu, conditions:",
                   __func__,source_file,__LINE__,ieq);
                for (i=0UL; i<nmemb; i++)
                    (V)fprintf(stderr, " %lu:%d", first+i, conditions[i]);
                (V)fprintf(stderr, " */\n");
            }
#  endif
            *peq=first+ieq;
            /* 2nd scan: right-to-left to set indices for > elements. */
            for (i=igt=nmemb-1UL,pb=pu; pb>pl; pb-=size,i--)
                if (0<conditions[i]) {
                    indices[igt]=first+i;
                    if (0UL<igt) igt--; /* avoid decrementing zero */
                }
            /* 3rd scan: left to right to set indices for == elements. */
            for (i=0UL; (i<nmemb)&&(ieq<=igt); i++) {
                if (0==conditions[i]) {
                    indices[ieq++]=first+i;
                }
                A(i<beyond);
            }
            *pgt=first+ieq;
#  if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr,
                    "/* %s: %s line %d: *peq=%lu, *pgt= %lu, indices:",
                   __func__,source_file,__LINE__,*peq,*pgt);
                for (i=0UL; i<nmemb; i++)
                    (V)fprintf(stderr, " %lu:%lu", first+i, indices[i]);
                (V)fprintf(stderr, " */\n");
            }
#  endif
        break;
# endif /* QUICKSELECT_STABLE */
    }
    i=rearrange_array(base,nmemb,size,indices,nmemb,first,beyond,alignsize);
    A(nmemb>(i>>1));
# if LIBMEDIAN_TEST_CODE
    /* Update count of moves: for direct data sort/select,
       size_ratio reflects data size compared to alignsize (which
       is assumed to be the basic move size used by movement); for
       indirect sort/select, size_ratio==1 because only pointers
       are moved here.
    */
    if (0UL!=i)
        nmoves+=(i+nmemb)*size_ratio;
    if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
        (V)fprintf(stderr,
            "/* %s: %s line %d: partitioned: "
            "(first)%lu-(pc)%lu-(pd)%lu-(pivot)%lu-(pe)%lu-(pf)%lu-(beyond)%lu "
            "options 0x%x*/\n",
            __func__,source_file,__LINE__,first,(pc-base)/size,(pd-base)/size,
            (pivot-base)/size,(pe-base)/size,(pf-base)/size,beyond,options);
        print_some_array(base,first,beyond-1UL, "/* "," */",options);
    }
# endif
}

/* return value is the number of == comparisons (not including the pivot itself) */
static QUICKSELECT_INLINE
void divide_and_conquer_partition(char *base, size_t first, size_t beyond,
    char *pc, char *pd, register char *pivot, char *pe, char *pf,
    register size_t size, COMPAR_DECL, void (*swapf)(char*, char*, size_t),
    size_t alignsize, size_t size_ratio, size_t pcachesz, unsigned int options,
    size_t *peq, size_t *pgt)
{
    char *pl, *pu;
    register int c=0;

    A(256UL<=pcachesz); A(beyond>first);
    /* divide-and-conquer partition */
    pl=base+size*first, pu=base+size*beyond;

# if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
        (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, pc@%lu, pd@%lu, pivot@"
            "%lu, pe@%lu, pf@%lu, beyond=%lu, options=0x%x */\n",__func__,
            source_file,__LINE__,first,(pc-base)/size,(pd-base)/size,
            (pivot-base)/size,(pe-base)/size,(pf-base)/size,beyond,options);
        print_some_array(base,first,beyond-1UL, "/* "," */",options);
    }
# endif
    A(first<beyond);A(pc<=pd);A(pd<=pivot);A(pivot<=pe);A(pe<=pf);
    /* Recursively partitions unpartitioned regions potentially down to a
       partition containing a single element, then merges partitions to fully
       partition the array.
    */
    if (pl+size==pu) { /* 1 element */
        if (pivot!=pl) { /* external pivot */
            c=OPT_COMPAR(pl,pivot,options);
            if (0>c) *peq=*pgt=beyond;
            else if (0<c) *peq=*pgt=first;
            else *peq=first, *pgt=beyond;
        } else *peq=first, *pgt=beyond; /* pivot */
    } else if ((pl==pc)&&(pf==pu)) { /* already fully partitioned */
        *peq=(pd-base)/size;
        *pgt=(pe-base)/size;
    } else if ((beyond-first)*(size+1UL+pointer_and_char)<pcachesz) {
        /* fits in cache */
# if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(PARTITION_DEBUG)) {
            (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, beyond=%lu, size="
                "%lu, pcachesz=%lu */\n",__func__,source_file,__LINE__,first,
                beyond,size,pcachesz);
        }
# endif
        linear_partition(base,first,beyond,pc,pd,pivot,pe,pf,size,
            COMPAR_ARGS,swapf,alignsize,size_ratio,options,peq,pgt);
        A(*peq<=*pgt);A(first<=*peq);A(*pgt<=beyond);
    } else { /* more than 1 element, not fully partitioned */
        /* already-partitioned region is 1 partition; 1 or 2 others */
        if ((pl<=pc)&&(pf<=pu)) { /* pivot is in region */
            size_t ipc, ipd, ipe, ipf;
            /* +-----------------------+
               |  ?  | < | = | > |  ?  |
               +-----------------------+
                first c   d   e   f     beyond
            */
            ipc=(pc-base)/size, ipd=(pd-base)/size, ipe=(pe-base)/size,
                ipf=(pf-base)/size;
# if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, ipc=%lu, ipd="
                    "%lu, ipe=%lu, ipf=%lu, beyond=%lu */\n",__func__,
                    source_file,__LINE__,first,ipc,ipd,ipe,ipf,beyond);
            }
# endif
            if (pl==pc) { /* already-partitioned at left end */
                A(pf<pu);
                /* partition the right unpartitioned region and merge */
                A(ipf<beyond);
                divide_and_conquer_partition(base,ipf,beyond,pc,pd,pivot,
                    pe,pf,size,COMPAR_ARGS,swapf,alignsize,size_ratio,pcachesz,
                    options,peq,pgt);
                A(*peq<=*pgt);A(ipf<=*peq);A(*pgt<=beyond);
                merge_partitions(base,first,ipd,ipe,ipf,*peq,*pgt,beyond,size,
                    swapf,alignsize,size_ratio,pcachesz,options,peq,pgt);
            } else if (pu==pf) { /* already-partitioned at right end */
                /* partition unpartitioned left region and merge */
                A(pl<pc);A(first<ipc);
                divide_and_conquer_partition(base,first,ipc,pc,pd,pivot,
                    pe,pf,size,COMPAR_ARGS,swapf,alignsize,size_ratio,pcachesz,
                    options,peq,pgt);
                A(*peq<=*pgt);A(first<=*peq);A(*pgt<=ipc);
                merge_partitions(base,first,*peq,*pgt,ipc,ipd,ipe,beyond,size,
                    swapf,alignsize,size_ratio,pcachesz,options,peq,pgt);
            } else { /* already-partitioned in middle */
                /* partition two unpartitioned regions and merge */
                size_t eq2, gt2;
                A(pl<pc);A(first<ipc);
                divide_and_conquer_partition(base,first,ipc,pc,pd,pivot,
                    pe,pf,size,COMPAR_ARGS,swapf,alignsize,size_ratio,pcachesz,
                    options,peq,pgt);
                A(*peq<=*pgt);A(first<=*peq);A(*pgt<=ipc);
                merge_partitions(base,first,*peq,*pgt,ipc,ipd,ipe,ipf,size,
                    swapf,alignsize,size_ratio,pcachesz,options,peq,pgt);
                A(*peq<=*pgt);A(first<=*peq);A(*pgt<=ipf);
                A(pf<pu);A(ipf<beyond);
                divide_and_conquer_partition(base,ipf,beyond,pl,
                    base+*peq*size,base+*peq*size,base+*pgt*size,pf,size,
                    COMPAR_ARGS,swapf,alignsize,size_ratio,pcachesz,options,
                    &eq2,&gt2);
                A(eq2<=gt2);A(ipf<=eq2);A(gt2<=beyond);
                merge_partitions(base,first,*peq,*pgt,ipf,eq2,gt2,beyond,size,
                    swapf,alignsize,size_ratio,pcachesz,options,peq,pgt);
            }
        } else { /* external pivot; split, partition, & merge */
            /* External pivot arises when partitioning a part of an
               unpartitioned sub-array.
            */
            size_t mid=first+((beyond-first)>>1), eq2, gt2;
# if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, mid=%lu, eq2="
                    "%lu, gt2=%lu, beyond=%lu */\n",__func__,source_file,
                    __LINE__,first,mid,eq2,gt2,beyond);
            }
# endif
            A(first<mid);A(mid<beyond);
            divide_and_conquer_partition(base,first,mid,pc,pd,pivot,pe,pf,
                size,COMPAR_ARGS,swapf,alignsize,size_ratio,pcachesz,options,
                peq,pgt);
            divide_and_conquer_partition(base,mid,beyond,pc,pd,pivot,pe,
                pf,size,COMPAR_ARGS,swapf,alignsize,size_ratio,pcachesz,options,
                &eq2,&gt2);
            merge_partitions(base,first,*peq,*pgt,mid,eq2,gt2,beyond,size,swapf,
                alignsize,size_ratio,pcachesz,options,peq,pgt);
        }
    }
}
#endif /* (QUICKSELECT_STABLE != 0) */

#if __STDC_WANT_LIB_EXT1__
QUICKSELECT_PARTITION_S
#else
QUICKSELECT_PARTITION
#endif
{
    char *pa, *ph, *pl, *pu;
    register char *pb, *pg;
    register int c=0, d=0;

#if LIBMEDIAN_TEST_CODE && ! QUICKSELECT_BUILD_FOR_SPEED
    if ((char)0==file_initialized) initialize_file(__FILE__);
    if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
        (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, pc@%lu, pd@%lu, pivot@"
            "%lu, pe@%lu, pf@%lu, beyond=%lu, options=0x%x */\n",__func__,
            source_file,__LINE__,first,(pc-base)/size,(pd-base)/size,
            (pivot-base)/size,(pe-base)/size,(pf-base)/size,beyond,options);
        print_some_array(base,first,beyond-1UL, "/* "," */",options);
    }
    if (DEBUGGING(CORRECTNESS_DEBUG)) { /* test partition pc-pd-pe-pf */
        size_t x;
        x=test_array_partition(base,(pc-base)/size,(pd-base)/size,
            (pe-base)/size-1UL,(pf-base)/size-1UL,size,compar,options,NULL,NULL);
        if (x!=(pd-base)/size) {
            (void)fprintf(stderr,"/* %s: line %d: bad partition at %lu, "
                "pivot at %lu */\n",__func__,__LINE__,
                x,(pd-base)/size);
            print_some_array(base,(pc-base)/size,(pf-base)/size-1UL,"/* ",
                " */",options);
            abort();
        }
    }
    npartitions++;
    /* antiqsort handshake; allow further freezes during partitioning */
    if (aqcmp==compar) pivot_minrank=beyond-first;
#endif /* LIBMEDIAN_TEST_CODE */
    /* Stable sorting methods (insertion sort, in-place mergesort, indirect
       mergesort) are all faster than sorting using stable divide-and-conquer
       quicksort, provided sufficient memory is available for the extra space
       required for indirect mergesort at large nmemb.  Stable partitioning
       may be useful when such space is unavailable.  Also, stable partitioning
       for stable divide-and-conquer might be useful for stable multiple
       selection where the number of desired order statistics is too small to
       warrant a full sort.
    */
    switch (options&(QUICKSELECT_STABLE)) {
        default:
            pl=base+first*size, pu=base+beyond*size;
            /* The already-partitioned regions are at one end of the array,
               except in the case of remedian, which produces only a pivot
               element that can be any element.
            */
            /* McGeoch & Tygar suggest that partial partition information
               from median-of-medians or median-of-samples might be used to
               avoid recomparisons during partitioning.
            */
            A((pc==pl)||(pf==pu)||(pc+size==pf));
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr,"/* %s: %s line %d: (on entry) first=%lu, pl@%lu, pc@"
                    "%lu, pd@%lu, pe@%lu, pf@%lu, pu@beyond=%lu, pivot@%lu, options=0x"
                    "%x */\n",__func__,source_file,__LINE__,first,(pl-base)/size,
                    (pc-base)/size,(pd-base)/size,(pe-base)/size,(pf-base)/size,
                    beyond,(pivot-base)/size,options);
                print_some_array(base,first,beyond-1UL, "/* "," */",options);
            }
# endif
            /* Move the pivot and the small part of the already-partitioned regions to
               the opposite end of the array
            */
            if (pc==pl) { /* move = region to right, > region below that */
                pa=pl,pb=pd;
                pe=blockmove(pd,pe,pf,swapf);
                pivot=ph=blockmove(pe,pf,pu,swapf);
                pg=blockmove(pd,pe,ph,swapf)-size;
            } else if (pf==pu) { /* move = region to left, < region above that */
                ph=pu,pg=pe-size,pivot=pl;
                pd=blockmove(pc,pd,pe,swapf);
                pa=blockmove(pl,pc,pd,swapf);
                pb=blockmove(pa,pd,pe,swapf);
            } else { /* somewhere... */
                /* This is general; it can handle elements in addition to the pivot. */
                ph=pu,pivot=pl;
                pd=blockmove(pc,pd,pe,swapf);
                pg=blockmove(pe,pf,pu,swapf)-size;
                pa=blockmove(pl,pc,pd,swapf);
                pb=blockmove(pa,pd,pe,swapf);
            }
            /* Already-partitioned elements have been moved.  Unpartitioned region is
               now [pb,pg)
            */
            /* +-----------------------------------------------------+ */
            /* |   =   |   <   |  ?  : < :=: > :  ?  |   >   |   =   | */
            /* +-----------------------------------------------------+ */
            /*  l       a       b    [c   d e   f]  G g       h       u*/
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr,"/* %s: %s line %d: (ready) first=%lu, pl@%lu, pa@%lu"
                    ", pb@%lu, pg@%lu, ph@%lu, beyond=%lu, pivot@%lu, options=0x%x */\n",
                    __func__,source_file,__LINE__,first,(pl-base)/size,
                    (pa-base)/size,(pb-base)/size,(pg-base)/size,(ph-base)/size,
                    beyond,(pivot-base)/size,options);
                print_some_array(base,first,beyond-1UL, "/* "," */",options);
            }
# endif
            if (0U==(options&(QUICKSELECT_INDIRECT))) {
                /* Initial partitoning (until a pair of out-of-place elements is
                   found) skips over in-place elements and moves elements
                   comparing equal to the pivot to the array ends.  Those
                   elements (equal to pivot) are swapped into position at the
                   end if there are intervening in-place elements (i.e. if
                   pa!=pb or pg!=ph); otherwise the equal-elements region is
                   simply extended.  This optimization is similar to Kiwiel's
                   Algorithm L.
                */
                for (; (pb<=pg)&&(0<=(c=COMPAR(pivot,pb))); pb+=size) {
                    if (0==c) {
                        if (pa!=pb) {
                            EXCHANGE_SWAP(swapf,pa,pb,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                        }
                        pa+=size;
                    }
                }
                for (; (pb<pg)&&(0>=(d=COMPAR(pivot,pg))); pg-=size) {
                    if (0==d) {
                        ph-=size;
                        if (pg!=ph) {
                            EXCHANGE_SWAP(swapf,pg,ph,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                        }
                    }
                }
                for (;pb<pg;) {
                    /* After the first pair of out-of-place elements (found
                       above and swapped below, further exchanges can avoid the
                       pa!=pb and pg!=ph tests as there will be at least one <
                       and at least one > element.
                    */
                    EXCHANGE_SWAP(swapf,pb,pg,size,alignsize,size_ratio,
                        SWAP_COUNT_STATEMENT);
                    for (pb+=size; (pb<=pg)&&(0<=(c=COMPAR(pivot,pb)));
                    pb+=size
                    ) {
                        if (0==c) {
                            EXCHANGE_SWAP(swapf,pa,pb,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                            pa+=size;
                        }
                    }
                    for (pg-=size; (pb<pg)&&(0>=(d=COMPAR(pivot,pg)));
                    pg-=size
                    ) {
                        if (0==d) {
                            ph-=size;
                            EXCHANGE_SWAP(swapf,pg,ph,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                        }
                    }
                }
            } else { /* indirect; cache pointer to pivot element */
                pivot=*((char **)pivot);
                for (; (pb<=pg)&&(0<=(c=COMPAR(pivot,*((char **)pb))));
                pb+=size
                ) {
                    if (0==c) {
                        if (pa!=pb) {
                            EXCHANGE_SWAP(swapf,pa,pb,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                        }
                        pa+=size;
                    }
                }
                for (; (pb<pg)&&(0>=(d=COMPAR(pivot,*((char **)pg))));
                pg-=size
                ) {
                    if (0==d) {
                        ph-=size;
                        if (pg!=ph) {
                            EXCHANGE_SWAP(swapf,pg,ph,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                        }
                    }
                }
                for (;pb<pg;) {
                    EXCHANGE_SWAP(swapf,pb,pg,size,alignsize,size_ratio,
                        SWAP_COUNT_STATEMENT);
                    for (pb+=size;
                    (pb<=pg)&&(0<=(c=COMPAR(pivot,*((char **)pb))));
                    pb+=size
                    ) {
                        if (0==c) {
                            EXCHANGE_SWAP(swapf,pa,pb,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                            pa+=size;
                        }
                    }
                    for (pg-=size;
                    (pb<pg)&&(0>=(d=COMPAR(pivot,*((char **)pg))));
                    pg-=size
                    ) {
                        if (0==d) {
                            ph-=size;
                            EXCHANGE_SWAP(swapf,pg,ph,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                        }
                    }
                }
            }
            /* Canonicalize */
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr,"/* %s: %s line %d: (before canonicalization)"
                    " first=%lu, pa@%lu, pb@%lu, pg@%lu, ph@%lu, beyond=%lu, "
                    "options=0x%x */\n",__func__,source_file,__LINE__,first,
                    (pa-base)/size,(pb-base)/size,(pg-base)/size,(ph-base)/size,
                    beyond,options);
                print_some_array(base,first,beyond-1UL, "/* "," */",options);
            }
# endif
            /* +-----------------------------------------------------+ */
            /* |   =   |   <              |              >   |   =   | */
            /* +-----------------------------------------------------+ */
            /*  l       a                  b                  h       u*/
            pd=blockmove(pl,pa,pb,swapf);
            pe=blockmove(pb,ph,pu,swapf);
            A(pl<=pd); A(pd<pe); A(pe<=pu);
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG)||DEBUGGING(PARTITION_DEBUG)) {
                (V)fprintf(stderr,"/* %s: %s line %d: (after canonicalization) "
                    "first=%lu, pd@%lu, pe@%lu, beyond=%lu, options=0x%x */\n",
                    __func__,source_file,__LINE__,first,(pd-base)/size,
                    (pe-base)/size,beyond,options);
                print_some_array(base,first,beyond-1UL, "/* "," */",options);
            }
# endif
            /* set *peq, *pgt */
            *peq=(pd-base)/size;
            *pgt=(pe-base)/size;
            return;
        break;
#if QUICKSELECT_STABLE /* not used if QUICKSELECT_STABLE is defined as zero */
        case QUICKSELECT_STABLE :
            /* divide-and-conquer partition */
            A(first<beyond);A(pc<=pd);A(pd<=pivot);A(pivot<=pe);A(pe<=pf);
            divide_and_conquer_partition(base,first,beyond,pc,pd,pivot,pe,pf,
                size,COMPAR_ARGS,swapf,alignsize,size_ratio,cachesz,options,peq,
                pgt);
            A(*peq<=*pgt);A(first<=*peq);A(*pgt<=beyond);
        break;
#endif /* QUICKSELECT_STABLE */
    }
}
#endif /* PARTITION_SRC_H_INCLUDED */
