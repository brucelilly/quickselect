/*INDENT OFF*/

#ifndef	QUICKSELECT_CONFIG_H_INCLUDED
/* Description: configuration macros for quickselect and qsort plus variants */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    quickselect_config.h copyright 2017-2019 Bruce Lilly.   \ quickselect_config.h $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is quickselect_config.h version 1.23 dated 2019-03-16T15:37:11Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/include/s.quickselect_config.h */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and a pair of indices brackets the sub-array
 being processed.  The indices correspond to the ranks of elements.  A similar
 scheme is used by Musser's introsort, described in "Introspective Sorting and
 Selection Algorithms".  The same method is used for the array of desired order
 statistic ranks, similar to that described by Lent & Mahmoud.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.
 Partitioning can still result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by efficient inline swap functions.  No attempt
 is made to optimize for specific array element types, but swapping can be
 performed in units of basic language types.  The swap functions avoid useless
 work (e.g. when given two pointers to the same element).  No specialized macros
 are required.
******************************************************************************/

/* version-controlled header file version information */
/* If you edit this file, you might wish to append something to the version
   string to indicate so...
*/
#define QUICKSELECT_CONFIG_H_VERSION "quickselect_config.h 1.23 2019-03-16T15:37:11Z"

/* compile-time configuration options */
/* assertions for validation testing */
#ifndef ASSERT_CODE
# define ASSERT_CODE                     0 /* Adds size & cost to aid debugging.
                                              0 for tested production code. */
                                           /* If ASSERT_CODE > 1, assertions
                                              might also affect the number of
                                              comparisons used.
                                           */
#endif
#ifndef DEBUG_CODE
# define DEBUG_CODE                      0
#endif
#ifndef SILENCE_WHINEY_COMPILERS
# define SILENCE_WHINEY_COMPILERS        1 /* >0 whiney compilers STFU */
#endif

/* tuning */
/* static inline (1) or separate major functions (0) */
#ifndef QUICKSELECT_BUILD_FOR_SPEED
# define QUICKSELECT_BUILD_FOR_SPEED      1
#endif

/* The sorting network for 3 elements can be arranged to favor already-sorted
   and reverse-sorted inputs (1), or to favor bitonic inputs (0). Already-sorted
   and reverse-sorted inputs are handled quickly, so favoring bitonic inputs
   here (define FAVOR_SORTED as 0) is recommended.  FAVOR_SORTED only matters
   if the size 3 sorting network is used (see below for configuration of
   sorting network sizes).
*/
#define FAVOR_SORTED                     0 /* configure this */

/* It is possible to override defined constants in quickselect.h here.
   Command-line compilation arguments can override this.
*/
/* Quickselect can sort or select preserving partial order stability.  However,
   code size approximately doubles, and there is a significant run-time cost
   (only when stable sorting or selection is requested, of course).
   Partial order stability is a non-issue for scalar data, and multivariate
   data is most efficiently sorted using multivariate comparisons.  It is
   therefore recommended to define QUICKSELECT_STABLE as 0 (zero) for general-
   purpose use.
*/
#ifndef QUICKSELECT_STABLE
# if 1 /* configure this: 1 to support stable sort/select, 0 to disable */
#  define QUICKSELECT_STABLE             0x01U
# else
#  define QUICKSELECT_STABLE             0 /* don't change this! */
# endif
#endif

/* Stable (w.r.t. partial order) partitioning is available in two varieties:
   1. An in-place recursive method based on merging partitions, with expected
      complexity O(N log N) [leading to O(N log ^2 (N)) stable sorting and
      O(N log N) stable selection]
   2. A method using O(N) additional space for condition variables and indices
      with expected linear complexity, but suffering from relatively poor
      locality of access (cache effects for large data arrays, where "large" is
      dependent on cache size vs. the product of the number of data elements and
      element size)).
   QUICKSELECT_LINEAR_STABLE can be defined as 0 to exclude the second method if
   stable sorting and selection is configured.  Nothing to do here if
   QUICKSELECT_STABLE is not configured (i.e. defined as 0).
*/
#if QUICKSELECT_STABLE
# if 1 /* configure this: 1 to include O(N) space method, 0 to exclude */
# define QUICKSELECT_LINEAR_STABLE QUICKSELECT_STABLE /* don't change this! */
# else
# define QUICKSELECT_LINEAR_STABLE 0 /* don't change this! */
# endif
#else /* no O(N) space method w/o in-place method (fallback for ENOMEM) */
# define QUICKSELECT_LINEAR_STABLE QUICKSELECT_STABLE /* don't change this! */
#endif /* QUICKSELECT_STABLE */

/* For testing and for no-repivot code (modified qsort, simplified qsort),
   avoid setting QUICKSELECT_RESTRICT_RANK if QUICKSELECT_NO_REPIVOT is set.
   This bit can be set (once) in the initial call; it persists through
   functions which call quickselect_loop.
*/
#define QUICKSELECT_NO_REPIVOT        0x010U

/* For testing and median_test code, always select if selection is specified
   (do not sort, even for large numbers of order statistics).
*/
#define QUICKSELECT_STRICT_SELECTION  0x020U

/* Small-array sorting and stable partitioning work well when the data (and
   ancillary data, when applicable) fit in processor cache memory.  Cache size
   is determined from the operating system if possible, but few systems provide
   a portable mechanism (i.e. working for all processor types and portable
   operating systems) for obtaining that information.  If unavailable, a default
   value is used, and that value is configurable.  It's probably not worth
   obsessing over for general-purpose use, but might be useful in embedded
   systems.  The default default (16kiB) presumes a conservative value
   appropriate for systems with a 16kiB L1 data cache, such as e.g. on some
   Intel(R) Celeron(R) processors.  The default can be changed, e.g. if building
   for an embedded system which lacks OS support for determining the cache size
   at run time.
*/
# define QUICKSELECT_DEFAULT_CACHE_SIZE 16384UL

/* Allocated memory access performance may be improved by assuring alignment to
   cache line size or TLB page size.  Aligned memory can be allocated via C11
   aligned_alloc() or optional POSIX posix_memalign().  Some systems support
   both, some support one but not the other, and some support neither.  E.g.
   NetBSD using gcc with -stdc11 has no aligned_alloc, even though it is
   supposed to be a standard function.  Define the following macros as non-zero
   if the corresponding allocation function is available.  Precedence is to
   use aligned_alloc if available, else posix_memalign, and if neither is
   available, memory allocation will use malloc().
*/
#define QUICKSELECT_USE_ALIGNED_ALLOC  0
#define QUICKSELECT_USE_POSIX_MEMALIGN 1

#if 1
# define QUICKSELECT_DEFAULT_ALIGNMENT  64 /* largest probable cache line size */
#else
# define QUICKSELECT_DEFAULT_ALIGNMENT  4096 /* likely page size */
#endif

/* C11 defines aligned_alloc, but no aligned versions of calloc or realloc; it
   is assumed(!) that realloc doesn't decrease the alignment when decreasing the
   size of the allocated block...
*/
#define REALLOC_DOES_NOT_DECREASE_ALIGNMENT 1

/* Avoid sorting networks for nmemb>QUICKSELECT_MAX_NETWORK (saves code space,
   faster for inputs with duplicate values). Range 3-16 (sizes 2-3 are always
   used; there are none available > 16). Recommended value 5.  Note in
   particular that sorting networks are data oblivious; they use the same
   number of comparisons for any input, even "easy" inputs such as constant
   values or already-sorted inputs (which divide-and-conquer, merge sorts, and
   even insertion sort can handle efficiently).
*/
#define QUICKSELECT_MAX_NETWORK 5

/*******************************************************************************
   Nothing to configure below this line. The remainder of this file contains
   internal definitions excluded from the public header file quickselect.h.
*******************************************************************************/

/* Indirection (i.e. initially moving pointers to the data instead of the data
   elements, followed by a rearrangement of the data elements after their final
   positions have been determined) is used internally for modest-sizes arrays
   of large elements (when moving pointers is less costly than moving data
   elements) and is available for all arrays as a user-visible option in
   quickselect.  There is no guarantee of partial order stability for qsort.
*/
#define QUICKSELECT_INDIRECT           0x04U

/* Don't use median-of-medians or "full" remedian if there are fewer than 3 sets
   of 3 elements available.
*/
#define SELECTION_MIN_REPIVOT            9UL

/* for assertions */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* space-saving abbreviations */
#undef V
#define V void
#undef A
#define A(me) assert(me)

#if QUICKSELECT_USE_ALIGNED_ALLOC
/* Linux magic incantation for aligned_alloc */
# if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201101L) /* C11 */
# define _ISOC11_SOURCE
# endif /* C11 */
#endif

#if QUICKSELECT_USE_POSIX_MEMALIGN
/* Linux magic incantation for posix_memalign */
# ifndef _POSIX_C_SOURCE
#  define _POSIX_C_SOURCE 200112L
# endif
#endif

#ifndef QUICKSELECT_INLINE
# if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
#  define QUICKSELECT_INLINE inline
# else
#  define QUICKSELECT_INLINE /**/
# endif /* C99 */
#endif

#ifndef QUICKSELECT_STATIC
# define QUICKSELECT_STATIC static
#endif

/* special case for fmed3 and variants which are inline when building for speed
   and externally visible in separate object files otherwise.
*/
#if (( ! defined(QUICKSELECT_FMED3_VISIBLE_HERE)) || ( ! QUICKSELECT_FMED3_VISIBLE_HERE )) && ( QUICKSELECT_BUILD_FOR_SPEED )
# define QUICKSELECT_FMED3_STATIC static
# if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
#  define QUICKSELECT_FMED3_INLINE inline
# endif
#endif

/* need defined names for qsort and qsort_s implementations */
/* also provides declarations for quickselect and quickselect_s */
#if ! defined(QSORT_FUNCTION_NAME) \
|| ! defined(QUICKSELECT_OPTIMIZE_COMPARISONS) \
|| ! defined(QUICKSELECT_RESTRICT_RANK) \
|| ! defined(QUICKSELECT_INDIRECT)
# include "quickselect.h"
#endif

/* regular vs. _s variations: */
#if __STDC_WANT_LIB_EXT1__
/* function name variation */
# define FUNCTION_NAME QSORT_S_FUNCTION_NAME
/* nmemb,size argument type variation */
# define NMEMB_SIZE_TYPE rsize_t
/* comparison argument(s) variation */
# ifndef COMPAR_DECL
#  define COMPAR_DECL int(*compar)(const void*,const void*,void*),void*context
# endif
/* support function comparison arg(s) */
# ifndef COMPAR_ARGS
#  define COMPAR_ARGS compar,context
# endif
/* comparison function call variation */
# define COMPAR(ma,mb) compar((ma),(mb),context)
/* support functions */
#else /* ! __STDC_WANT_LIB_EXT1__ */
# define FUNCTION_NAME QSORT_FUNCTION_NAME
# define NMEMB_SIZE_TYPE size_t
# ifndef COMPAR_DECL
#  define COMPAR_DECL int(*compar)(const void *,const void *)
# endif
# ifndef COMPAR_ARGS
#  define COMPAR_ARGS compar
# endif
# define COMPAR(ma,mb) compar((ma),(mb))
#endif /* __STDC_WANT_LIB_EXT1__ */

/* macros */
#if ! LIBMEDIAN_TEST_CODE
# ifndef SWAP_COUNT_STATEMENT
#  define SWAP_COUNT_STATEMENT /**/
# endif
#endif

/* watch the moving qualifiers */
#define OPT_COMPAR(ma,mb,mopts)   ((0U==((mopts)&(QUICKSELECT_INDIRECT)))? \
   COMPAR((ma),(mb)):COMPAR(*((char *const *)(ma)),*((char *const *)(mb))))

/* compare-exchange primitive for sorting networks */
#if SILENCE_WHINEY_COMPILERS /* no ambiguity here... */
# define COMPARE_EXCHANGE(ma,mb,mopts,msize,mswapf,malignsize,msize_ratio) \
   if(0<OPT_COMPAR((ma),(mb),(mopts))) {                                         \
       EXCHANGE_SWAP(mswapf,(ma),(mb),msize,malignsize,msize_ratio,SWAP_COUNT_STATEMENT); }
   /* Programmer's terminating semicolon is now an excess statement.
      And this precludes a following "else".
      "Thanks" :-/ gcc.
   */
#else
# define COMPARE_EXCHANGE(ma,mb,mopts,msize,mswapf,malignsize,msize_ratio) \
   if(0<OPT_COMPAR((ma),(mb),(mopts)))                                           \
       EXCHANGE_SWAP(mswapf,(ma),(mb),msize,malignsize,msize_ratio,SWAP_COUNT_STATEMENT)
#endif

#define CX(ma,mb) COMPARE_EXCHANGE((ma),(mb),options,size,swapf,alignsize,size_ratio)

/* system header files required */
#include <assert.h>             /* assert */
#include <errno.h>              /* errno E* */
#if defined(__STDC__) && ( __STDC__ == 1 ) && defined(__STDC_VERSION__) && ( __STDC_VERSION__ >= 199901L )
# include <stdint.h>           /* (header not standardized pre-C99) SIZE_MAX */
#endif /* C99 or later */
#ifndef SIZE_MAX /* not standardized pre-C99 */
# include <limits.h>           /* ULONG_MAX */
# define SIZE_MAX ULONG_MAX
#endif /* SIZE_MAX */
#include <stddef.h>             /* NULL size_t */
#include <string.h>             /* strerror */
#include <unistd.h>             /* sysconf _SC_* */
#if ASSERT_CODE + DEBUG_CODE
# include <stdio.h>
#endif /* ASSERT_CODE + DEBUG_CODE */

/* local header files */
#include "tables.h"             /* sampling_table_struct SAMPLING_TABLE_SIZE */

/* macros */
/* Selecting the middle m of a range from low l to high h often appears in naive
   code as m=(l+h)/2, but that can lead to overflow if l and h are large.  An
   equivalent avoiding overflow is m=l+(h-l)/2, and an alternative which favors
   high values is m=h-(h-l)/2.  These are defined as macros BS_MID_L and
   BS_MID_H.  Bit shifts are used here as they are sometimes faster than
   integer division.
*/
#define BS_MID_L(ml,mh) (ml)+(((mh)-(ml))>>1)
#define BS_MID_H(ml,mh) (mh)-(((mh)-(ml))>>1)

/* inline code */
/* cache_size is called by qsort[_s], quickselect[_s], introsort, mbmqsort,
   logsort, sqrtsort, sqsort, wqsort, dual, and dedsort (dedicated_sort.c).
*/
/* Determine cache size (from OS if possible, otherwise use a default value).
   But there is no standard interface for doing so; ISO C doesn't address this
   issue at all, but does worry about buffer size for really slow ("physical
   devices such as terminals and tape drives") I/O.  POSIX and X/OPEN don't
   address it either, but worry about providing a C run-time interface to
   determine limits for infrequently-used interactive commands like bc (which
   could be documented in a man page).  Some operating systems do provide
   extension(s) to POSIX and X/OPEN sysconf to provide information about cache
   size(s), although at least one OS and its derivatives always fail when such
   an extension is used, for any supported processor type.  Go figure.
   Most (all modern?) processors have at least 16kiB L1 cache.  Any with less
   (and many with only that amount!) aren't intended for high performance, and
   that value is safe for those that may have larger cache (although in that
   case performance could be improved with a larger value).
*/
static QUICKSELECT_INLINE
size_t cache_size(void)
{
    register size_t c = 0UL;
#if 1
#if defined(_SC_LEVEL1_DCACHE_SIZE) || defined(_SC_LEVEL2_CACHE_SIZE) || \
    defined(_SC_LEVEL3_CACHE_SIZE) || defined(_SC_LEVEL4_CACHE_SIZE) || \
    defined(_SC_DCACHE_SZ)
    register long l;
#endif
#ifdef _SC_LEVEL1_DCACHE_SIZE
    errno=0;
    l=sysconf(_SC_LEVEL1_DCACHE_SIZE);
    if (l>(long)c) {
        c=(size_t)l;
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(CACHE_DEBUG)) {
            (V)fprintf(stderr,
                "/* %s: cache size based on %s = %lu bytes */\n",
                __func__,
                "_SC_LEVEL1_DCACHE_SIZE",
                (unsigned long)c);
        }
#endif
    }
# if ((DEBUG_CODE)>0)
    else if (l<0L) (V)fprintf(stderr,
        "/* %s: OS ERROR: %s is defined, but sysconf returns "
        "%ld with errno=%d(%s) */\n",
        __func__,
        "_SC_LEVEL1_DCACHE_SIZE",
        l,errno,strerror(errno));
# endif /* DEBUG_CODE */
# ifdef _SC_LEVEL1_DCACHE_LINESIZE
#  if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(CACHE_DEBUG)) {
        l=sysconf(_SC_LEVEL1_DCACHE_LINESIZE);
        (V)fprintf(stderr,
            "/* %s: cache linesize based on %s = %ld bytes */\n",
            __func__, "_SC_LEVEL1_DCACHE_LINESIZE", l);
    }
#  endif
# endif /* _SC_LEVEL1_DCACHE_LINESIZE */
#endif /* _SC_LEVEL1_DCACHE_SIZE */
#if 0 /* 0: use only L1 or generic data cache */
#ifdef _SC_LEVEL2_CACHE_SIZE
    errno=0;
    l=sysconf(_SC_LEVEL2_CACHE_SIZE);
    /* Use only 1/2 of unified cache */
    if (l>(long)(c<<1)) {
        c=(size_t)(l>>1);
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(CACHE_DEBUG)) {
            (V)fprintf(stderr,
                "/* %s: cache size based on %s (%ld) = %lu bytes */\n",
                __func__,
                "_SC_LEVEL2_CACHE_SIZE",
                l,(unsigned long)c);
        }
#endif
    }
# if ((DEBUG_CODE)>0)
    else if (l<0L) (V)fprintf(stderr,
        "/* %s: OS ERROR: %s is defined, but sysconf returns "
        "%ld with errno=%d(%s) */\n",
        __func__,
        "_SC_LEVEL2_CACHE_SIZE",
        l,errno,strerror(errno));
# endif /* DEBUG_CODE */
#endif /* _SC_LEVEL2_CACHE_SIZE */
#if 0 /* use/don't use Level 3 cache */
#ifdef _SC_LEVEL3_CACHE_SIZE
    errno=0;
    l=sysconf(_SC_LEVEL3_CACHE_SIZE);
    /* Use only 1/2 of unified cache */
    if (l>(long)(c<<1)) {
        c=(size_t)(l>>1);
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(CACHE_DEBUG)) {
            (V)fprintf(stderr,
                "/* %s: cache size based on %s (%ld) = %lu bytes */\n",
                __func__,
                "_SC_LEVEL3_CACHE_SIZE",
                l,(unsigned long)c);
        }
#endif
    }
# if ((DEBUG_CODE)>0)
    else if (l<0L) (V)fprintf(stderr,
        "/* %s: OS ERROR: %s is defined, but sysconf returns "
        "%ld with errno=%d(%s) */\n",
        __func__,
        "_SC_LEVEL3_CACHE_SIZE",
        l,errno,strerror(errno));
# endif /* DEBUG_CODE */
#endif /* _SC_LEVEL3_CACHE_SIZE */
#endif
#if 0 /* Use/don't use Level 4 cache */
#ifdef _SC_LEVEL4_CACHE_SIZE
    errno=0;
    l=sysconf(_SC_LEVEL4_CACHE_SIZE);
    /* Use only 1/2 of unified cache */
    if (l>(long)(c<<1)) {
        c=(size_t)(l>>1);
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(CACHE_DEBUG)) {
            (V)fprintf(stderr,
                "/* %s: cache size based on %s (%ld) = %lu bytes */\n",
                __func__,
                "_SC_LEVEL4_CACHE_SIZE",
                l,(unsigned long)c);
        }
#endif
    }
# if ((DEBUG_CODE)>0)
    else if (l<0L) (V)fprintf(stderr,
        "/* %s: OS ERROR: %s is defined, but sysconf returns "
        "%ld with errno=%d(%s) */\n",
        __func__,
        "_SC_LEVEL4_CACHE_SIZE",
        l,errno,strerror(errno));
# endif /* DEBUG_CODE */
#endif /* _SC_LEVEL4_CACHE_SIZE */
#endif /* L4 */
#endif /* no L2, L3, L4 */
#ifdef _SC_DCACHE_SZ
    errno=0;
    l=sysconf(_SC_DCACHE_SZ);
    if (l>(long)c) {
        c=(size_t)l;
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(CACHE_DEBUG)) {
            (V)fprintf(stderr,
                "/* %s: cache size based on %s = %lu bytes */\n",
                __func__,
                "_SC_DCACHE_SZ",
                (unsigned long)c);
        }
#endif
    }
# if ((DEBUG_CODE)>0)
    else if (l<0L) (V)fprintf(stderr,
        "/* %s: OS ERROR: %s is defined, but sysconf returns "
        "%ld with errno=%d(%s) */\n",
        __func__,
        "_SC_DCACHE_SZ",
        l,errno,strerror(errno));
# endif /* DEBUG_CODE */
#endif /* _SC_DCACHE_SZ */
#endif /* fixed default size only */
    if (0UL==c) {
        c= QUICKSELECT_DEFAULT_CACHE_SIZE ;
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(CACHE_DEBUG)) {
            (V)fprintf(stderr,
                "/* %s: Assuming default cache size = %lu bytes */\n",
                __func__,
                (unsigned long)c);
        }
#endif
    }
#if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(CACHE_DEBUG)) {
        (V)fprintf(stderr,
            "/* %s: cache size = %lu bytes */\n",
            __func__,(unsigned long)c);
    }
#endif
    return c;
}

#define	QUICKSELECT_CONFIG_H_INCLUDED 1
#endif /* QUICKSELECT_CONFIG_H_INCLUDED */
