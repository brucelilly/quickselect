/*INDENT OFF*/

#ifndef	QUICKSELECT_CONFIG_H_INCLUDED
/* Description: configuration macros for quickselect and qsort plus variants */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    quickselect_config.h copyright 2017 Bruce Lilly.   \ quickselect_config.h $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is quickselect_config.h version 1.7 dated 2017-12-22T04:14:04Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/include/s.quickselect_config.h */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and a pair of indices brackets the sub-array
 being processed.  The indices correspond to the ranks of elements.  A similar
 scheme is used by Musser's introsort, described in "Introspective Sorting and
 Selection Algorithms".  The same method is used for the array of desired order
 statistic ranks, similar to that described by Lent & Mahmoud.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.
 Partitioning can still result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by efficient inline swap functions.  No attempt
 is made to optimize for specific array element types, but swapping can be
 performed in units of basic language types.  The swap functions avoid useless
 work (e.g. when given two pointers to the same element).  No specialized macros
 are required.
******************************************************************************/

/* version-controlled header file version information */
/* If you edit this file, you might wish to append something to the version
   string to indicate so...
*/
#define QUICKSELECT_CONFIG_H_VERSION "quickselect_config.h 1.7 2017-12-22T04:14:04Z"

/* compile-time configuration options */
/* assertions for validation testing */
#ifndef ASSERT_CODE
# define ASSERT_CODE                     0 /* Adds size & cost to aid debugging.
                                              0 for tested production code. */
                                           /* If ASSERT_CODE > 1, assertions
                                              might also affect the number of
                                              comparisons used.
                                           */
#endif
#ifndef SILENCE_WHINEY_COMPILERS
# define SILENCE_WHINEY_COMPILERS        1 /* >0 whiney compilers STFU */
#endif

/* tuning */
/* static inline (1) or separate major functions (0) */
#define QUICKSELECT_BUILD_FOR_SPEED      1

/* Repivoting parameters (for sorting) control the tradeoff between minimal
   effect on random inputs and effective repivoting of adverse inputs.
   Choices are (defined by macros later):
    DISABLED    repivot only under extreme circumstances
    TRANSPARENT (almost) no repivots for random inputs
    LOOSE       worst adverse sorting performance < 2.0 N log(N)
    RELAXED     adverse input sorting performance < 1.5 N log(N)
    AGGRESSIVE  best practical adverse input sorting performance
# define SORTING_TABLE_ENTRIES           DISABLED
# define SORTING_TABLE_ENTRIES           TRANSPARENT
# define SORTING_TABLE_ENTRIES           LOOSE
# define SORTING_TABLE_ENTRIES           RELAXED
# define SORTING_TABLE_ENTRIES           AGGRESSIVE
*/
#ifndef SORTING_TABLE_ENTRIES
# undef DISABLED
# undef TRANSPARENT
# undef LOOSE
# undef RELAXED
# undef AGGRESSIVE
  /* Configure by copying one of the commented lines (above) below this line. */
# define SORTING_TABLE_ENTRIES           RELAXED
  /* FYI: selection is more sensitive to lopsided partitions and always uses
     very aggressive repivoting (not configurable).
  */
#endif

/* The sorting network for 3 elements can be arranged to favor already-sorted
   and reverse-sorted inputs (1), or to favor bitonic inputs (0). Already-sorted
   and reverse-sorted inputs are handled quickly, so favoring bitonic inputs
   here (define FAVOR_SORTED as 0) is recommended.  FAVOR_SORTED only matters
   if the size 3 sorting network is used (see below for configuration of
   sorting network sizes).
*/
#define FAVOR_SORTED                     0 /* configure me */

/* It is possible to override defined constants in quickselect.h here.
   Command-line compilation arguments can override this.
*/
/* Quickselect can sort or select preserving partial order stability.  However,
   code size approximately doubles, and there is a significant run-time cost.
   Partial order stability is a non-issue for scalar data, and multivariate
   data is most efficiently sorted using multivariate comparisons.  It is
   therefore recommended to define QUICKSELECT_STABLE as 0 (zero) for general-
   purpose use.
*/
#ifndef QUICKSELECT_STABLE
# if 1 /* configure me: 1 to support stable sort/select, 0 to disable */
#  define QUICKSELECT_STABLE             0x01U
# else
#  define QUICKSELECT_STABLE             0 /* don't change this! */
# endif
#endif

/* If QUICKSELECT_INDIRECT is pre-defined as zero, sorting will be direct
   unless arranged externally by the caller and object code size will be
   reduced slightly.  Internal indirection uses O(N) + O(1) additional space for
   an array of pointers and a memory block to hold a temporary base array
   element.  For non-trivial base array element size, it reduces data
   movement cost by rearranging (permuting) base array elements after
   indirectly sorting by low-cost pointer movement.  However, rearranging
   base array elements has poor locality of access, and therfore suffers
   from machine-dependent (cache-related) performance issues when the
   base array (product of element size and number of elements) becomes
   large relative to memory cache size.  The caller can of course arrange
   for explicit indirect sorting by allocating and initializing an array of
   pointers, providing a comparison function which indirectly accesses the
   base elements for comparisons, and optionally rearranging base data
   elements after indirect sorting of pointers (or accessing base elements
   indirectly via the sorted pointers) [see header file indirect.h].  Such a
   method is fully compatible with the internal indirect sorting (the internal
   method never uses additional indirection when sorting trivial types such as
   pointers), but the internal method can provide some performance tweaks by
   caching dereferenced pointers e.g. for pivot comparisons during
   partitioning.  Because of the cache-related performance degradation and the
   difficulty of efficiently determining cache sizes at run-time, internal
   indirection is not recommended for general-purpose use (the performance
   tweaks may be useful for application-specific cases).
*/
#ifndef QUICKSELECT_INDIRECT
# if 1 /* configure me: 1 to support internal indirection, 0 to disable */
   /* 0x04U for user-visible, 0x04000U for internal flag */
   /* N.B. for internal flag, you'll need to provide some heuristic for deciding
      when to use indirect vs. direct sorting/selection in qsort_src.h, 
      quickselect_src.h
   */
#  define QUICKSELECT_INDIRECT           0x04U /* configure me too */
# else
#  define QUICKSELECT_INDIRECT           0 /* don't change this! */
# endif
#endif

/* Sorting networks are data-oblivious; the same number of comparisons are
   made regardless of the input sequence.  Optimal (but non-stable) sorting
   networks have low overhead. Stable variants (through size 6) operate as
   unrolled insertion sort.  However, sorting networks can theoretically
   take advantage of parallel operations, unlike insertion sort. As each
   sorting network (for a particular sub-array size) is distinct from the
   networks used for other sizes, the code size increases with each additional
   sorting network included.  Size 2 is a simple, efficient compare-exchange
   network which is always used for sorting 2 elements.  Larger sizes may be
   included, through size 12, by setting appropriate bits in
   QUICKSELECT_NETWORK_MASK.  Size 3 is implemented as a decision tree, which
   is slightly more general, and which can be futher configured (near the top
   of the configuration options in this file) to favor certain input sequences.
*/
#ifndef QUICKSELECT_NETWORK_MASK
# if 0 /* configure me: 1 for network sort sizes 2-12 */
   /* If you change this, also change the relevant comments! */
#  define QUICKSELECT_NETWORK_MASK       0x01FF8U /* 2-12 */
# else
#  if 1 /* configure me: 1 for network sort sizes 2-3 */
   /* If you change this, also change the relevant comments! */
#   define QUICKSELECT_NETWORK_MASK      0x08U /* 3 only */
#  else
#   define QUICKSELECT_NETWORK_MASK      0x0U /* 2 only */
#  endif
# endif
#endif

/* Stable (w.r.t. partial order) partitioning is available in two varieties:
   1. An in-place recursive method based on merging partitions, with expected
      complexity O(N log N) [leading to O(N log ^2 (N)) stable sorting and
      O(N log N) stable selection]
   2. A method using O(N) additional space for condition variables and indices
      with expected linear complexity, but suffering from relatively poor
      locality of access (cache effects for large data arrays, where "large" is
      dependent on cache size vs. the product of the number of data elements and
      element size)).
   QUICKSELECT_LINEAR_STABLE can be defined as 0 to exclude the second method if
   stable sorting and selection is configured.  Nothing to do here if
   QUICKSELECT_STABLE is not configured (i.e. defined as 0).
*/
#if QUICKSELECT_STABLE
# if 1 /* configure me: 1 to include O(N) space method, 0 to exclude */
# define QUICKSELECT_LINEAR_STABLE QUICKSELECT_STABLE /* don't change this! */
# else
# define QUICKSELECT_LINEAR_STABLE 0 /* don't change this! */
# endif
#else /* no O(N) space method w/o in-place method (fallback for ENOMEM) */
# define QUICKSELECT_LINEAR_STABLE QUICKSELECT_STABLE /* don't change this! */
#endif /* QUICKSELECT_STABLE */

/*******************************************************************************
   Nothing to configure below this line. The remainder of this file contains
   internal definitions excluded from the public header file quickselect.h.
*******************************************************************************/

/* Don't use median-of-medians or "full" remedian if there are fewer than 3 sets
   of 3 elements available.
*/
#define SELECTION_MIN_REPIVOT            9UL

/* In-place merge sort is slower than insertion sort for small sub-arrays, but
   is faster for larger sub-arrays.
*/
#define INPLACE_MERGE_CUTOFF             155UL

/* repivot tuning */
#define DISABLED    0
#define TRANSPARENT 1 /* (almost) no repivots for random inputs */
#define LOOSE       2 /* adversary < 2.0 N log N */
#define RELAXED     3 /* adversary < 1.5 N log N */
#define AGGRESSIVE  4 /* minimum adversary comparison complexity < 1.4 N log N */

/* defaults */
 /* in case not defined above */
#ifndef SORTING_TABLE_ENTRIES
# define SORTING_TABLE_ENTRIES RELAXED
#endif
 /* in case of bogus definition above */
#if (( SORTING_TABLE_ENTRIES != DISABLED ) \
  && ( SORTING_TABLE_ENTRIES != TRANSPARENT ) \
  && ( SORTING_TABLE_ENTRIES != LOOSE ) \
  && ( SORTING_TABLE_ENTRIES != RELAXED ) \
  && ( SORTING_TABLE_ENTRIES != AGGRESSIVE ) \
)
# undef SORTING_TABLE_ENTRIES
# define SORTING_TABLE_ENTRIES RELAXED
#endif

/* space-saving abbreviations */
#undef V
#define V void
#undef A
#define A(me) assert(me)

#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
# define QUICKSELECT_INLINE inline
#else
# define QUICKSELECT_INLINE /**/
#endif /* C99 */

/* need defined names for qsort and qsort_s implementations */
/* also provides declarations for quickselect and quickselect_s */
#if ! defined(QSORT_FUNCTION_NAME) \
|| ! defined(QUICKSELECT_OPTIMIZE_COMPARISONS) \
|| ! defined(QUICKSELECT_RESTRICT_RANK) \
|| ! defined(QUICKSELECT_INDIRECT)
# include "quickselect.h"
#endif

/* regular vs. _s variations: */
#if __STDC_WANT_LIB_EXT1__
/* Return type variation */
# define QSORT_RETURN_TYPE errno_t
/* function name variation */
# define FUNCTION_NAME QSORT_S_FUNCTION_NAME
/* nmemb,size argument type variation */
# define NMEMB_SIZE_TYPE rsize_t
/* comparison argument(s) variation */
# define COMPAR_DECL int(*compar)(const void*,const void*,void*),void*context
/* support function comparison arg(s) */
# define COMPAR_ARGS compar,context
/* comparison function call variation */
# define COMPAR(ma,mb,mc) compar(ma,mb,mc)
# if QUICKSELECT_INDIRECT
#  define OPT_COMPAR(ma,mb,mopts,mc) ((0U==(mopts&(QUICKSELECT_INDIRECT)))?\
     compar(ma,mb,mc):compar(*((char *const *)(ma)),*((char *const *)(mb)),mc))
# else
#  define OPT_COMPAR(ma,mb,mopts,mc) COMPAR(ma,mb,mc)
# endif /* QUICKSELECT_INDIRECT */
/* support functions */
# define DEDICATED_SORT dedicated_sort_s
# define FIND_MINMAX_FUNCTION_NAME find_minmax_s
# define FMED3_FUNCTION_NAME fmed3_s
# define PARTITION_FUNCTION_NAME partition_s
# define REMEDIAN_FUNCTION_NAME remedian_s
# define SELECT_MAX_FUNCTION_NAME select_max_s
# define SELECT_MIN_FUNCTION_NAME select_min_s
# define SELECT_MINMAX_FUNCTION_NAME select_minmax_s
# define SELECT_PIVOT_FUNCTION_NAME select_pivot_s
# define QUICKSELECT_FUNCTION_NAME quickselect_s
# define QUICKSELECT_LOOP quickselect_loop_s
# define QUICKSORT_LOOP quicksort_loop_s
#else
# define QSORT_RETURN_TYPE void
# define FUNCTION_NAME QSORT_FUNCTION_NAME
# define NMEMB_SIZE_TYPE size_t
# define COMPAR_DECL int(*compar)(const void *,const void *)
# define COMPAR_ARGS compar
# define COMPAR(ma,mb,mc) compar(ma,mb)
# if QUICKSELECT_INDIRECT
#  define OPT_COMPAR(ma,mb,mopts,mc) ((0U==(mopts&(QUICKSELECT_INDIRECT)))?\
      compar(ma,mb):compar(*((char *const *)(ma)),*((char *const *)(mb))))
# else
#  define OPT_COMPAR(ma,mb,mopts,mc) COMPAR(ma,mb,mc)
#endif /* QUICKSELECT_INDIRECT */
# define DEDICATED_SORT dedicated_sort
# define FMED3_FUNCTION_NAME fmed3
# define FIND_MINMAX_FUNCTION_NAME find_minmax
# define PARTITION_FUNCTION_NAME partition
# define REMEDIAN_FUNCTION_NAME remedian
# define SELECT_MAX_FUNCTION_NAME select_max
# define SELECT_MIN_FUNCTION_NAME select_min
# define SELECT_MINMAX_FUNCTION_NAME select_minmax
# define SELECT_PIVOT_FUNCTION_NAME select_pivot
# define QUICKSELECT_FUNCTION_NAME quickselect
# define QUICKSELECT_LOOP quickselect_loop
# define QUICKSORT_LOOP quicksort_loop
#endif /* __STDC_WANT_LIB_EXT1__ */

/* declarations for internal publicly-visible functions */
/* cutoff_value declaration */
QUICKSELECT_EXTERN
#include "cutoff_value_decl.h"
;
/* dedicated_sort declaration */
QUICKSELECT_EXTERN
#include "dedicated_sort_decl.h"
;
/* quickselect_loop declaration */
QUICKSELECT_EXTERN
#include "quickselect_loop_decl.h"
;

/* defined values for pivot_method */
  /* no data movement */
#define QUICKSELECT_PIVOT_REMEDIAN_SAMPLES  0
#define QUICKSELECT_PIVOT_REMEDIAN_FULL     1
  /* alters data order (cannot be used for stable sort/selection) */
#define QUICKSELECT_PIVOT_MEDIAN_OF_MEDIANS 2

/* defined values for partition_method */
  /* partial order not preserved (cannot be used for stable sort/selection) */
#define QUICKSELECT_PARTITION_FAST   0
  /* partial order preserved */
#define QUICKSELECT_PARTITION_STABLE 1

#define	QUICKSELECT_CONFIG_H_INCLUDED
#endif
