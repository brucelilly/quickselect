/*INDENT OFF*/

/* Description: C source code for select_pivot */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    pivot_src.h copyright 2017-2019 Bruce Lilly.   \ pivot_src.h $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is pivot_src.h version 1.25 dated 2019-03-16T14:44:14Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/include/s.pivot_src.h */

/********************** Long description and rationale: ***********************
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.
 Partitioning can still result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
******************************************************************************/

/* Minimum _XOPEN_SOURCE version for C99 (else illumos compilation fails) */
#undef MAX_XOPEN_SOURCE_VERSION
#undef MIN_XOPEN_SOURCE_VERSION
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# define MIN_XOPEN_SOURCE_VERSION 600 /* >=600 for illumos */
#else
# define MAX_XOPEN_SOURCE_VERSION 500 /* <=500 for illumos */
#endif

/* feature test macros defined before any header files are included */
#ifndef _XOPEN_SOURCE
# ifdef MIN_XOPEN_SOURCE_VERSION
#  define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
# else
#  ifdef MAX_XOPEN_SOURCE_VERSION
#   define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#  endif
# endif
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MIN_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE < MIN_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MAX_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE > MAX_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#endif

#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
   ID_STRING_PREFIX is suitable for the what(1) and ident(1) utilities.
   MODULE_DATE uses modern SCCS extensions.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: pivot_src.h ~|^` @(#)"
#define SOURCE_MODULE "pivot_src.h"
#define MODULE_VERSION "1.25"
#define MODULE_DATE "2019-03-16T14:44:14Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
#define COPYRIGHT_DATE "2017-2019"

/* local header files needed */
#include "exchange.h"           /* EXCHANGE_SWAP */
#include "quickselect_config.h" /* QUICKSELECT_INLINE */
#include "tables.h"             /* sampling_table_struct SAMPLING_TABLE_SIZE */
#if ! QUICKSELECT_BUILD_FOR_SPEED
#include "initialize_src.h"
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* system header files */
#include <assert.h>             /* assert */
#include <errno.h>              /* errno E* (maybe errno_t [N1570 K3.2]) */
#include <stddef.h>             /* size_t NULL (maybe rsize_t) */
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# if __STDC_VERSION__ >= 201001L
    /* [N1570 6.10.8.1] (minimum value: y=0,mm=01) */
#  include <stdio.h>            /* (maybe errno_t rsize_t [N1570 K3.5]) */
#  include <stdlib.h>           /* (maybe errno_t rsize_t constraint_handler_t
                                   [N1570 K3.6]) */
# endif /* N1570 */
#endif /* C99 or later */
#include <stdio.h>              /* stderr fprintf */

#if __STDC_WANT_LIB_EXT1__
/* Preliminary support for 9899:201x draft N1570 qsort_s w/ "context".
   "context" is similar to glibc qsort_r; N1570 also has provision for
   runtime-constraint violation detection and handling. "Preliminary"
   because of the apparent lack of a convincing use-case for "context" and
   due to the poorly defined semantics and interface for constraint
   violation handling.

   Consequences of "context" are wide-ranging: any operation that requires
   comparisons (pivot selection, partitioning, dedicated sorting and/or
   selection, and support functions for any of those) has to be rewritten.
   The only operations unaffected are sampling, basic swaps, blockmoves using
   swaps, rank comparisons, and partition size evaluation; sampling and
   repivoting tables may also be reused without change.
   Executable code size is roughly doubled, not including external
   constraint-handler function code.
   Use case of "context" is questionable; one could simply use an appropriate
   comparison function.  Published supposed examples (e.g.
   https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/qsort-s
   tend to be rather silly (in the specific example above:
      1. functions are defined for specific locales, but not specifically
         implementing locale-specific collation -- one could at least as easily
         define locale-specific string comparison functions using the standard
         strcoll [+] function and use these with qsort to perform the
         locale-specific sorts with no need for "context", and avoiding the
         other implementation issues detailed below.
      2. Aside from inconsistent "context" argument order...
      3. ... the implementation comparison function copies (!) (leading portions
         of) supplied strings to fixed size (!!)[*] local buffers, then makes a
         second set of passes (!!!) over the copies to perform a conversion
         (which is discarded (!!!!) when the comparison function returns), which
         is then subjected to a third (!!!!!) pass to perform the comparison.
         Note that qsort implementations typically call the comparison function
         N log N times for an array of N elements; the above implementation
         makes 2 N log N copies and 6 N log N passes over data representing
         the strings to be sorted.  In particular, at each stage of partitioning
         qsort implementations compare a pivot element to many other elements;
         in the above implementation the string corresponding to that pivot
         element is copied, the copy modified and examined, only to be discarded
         before repeating those steps anew with the same pivot element's string
         for the next comparison.
      4. Although the copies (see #3 above) ignore the actual length of the
         original strings, strlen is subsequently called for each string (copy),
         resulting in a fourth (!!!!!!) pass over the data. Had strlen been
         called for the initial strings, the copies could have been made
         appropriate sizes (assuming that one still naively wished to make, then
         discard such copies).
      * a possibly-valid use of "context" *might* be to provide the maximum
        string length, avoiding magic numbers and failure to fully compare
        strings which have long identical leading substrings... *if* one
        insisted on the naive implementation involving copies (which are
        subsequently discarded) and multiple passes over the data.  It would
        be much more efficient to make one-time initial transformations (e.g.
        w/ strxfrm [+]) of the original string data supplemented by an index
        indicating the original order (or a pointer to the original string
        data), sorting the transformed and supplemented data using standard
        strcmp on the transformed strings.  That would involve N combined
        transformations and copies (instead of N log N copies and N log N
        transformations) plus N log N standard strcmp string comparisons (rather
        than 6 N log N passes over data), followed by access of the orginal
        string data via the indices or pointers for output.
      + Note that strcoll and strxfrm have been standardized since C89 (a.k.a.
        C90).
   ). In summary, there is no convincing use-case for "context" to justify
   doubling the size of library code.
*/
#endif /* __STDC_WANT_LIB_EXT1__ */

#if QUICKSELECT_BUILD_FOR_SPEED
# include "fmed3_src.h"
#endif

/* Remedian (base 3) of samples, recursive implementation.
   The function does not modify the value pointed to by middle, but it is not
   declared as const to avoid spurious compiler warnings about discarding the
   const qualifier when passing middle to fmed3 (which also doesn't make
   modifications, but see the rationale there)

   Row and sample spacings are in elements.
   The variable idx is the index into the sampling table (with number of samples
      equal to the idx'th power of 3), which provides an inexpensive way of
      determining when to end the recursion
   Uniform sample spacing is maintained, recursively.
*/
static
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
inline
#endif
char *
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
            d_remedian_s
# else
            d_remedian
# endif
#else
# if __STDC_WANT_LIB_EXT1__
            remedian_s
# else
            remedian
# endif
#endif
    (char *middle, size_t row_spacing,
    register size_t sample_spacing, register size_t size,
    register unsigned int idx, 
#if __STDC_WANT_LIB_EXT1__
    int(*compar)(const void *,const void *,const void *),const void *context,
#else
    int(*compar)(const void *,const void *),
#endif
    unsigned int options)
{
    register char *pa, *pb, *pc;
    register size_t o;
#if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(REMEDIAN_DEBUG)) {
        (V)fprintf(stderr,"/* %s: middle=%p, row_spacing=%lu, sample_spacing="
            "%lu, idx=%u */\n",__func__,(void *)middle,
            (unsigned long)row_spacing,(unsigned long)sample_spacing,idx);
    }
#endif
    A((SAMPLING_TABLE_SIZE)>idx);
    if (0U < --idx) {
        register size_t s=sample_spacing/3UL;

        o=s*size;
        pa=
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
            d_remedian_s
# else
            d_remedian
# endif
#else
# if __STDC_WANT_LIB_EXT1__
            remedian_s
# else
            remedian
# endif
#endif
	    (middle-o,row_spacing,s,size,idx,
#if __STDC_WANT_LIB_EXT1__
            compar,context,
#else
	    compar,
#endif
            options);
        pb=
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
            d_remedian_s
# else
            d_remedian
# endif
#else
# if __STDC_WANT_LIB_EXT1__
            remedian_s
# else
            remedian
# endif
#endif
	    (middle,row_spacing,s,size,idx,
#if __STDC_WANT_LIB_EXT1__
            compar,context,
#else
	    compar,
#endif
            options);
        pc=
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
            d_remedian_s
# else
            d_remedian
# endif
#else
# if __STDC_WANT_LIB_EXT1__
            remedian_s
# else
            remedian
# endif
#endif
	    (middle+o,row_spacing,s,size,idx,
#if __STDC_WANT_LIB_EXT1__
            compar,context,
#else
	    compar,
#endif
            options);
        if (0U!=(options&(QUICKSELECT_INDIRECT))) {
            char *pr= 
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                d_fmed3_s
# else
                d_fmed3
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                fmed3_s
# else
                fmed3
# endif
#endif
		(*((char **)pa),
                *((char **)pb), *((char **)pc),
#if __STDC_WANT_LIB_EXT1__
            compar,context,
#else
	    compar,
#endif
	    options
#if LIBMEDIAN_TEST_CODE
            , middle, size
#endif
	    );
            if (pr==*((char **)pa)) return pa;
            if (pr==*((char **)pc)) return pc;
            return pb;
        } else
            return 
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                d_fmed3_s
# else
                d_fmed3
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                fmed3_s
# else
                fmed3
# endif
#endif
		    (pa,pb,pc,
	#if __STDC_WANT_LIB_EXT1__
	            compar,context,
	#else
		    compar,
	#endif
		    options
#if LIBMEDIAN_TEST_CODE
                , middle, size
#endif
		);
    }
    o=row_spacing*size;
    if (0U!=(options&(QUICKSELECT_INDIRECT))) {
        char *pr;
        pa=middle-o, pc=middle+o;
        pr = 
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                d_fmed3_s
# else
                d_fmed3
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                fmed3_s
# else
                fmed3
# endif
#endif
            (*((char **)pa),*((char **)middle),
            *((char **)pc),
#if __STDC_WANT_LIB_EXT1__
	    compar,context,
#else
	    compar,
#endif
	    options
#if LIBMEDIAN_TEST_CODE
             , middle, size
#endif
	    );
        if (pr==*((char **)pa)) return pa;
        if (pr==*((char **)pc)) return pc;
        return middle;
    } else
        return 
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                d_fmed3_s
# else
                d_fmed3
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                fmed3_s
# else
                fmed3
# endif
#endif
		(middle-o,middle,middle+o,
	#if __STDC_WANT_LIB_EXT1__
		 compar,context,
	#else
		 compar,
	#endif
		 options
#if LIBMEDIAN_TEST_CODE
                 , middle, size
#endif
		 );
}

/* Remedian-based fast pivot selection includes single sample and median of
   (uniformly-spaced) 3.
   Doesn't move data (suitable for stable sorting and selection).
   Expected cost (comparisons) for selection of pivot from s samples is
   asymptotically 1.5s (0 for 1 sample, average 8/3 comparisons for 3 samples
   (8/9 s ~ 0.889 s), 32/3 comparisons for 9 samples (32/27 s ~ 1.185 s), 104/3
   comparisons for 27 samples (104/81 s ~ 1.284 s), etc.).
*/
static
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
inline
#endif
char *remedian_pivot_selection(char *base,
    size_t first, size_t beyond, size_t size,
#if __STDC_WANT_LIB_EXT1__
    int(*compar)(const void *,const void *,const void *),const void *context,
#else
    int(*compar)(const void *,const void *),
#endif
    void (*swapf)(char *, char *, size_t), size_t alignsize, size_t size_ratio,
    unsigned int table_index, const size_t *pk, size_t cachesz, size_t pbeyond,
    unsigned int options, char **ppc, char **ppd, char **ppe, char **ppf,
    size_t nmemb)
{
    register char *pivot;
    /*Fast pivot selection:1 sample, median-of-3, remedian of samples.*/
    pivot=base+size*(first+(nmemb>>1));     /* [upper-]middle element */
    if (0U<table_index) {       /* 3 or more samples */
        register size_t r=nmemb/3UL;     /* 1/3 #elements */
#if LIBMEDIAN_TEST_CODE
        /* before pivot selection */
        if (aqcmp==compar) {
            /* freeze low-address samples which will be used for pivot selection */
            (V)freeze_some_samples(base,first,beyond,size,compar,swapf,
                alignsize,size_ratio,table_index,options);
            if (DEBUGGING(WQSORT_DEBUG)) /* how well did it work? */
                (V)fprintf(stderr,"/* %s line %d: first=%lu, beyond=%lu, nmemb="
                    "%lu, %lu samples, nfrozen=%lu, pivot_minrank=%lu */\n",
                    __func__,__LINE__,first,beyond,nmemb,
                    sorting_sampling_table[table_index].samples,nfrozen,
                    pivot_minrank);
        }
#endif
        A(base+first*size<=pivot);A(pivot<base+beyond*size);
        pivot=
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
            d_remedian_s
# else
            d_remedian
# endif
#else
# if __STDC_WANT_LIB_EXT1__
            remedian_s
# else
            remedian
# endif
#endif
            (pivot,r,r,size,table_index,
            
#if __STDC_WANT_LIB_EXT1__
	     compar,context
#else
	     compar
#endif
	     ,options);
    } else { /* offset single sample (middle bad for bitonic input) */
#if LIBMEDIAN_TEST_CODE
        if (aqcmp==compar) nfrozen=0UL, pivot_minrank=1UL;
#endif
        switch (nmemb) {
            case 0UL :
            case 1UL :
            case 2UL :
            case 3UL :
            case 4UL :
            case 6UL :
            case 8UL :
                /* leave pivot at [upper-]middle element */
            break;
            case 5UL :
            case 7UL :
            case 9UL :
                pivot+=size; /* away from middle for bitonic */
            break;
            default :
                pivot+=size*((nmemb-1UL)/8); /* 1/2+1/8=5/8 */
            break;
        }
#if LIBMEDIAN_TEST_CODE
        if (aqcmp==compar) (V)freeze(aqindex(pivot,base,size));
#endif
    }
    *ppc=*ppd=pivot, *ppe=*ppf=pivot+size;
    return pivot;
}

#if 0
/* functions in sampling_table_src.h */
extern QUICKSELECT_INLINE int 
#if LIBMEDIAN_TEST_CODE
                              d_pivot_method
#else
                              pivot_method
#endif
                                          (size_t *, size_t, size_t, size_t, unsigned int, size_t, unsigned int);
extern QUICKSELECT_INLINE size_t 
#if LIBMEDIAN_TEST_CODE
                                 d_samples
#else
                                 samples
#endif
                                        (size_t nmemb, int method, unsigned int distribution, unsigned int options);
#endif

/* floor of base 2 logarithm of size_t argument */
static
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
inline
#endif
size_t floor_log2(register size_t n)
{
    switch (n) {
        default :
            { register size_t l, m, x=floor_log2(SIZE_MAX);
                /* n not an exact power of 2
                   n < SIZE_MAX
                   stop when l==x to avoid overflow of m
                */
                for (l=0UL,m=2UL; (l<x)&&(m<n); l++,m<<=1) ;
                return l;
            }
        break;
        /* huge case */
        case (SIZE_MAX) :
#if ( SIZE_MAX > 65535 ) /* > 16 bits */
# if ( SIZE_MAX > 4294967295 ) /* > 32 bits */
        return 64UL; /* 64 bits */
# endif /* > 32 bits */
        return 32UL; /* 32 bits */
#else
        return 16UL; /* 16 bits */
#endif /* > 16 bits */
        /* exact cases for small n */
        case 32768UL : return 15UL;
        case 16384UL : return 14UL;
        case 8192UL  : return 13UL;
        case 4096UL  : return 12UL;
        case 2048UL  : return 11UL;
        case 1024UL  : return 10UL;
        case 512UL   : return 9UL;
        case 256UL   : return 8UL;
        case 128UL   : return 7UL;
        case 64UL    : return 6UL;
        case 32UL    : return 5UL;
        case 16UL    : return 4UL;
        case 8UL     : return 3UL;
        case 4UL     : return 2UL;
        case 2UL     : return 1UL;
        case 1UL     : return 0UL;
        /* argument error */
        case 0UL     : return 0UL;
    }
}

/* Pivot selection: select_pivot (or some such name) */
#if __STDC_WANT_LIB_EXT1__
QUICKSELECT_SELECT_PIVOT_S
#else
QUICKSELECT_SELECT_PIVOT
#endif
{
    size_t karray[1], firsts, beyonds, nmemb=beyond-first;
    register size_t mid, n, o, q, r;
    register char *pa, *pb, *pc, *pivot, *pm;
    int method;
#if __STDC_WANT_LIB_EXT1__
    errno_t
#else
    int
#endif
        ret=0;

#if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(PIVOT_SELECTION_DEBUG))
        (V)fprintf(stderr,
            "/* %s line %d: nmemb=%lu, first=%lu, beyond=%lu, "
            "compar=%s, options=0x%x */\n",__func__,__LINE__,nmemb,first,beyond,
            comparator_name(compar),options);
#endif /* LIBMEDIAN_TEST_CODE */
    /* pivot selection method */
    method=
#if LIBMEDIAN_TEST_CODE
           d_pivot_method
#else
           pivot_method
#endif
                       (pk,nmemb,firstk,beyondk,distribution,size_ratio,options);
    /* determine number of samples (medians for median of medians) */
    n=
#if LIBMEDIAN_TEST_CODE
       d_samples
#else
       samples
#endif
             (nmemb,method,distribution,options);
    if ((QUICKSELECT_PIVOT_MEDIAN_OF_SAMPLES==method)&&(5UL>n)) {
        method=QUICKSELECT_PIVOT_REMEDIAN_SAMPLES; /* no offset 3 samples */
    }
    if (NULL!=pmethod) *pmethod=method;
    if (NULL!=psamples) *psamples=n;
    switch (method) {
        case QUICKSELECT_PIVOT_REMEDIAN_FULL :
        /*FALLTHROUGH*//* to remedian */
        case QUICKSELECT_PIVOT_REMEDIAN_SAMPLES :
            /* table index as a surrogate for division by 3 in remedian */
            r= floor_log3(n); /* table index */
            pivot=remedian_pivot_selection(base,first,beyond,size,
		#if __STDC_WANT_LIB_EXT1__
			    compar,context
		#else
			    compar
		#endif
			    ,
                swapf,alignsize,size_ratio,r,pk,cachesz,pbeyond,options,ppc,ppd,
                ppe,ppf,nmemb);
        break;
        case QUICKSELECT_PIVOT_MEDIAN_OF_MEDIANS :
#if LIBMEDIAN_TEST_CODE
            if (aqcmp==compar) {
                nfrozen=0UL, pivot_minrank=n;
                if (0UL==(n&0x01UL)) pivot_minrank++;
                /* freeze 1/2 of lowest and highest rows, forcing swaps of
                   medians to middle row. 1/2 of 2/3 = 1/3 elements. n=nmemb/3.
                   That will result in 1/2 of the medians being frozen, which
                   will partition all frozen elements in one region, giving the
                   worst-case 2:1 ratio for median-of-medians.  The small region
                   will have all frozen elements in two in-order runs, and the
                   large region will be all "gas".
                   Unmodified McIlroy adversary would freeze 2/3 of elements (in
                   sets of 3 for medians) resulting in an even split from
                   partitioning after median-of-medians, with one region nearly
                   sorted and the other with 1/3 of its elements frozen.
                */
            }
#endif /* LIBMEDIAN_TEST_CODE */
            A(NULL!=base);A(NULL!=compar);
            A(8UL<nmemb); /* at least 9 elements (3 sets of 3) */
            A(NULL!=ppc);A(NULL!=ppd);A(NULL!=ppe);A(NULL!=ppf);
            /* rearranges elements; precludes stable sort/selection */
            A(0U==(options&(QUICKSELECT_STABLE)));
            /* Finding a pivot with guaranteed intermediate rank. Ideally,
               median (50%).  Blum, Floyd, Pratt, Rivest, Tarjan
               median-of-medians using sets of 5 elements with recursion
               guarantees rank in (asymptotically) 30-70% range, often
               better; can guarantee linear median-finding, N log(N)
               sorting. Simplification ignores "leftover" elements with a
               slight increase in rank range.  Non-recursive method (using
               separate linear median finding) can use sets of 3 elements to
               provide a tighter 33.33% to 66.67% range (again, slightly
               wider if "leftover" elements are ignored) at lower
               computational cost.
            */
            pc=base+first*size;
            /* Medians of sets of 3 elements. */
            A(1UL<n); /* never repivot for nmemb<9 */
            /*3 element sets (columns); medians->first row, ignore leftovers*/
            for (o=0UL,r=n*size; o<r; o+=size) {
                pa=pc+o;
                pb=pa+r; /* middle element */
                A(pb+r<base+beyond*size);
                if (0U!=(options&(QUICKSELECT_INDIRECT))) {
#if LIBMEDIAN_TEST_CODE
                    if (aqcmp==compar) {
                        /* XXX not sure if indirection is needed here */
                        (V)freeze(aqindex(pa,base,size));
                        (V)freeze(aqindex(pb+r,base,size));
                    }
#endif /* LIBMEDIAN_TEST_CODE */
                    pm=
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                        d_fmed3_s
# else
                        d_fmed3
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                        fmed3_s
# else
                        fmed3
# endif
#endif
                        (*((char **)pb),*((char **)pa),
                        *((char **)(pb+r)),
	#if __STDC_WANT_LIB_EXT1__
			compar,context,
	#else
			compar,
	#endif
			options
#if LIBMEDIAN_TEST_CODE
                        , base, size
#endif
			);
                    /* medians start at 1/3 of sub-array */
                    /*compare returned data pointer,swap indirect pointers*/
                    if (pm!=*((char **)pa)) {
                        if (pm==*((char **)pb))
                            EXCHANGE_SWAP(swapf,pa,pb,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                        else
                            EXCHANGE_SWAP(swapf,pa,pb+r,size,alignsize,
                                size_ratio,SWAP_COUNT_STATEMENT);
                    }
                } else {
#if LIBMEDIAN_TEST_CODE
                    if (aqcmp==compar) {
                        (V)freeze(aqindex(pa,base,size));
                        (V)freeze(aqindex(pb+r,base,size));
                    }
#endif /* LIBMEDIAN_TEST_CODE */
                    if ((pa!=(pm=(char *)
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                        d_fmed3_s
# else
                        d_fmed3
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                        fmed3_s
# else
                        fmed3
# endif
#endif
                                       (pb,pa,pb+r,
                                       
			#if __STDC_WANT_LIB_EXT1__
					compar,context,
			#else
					compar,
			#endif
					options
#if LIBMEDIAN_TEST_CODE
                        , base, size
#endif
					))) /*bias to pa*/
                    ) { /* place medians in first row of sub-array */
                        EXCHANGE_SWAP(swapf,pm,pa,size,alignsize,size_ratio,
                            SWAP_COUNT_STATEMENT);
                    }
                }
            }
            *ppc=pc; /* first median */
            /* median of medians */
            karray[0]=first+(n>>1); /* upper-median for even size arrays */
            *ppf=*ppc+r; /* past last median */
# if ASSERT_CODE
            A((NULL!=ppd)&&(NULL!=ppe));
            *ppd=*ppe=NULL; /* clear to avoid random values */
# endif
            /* select median of medians; partitions medians */
            /* table_index may be higher, as the number of medians
               is about 1/3 of the number of samples; but the middle
               sampling table will be used for the median of medians; the
               current table_index is probably a good starting point
            */
            A(0==ret);
            ret=
#if LIBMEDIAN_TEST_CODE
# if  __STDC_WANT_LIB_EXT1__
                d_quickselect_loop_s
# else
                d_quickselect_loop
# endif
#else
# if  __STDC_WANT_LIB_EXT1__
                quickselect_loop_s
# else
                quickselect_loop
# endif
#endif
                (base,first,first+n,size,
		#if __STDC_WANT_LIB_EXT1__
			    compar,context
		#else
			    compar
		#endif
			    ,
                karray,0UL,1UL,swapf,alignsize,size_ratio,cachesz,pbeyond,
                options&(~(QUICKSELECT_RESTRICT_RANK)),ppd,ppe);
            A(0==ret);if(0!=ret) return NULL;
            pivot=base+karray[0]*size; /* pointer to median of medians */
            /* Left third of array (medians) is partitioned. */
#if ASSERT_CODE + DEBUG_CODE
            if ((*ppe<=pivot||(*ppd>pivot)))  {
                size_t d, e, l;
                l=(pivot-base)/size;
                if (NULL!=ppd) d=(*ppd-base)/size; else d=first;
                if (NULL!=ppe) e=(*ppe-base)/size; else e=beyond;
                (V)fprintf(stderr,
                    "/* %s line %d: nmemb=%lu, first=%lu, pivot=%p[%lu], ppd=%p, "
                    "*ppd=%p[%lu], ppe=%p, *ppe=%p[%lu], beyond=%lu, "
                    "options=0x%x */\n",
                    __func__,__LINE__,nmemb,first,(void *)pivot,l,
                    (void *)ppd,NULL!=ppd?(void *)(*ppd):NULL,d,
                    (void *)ppe,NULL!=ppe?(void *)(*ppe):NULL,e,
                    beyond,options);
                A((NULL!=ppd)&&(NULL!=ppe));
                A((NULL!=*ppd)&&(NULL!=*ppe));
#if LIBMEDIAN_TEST_CODE
                if (d<l) l=d;
                    print_some_array(base,l-1UL,l+1UL,"/* "," */",options);
                    print_some_array(base,d-1UL,d+1UL,"/* "," */",options);
                    print_some_array(base,e-1UL,e+1UL,"/* "," */",options);
# endif
            }
#endif
        break;
        case QUICKSELECT_PIVOT_MEDIAN_OF_SAMPLES :
            /* Moving samples (for median selection) saves recomparisons during
               partitioning but costs extra swaps.  In particular, if the input
               is already-sorted, the swaps introduce disorder, and the elements
               need to be swapped again during subsequent partitioning.  The
               extra swaps are especially expensive for large data elements
               (size_ratio>1).  Use this method for sorting only if
               QUICKSELECT_OPTIMIZE_COMPARISONS is specified, and/or only for
               small size_ratio.  For a small number of samples, the saving in
               comparisons is very small; avoid this method for sorting 3 or
               fewer samples.  However, for order statistic selection, this
               method can use a pivot at a position other than the sample
               median, which can provide an improvement in the reduction of the
               problem size.
            */
            /* upper-middle element is one of the samples */
            mid=first+(nmemb>>1); /* index of upper-middle element */

#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(PIVOT_SELECTION_DEBUG))
                (V)fprintf(stderr,
                    "/* %s line %d: nmemb=%lu, first=%lu, beyond=%lu, "
                    "compar=%s, options=0x%x, n=%lu, mid=%lu */\n",
                    __func__,__LINE__,nmemb,first,beyond,
                    comparator_name(compar),options,n,mid);
#endif /* LIBMEDIAN_TEST_CODE */
            if (nmemb<=n) {
                fprintf(stderr,"/* %s: line %d: first=%lu, beyond=%lu, "
                    "nmemb=%lu, n=%lu */\n",__func__,__LINE__,
                    first,beyond,nmemb,n);
                abort();
            }

            q = (n>>1); /* samples (elements) below/above middle */

            /* If selecting in base array (not sorting) and the
               distribution of desired order statistics is such that they
               are at one end of the sub-array, offset the desired rank
               of the samples to eliminate most of the sub-array.
            */
            if ((NULL!=pk)&&(beyondk>firstk)
            && (5U!=distribution) /* counterproductive e.g. 2 min.+2 max. */
            && (5UL<=n) /* cannot offset 1 or 3 samples */
            ) { /* maybe offset rank for selection */
                size_t t, u, v, w;
#if LIBMEDIAN_TEST_CODE
                if (DEBUGGING(PIVOT_SELECTION_DEBUG)
                || DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
                    fprintf(stderr,"/* %s line %d: nmemb=%lu, distribution=%d, "
                        "firstk=%lu, beyondk=%lu, mid=%lu, first=%lu, "
                        "beyond=%lu, pk[firstk]=%lu, pk[beyondk-1]=%lu */\n",
                        __func__,__LINE__,nmemb,distribution,firstk,beyondk,mid,
                        first,beyond,pk[firstk],pk[beyondk-1UL]);
                }
#endif
                /* position in sub-array of middle-most desired rank */
                switch (distribution) {
                    case 3U : /*FALLTHROUGH*/
                    case 1U :
                        /* left-most desired rank */
                        t=pk[firstk]-first;
                    break;
                    case 6U : /*FALLTHROUGH*/
                    case 4U :
                        /* right-most desired rank */
                        t=pk[beyondk-1UL]-first;
                    break;
                    default :
                        /* find rank nearest [upper-]median element */
                        for (t=pk[firstk],v=firstk+1UL; v<beyondk; v++)
                        {
                            w=pk[v];
                            if (w<mid) {
                                if (t<mid) {
                                    if (mid-w<mid-t) t=w;
                                } else {
                                    if (mid-w<t-mid) t=w;
                                }
                            } else {
                                if (t<mid) {
                                    if (w-mid<mid-t) t=w;
                                } else {
                                    if (w-mid<t-mid) t=w;
                                }
                            }
                        }
                        t-=first; /* relative to nmemb */
                    break;
                }
                /* u (fraction of nmemb for end distribution) should match
                   code in sampling_table (sampling_table_src.h)
                */
                u=(nmemb>>2); /* nmemb/4 */
                v=nmemb/n; /* see comments below re. overflow */
#if LIBMEDIAN_TEST_CODE
                if (DEBUGGING(PIVOT_SELECTION_DEBUG)
                || DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
                    fprintf(stderr,"/* %s line %d: distribution=%d, "
                        "firstk=%lu, beyondk=%lu, mid=%lu, first=%lu, "
                        "beyond=%lu, pk[firstk]=%lu, pk[beyondk-1]=%lu, "
                        "nmemb=%lu, q=%lu, t=%lu, u=%lu, v=%lu */\n",
                        __func__,__LINE__,distribution,firstk,beyondk,mid,
                        first,beyond,pk[firstk],pk[beyondk-1UL],nmemb,q,
                        t,u,v);
                }
#endif
                /* Sibeyn, in "External Selection", gives an offset of
                   sqrt(n/4*log2(nmemb)).  A disadvantage of Sibeyn's offset
                   for small nmemb is that the problem size reduction is
                   tiny for ranks near the median, because the offset
                   approaches n/2. E.g. for nmemb=32, n=5 samples, the
                   offset is n/2 if computed exactly (with integer
                   arithmetic and using the floor of log2 and sqrt, it's
                   still too big for practical use).  An approximation
                   avoiding tiny problem size reduction is used for small
                   nmemb (and therefore small n), and Sibeyn's offset is
                   computed for large nmemb.
                */
                /* Offset is not applied for distributions 0, 2, 5, or 7 */
                switch (distribution) {
                    case 1 : /*FALLTHROUGH*/ case 3: /*FALLTHROUGH*/
                    case 4 : /*FALLTHROUGH*/ case 6: /*FALLTHROUGH*/
                        if (8UL>n) {
                            o=1UL;
                        } else if (22UL>n) {
                            o=1UL+(q>>1); /* 1+n/4 */
                        } else {
                            o=1UL+
#if LIBMEDIAN_TEST_CODE
                            d_size_t_sqrt
#else
                            size_t_sqrt
#endif
                            ((q>>1)*floor_log2(nmemb)); /* Sibeyn delta/2 */
                        }
                    break;
                }
                if ((t<=u)||(t>=(nmemb-u))) { /* <= 1/4|| >= 3/4 */
                    /* Middle-most desired rank is near one end of the
                       sub-array: choose a pivot conservatively (farther from
                       the end of the samples) to reduce the chance of having a
                       desired rank in the large region after partitioning
                       (which would greatly increase the cost of selection by
                       not reducing the problem size).  Distribution is 1 (001)
                       or 4 (100).
                    */
                    /* Contortions to avoid overflow:
                       Desired relative rank in samples will become
                       variable u, want u/n ~ 2*t/nmemb if the desired
                       rank is away from the middle (i.e. distributions
                       1 or 4) (so that the rank of desired base array
                       rank closest to the base array median will be
                       expected to be near the median of the partitioned
                       region containing the desired ranks; ideally none
                       of the desired ranks will be in the large region
                       resulting from the partition).  So u~2*n*t/nmemb.
                       But n ~ sqrt(nmemb) and t is in [0,nmemb/4] (or
                       in [3*nmemb/4,nmemb-1]) so n*t might overflow.
                       And because n<nmemb and t<nmemb, n/nmemb and
                       t/nmemb are both always 0 in integer arithmetic.
                       Conversely, nmemb/n is in [2*sqrt(nmemb),nmemb]
                       (n>=1).  Overflow is avoided by setting temporary
                       variable v to nmemb/n, and u ~ 2*t/v.
                       Example: nmemb=16Mi, n=2ki, t=2Mi (nmemb/8)
                       v=nmemb/n=8ki and u = 2*t/v = 4Mi/8ki = 512
                       512/2ki is about 1/4 relative rank of samples
                       so t is expected to fall around the median of
                       the approximately 1/4 of nmemb (1/4*16Mi=4Mi)
                       in the small region resulting from the
                       partition.
                       For distributions 3 and 6, the pivot may be near the
                       middle of the sub-array; rather than multiplying
                       the relative rank by 2, the relative rank should
                       be offset somewhat away from the desired ranks to
                       give a greater probability of having all of the
                       desired ranks in one region.
                       Use Sibeyn's offset if it would provide a greater problem
                       size reduction than doubling the rank proportion.
                    */
                    if (t<=u) {
                        if (o*v<=(t<<1))
                            u=t/v+o;
                        else
                            u=(t<<1)/v; /* 2x proportion */
                        if (1UL>u) u++; /* avoid extreme value */
                        else if (u>q) u=q;
                        /* Desired rank is below median; partition is expected
                           to have more elements in the > region.  Put the
                           samples at the right end of the array so that the
                           smaller < region of samples is moved prior to
                           partitioning.
                        */
                        beyonds=beyond, firsts=beyond-n;
                    } else {
                        /* In this case, t is in [3*nmemb/4,nmemb),
                           so 2*t might overflow for large nmemb.
                           Use nmemb-t, which is in [1,nmemb/4].
                           Example: nmemb=16Mi, n=2ki, t=14Mi (7/8)
                           v=8ki, nmemb-t=2Mi, u=n-1-2*2Mi/v=2ki-1-512
                        */
                        u=nmemb-t;
                        if (o*v<=(u<<1))
                            w=u/v+o;
                        else
                            w=(u<<1)/v; /* 2x proportion */
                        if (1UL>w) w++; /* avoid extreme value */
                        u=n-1UL-w;
                        if (u<q) u=q;
                        /* Desired rank is above median; partition is expected
                           to have more elements in the < region.  Put the
                           samples at the left end of the array so that the
                           smaller > region of samples is moved prior to
                           partitioning.
                        */
                        firsts=first, beyonds=firsts+n ;
                    }
                } else { /* somewhere near middle */
                    u=q;
                    /* Middle-most desired rank is near the median of
                       the base sub-array.  Try for relative rank
                       (proportion) in samples close to relative rank in
                       base array.  If the pivot turns out to be one of
                       the desired ranks, the problem size is directly
                       reduced.  Otherwise, the problem will be split
                       with a desired rank near one end of one region
                       for the next iteration.  Want u/n ~ t/nmemb,
                       v=nmemb/n and u=t/v (see comments in the above
                       section regaing overflow).  For distributions 3
                       (011) and 6 (110) with the middle-most rank an
                       extreme rank, offset the sample rank slightly to
                       increase the chance of keeping all of the desired
                       ranks in one partitioned region; no such
                       additional offset for distributions 5 (101) or 7
                       (111), which will have desired ranks in both
                       regions, or for distribution 2 (010).
                       Use Sibeyn's offset if the mid-most rank is on the same
                       side of the middle as most of the desired ranks,
                       otherwise only if the problem size reduction would not
                       be tiny (if it would be tiny, use no offset).
                    */
                    if (o>(q>>2)) o=0UL; /* offset too large */
                    if (t<mid-first) { /* below middle */
                        u=t/v;
                        if (6U==distribution)
                            u+=o;
                        else if (3U==distribution)
                            u-=o;
                        /* Desired rank is below median; partition is expected
                           to have more elements in the > region.  Put the
                           samples at the right end of the array so that the
                           smaller < region of samples is moved prior to
                           partitioning.
                        */
                        beyonds=beyond, firsts=beyond-n;
                    } else { /* at or above middle */
                        w=(nmemb-t)/v;
                        if (3U==distribution)
                            w+=o;
                        else if (6U==distribution)
                            w-=o;
                        if (1UL>w) w++; /* avoid extreme value */
                        if (w>=n) u=0UL; else u=n-1UL-w;
                        /* Desired rank is above median; partition is expected
                           to have more elements in the < region.  Put the
                           samples at the left end of the array so that the
                           smaller > region of samples is moved prior to
                           partitioning.
                        */
                        firsts=first, beyonds=firsts+n ;
                    }
                    if (1UL>u) u++; /* avoid extreme value */
                }
                karray[0]=firsts+u;
#if LIBMEDIAN_TEST_CODE
                if (aqcmp==compar) nfrozen=0UL, pivot_minrank=nmemb-u;
#endif
            } else {
                firsts=first, beyonds=first+n;
                karray[0]=firsts+q;
#if LIBMEDIAN_TEST_CODE
                if (aqcmp==compar) nfrozen=0UL, pivot_minrank=nmemb-q;
#endif
            }
#if LIBMEDIAN_TEST_CODE
            /* pivot rank sanity check */
            if ((karray[0]<firsts)||(karray[0]>=beyonds)) {
                (V)fprintf(stderr,"/* %s line %d: distribution=%d,"
                    " firstk=%lu, beyondk=%lu, mid=%lu, "
                    "first=%lu, beyond=%lu, pk[firstk]=%lu, pk["
                    "beyondk-1]=%lu, nmemb=%lu, n=%lu, q=%lu, "
                    "firsts=%lu, beyonds=%lu, karray[0]=%lu */\n",
                    __func__,__LINE__,distribution,firstk,beyondk,mid,
                    first,beyond,pk[firstk],pk[beyondk-1UL],nmemb,n,
                    q,firsts,beyonds,karray[0]);
                abort();
            }
#endif
            pivot=base+karray[0]*size;

            /* limits of region occupied by samples */
            *ppc=base+firsts*size, *ppf=base+beyonds*size;

            /* move samples to one end for selection */
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
                (V)fprintf(stderr,"/* %s line %d: first=%lu, beyond=%lu, "
                    "nmemb=%lu, n(samples)=%lu, firsts=%lu, mid=%lu, "
                    "beyonds=%lu, karray[0]=%lu */\n",__func__,__LINE__,
                    first,beyond,nmemb,n,firsts,mid,beyonds),karray[0];
            }
#endif
            /* sample spacing */
            o = size*(nmemb/n); /* char spacing for samples */
            pm=base+mid*size; /* [upper-]middle element */

            /* First sample is at pm-q*o; last sample is at pm+q*o */
            if (firsts==first) { /* samples at left end of array */
                for (pc=base+firsts*size,pa=pm-q*o,pb=pm+q*o; pa<=pb;
                pa+=o,pc+=size
                ) {
                    if (pa!=pc) {
#if LIBMEDIAN_TEST_CODE
                        if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
                            fprintf(stderr,"/* %s: line %d: sample@%lu, moved to "
                                "%lu */\n",__func__,__LINE__,(pa-base)/size,
                                (pc-base)/size);
                        }
#endif
                        EXCHANGE_SWAP(swapf,pa,pc,size,alignsize,size_ratio,
                            SWAP_COUNT_STATEMENT);
                    }
                }
            } else { /* samples at right end of array */
                for (pc=base+(beyonds-1UL)*size,pa=pm-q*o,pb=pm+q*o; pa<=pb;
                pb-=o,pc-=size
                ) {
                    if (pb!=pc) {
#if LIBMEDIAN_TEST_CODE
                        if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
                            fprintf(stderr,"/* %s: line %d: sample@%lu, moved to "
                                "%lu */\n",__func__,__LINE__,(pb-base)/size,
                                (pc-base)/size);
                        }
#endif /* DEBUGGING */
                        EXCHANGE_SWAP(swapf,pb,pc,size,alignsize,size_ratio,
                            SWAP_COUNT_STATEMENT);
                    }
                }
            }
#if LIBMEDIAN_TEST_CODE
            if (aqcmp==compar) { /* adversary */
                for (pa=base+firsts*size,pb=base+beyonds*size; pa<pb; pa+=size) {
                        (V)freeze(aqindex(pa,base,size));
                    if (pa==pivot) break;
                }
            }
#endif /* DEBUGGING */

# if ASSERT_CODE
            A((NULL!=ppd)&&(NULL!=ppe));
            *ppd=*ppe=NULL; /* clear to avoid random values */
# endif
            /* select median (or other rank) of samples; partitions samples */
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(PIVOT_SELECTION_DEBUG)
            || DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
                fprintf(stderr,"/* %s line %d: nmemb=%lu (samples moved, before "
                    "selection): *ppc@%lu, r(mid)=%lu, *ppf@%lu, q=%lu, "
                    "karray[0]=%lu */\n",
                    __func__,__LINE__,nmemb,((*ppc)-base)/size,r,
                    ((*ppf)-base)/size,q,karray[0]);
            }
#endif
            A(0==ret);
            ret=
#if LIBMEDIAN_TEST_CODE
# if  __STDC_WANT_LIB_EXT1__
                d_quickselect_loop_s
# else
                d_quickselect_loop
# endif
#else
# if  __STDC_WANT_LIB_EXT1__
                quickselect_loop_s
# else
                quickselect_loop
# endif
#endif
                (base,firsts,beyonds,size,
		#if __STDC_WANT_LIB_EXT1__
			    compar,context
		#else
			    compar
		#endif
			    ,karray,
                0UL,1UL,swapf,alignsize,size_ratio,cachesz,pbeyond,
                options&(~(QUICKSELECT_RESTRICT_RANK)),ppd,ppe);
            A(0==ret);if(0!=ret) return NULL;
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(PIVOT_SELECTION_DEBUG)
            || DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
                (V)fprintf(stderr,"/* %s: line %d: nmemb=%lu (after selecting "
                    "pivot from samples): *ppd@%lu, firsts=%lu, mid=%lu, "
                    "beyonds=%lu, *ppe@%lu, karray[0]=%lu */\n",
                    __func__,__LINE__,nmemb,(*ppd-base)/size,firsts,mid,beyonds,
                    (*ppe-base)/size,karray[0]);
                print_some_array(base,first,beyond-1UL,"/* "," */",options);
            }
#endif

            /* Samples are partitioned. */
#if ASSERT_CODE + DEBUG_CODE
            if ((*ppe<=pivot||(*ppd>pivot)))  {
                size_t d, e, l;
                l=(pivot-base)/size;
                if (NULL!=ppd) d=(*ppd-base)/size; else d=first;
                if (NULL!=ppe) e=(*ppe-base)/size; else e=beyond;
                (V)fprintf(stderr,
                    "/* %s line %d: nmemb=%lu, first=%lu, pivot=%p[%lu], ppd=%p, "
                    "*ppd=%p[%lu], ppe=%p, *ppe=%p[%lu], beyond=%lu, "
                    "options=0x%x */\n",
                    __func__,__LINE__,nmemb,first,(void *)pivot,l,
                    (void *)ppd,NULL!=ppd?(void *)(*ppd):NULL,d,
                    (void *)ppe,NULL!=ppe?(void *)(*ppe):NULL,e,
                    beyond,options);
                A((NULL!=ppd)&&(NULL!=ppe));
                A((NULL!=*ppd)&&(NULL!=*ppe));
#if LIBMEDIAN_TEST_CODE
                if (d<l) l=d;
                    print_some_array(base,l-1UL,l+1UL,"/* "," */",options);
                    print_some_array(base,d-1UL,d+1UL,"/* "," */",options);
                    print_some_array(base,e-1UL,e+1UL,"/* "," */",options);
# endif
            }
#endif
        break;
    }
    A(NULL!=pivot);A(base+first*size<=pivot);A(pivot<base+beyond*size);
#if ASSERT_CODE + DEBUG_CODE
    if ((*ppe<=pivot||(*ppd>pivot)))  {
        size_t d, e, l;
        l=(pivot-base)/size;
        if (NULL!=ppd) d=(*ppd-base)/size; else d=first;
        if (NULL!=ppe) e=(*ppe-base)/size; else e=beyond;
        (V)fprintf(stderr,
            "/* %s line %d: nmemb=%lu, first=%lu, pivot=%p[%lu], ppd=%p, *ppd=%p[%lu], "
            "ppe=%p, *ppe=%p[%lu], beyond=%lu, options=0x%x */\n",
            __func__,__LINE__,nmemb,first,(void *)pivot,l,
            (void *)ppd,NULL!=ppd?(void *)(*ppd):NULL,d,
            (void *)ppe,NULL!=ppe?(void *)(*ppe):NULL,e,
            beyond,options);
#if LIBMEDIAN_TEST_CODE
        if (d<l) l=d;
        if (e<first+nmemb) e++;
        print_some_array(base,l,e-1UL,"/* "," */",options);
# endif
    }
#endif
    A(*ppd<=pivot);A(pivot<*ppe);A(*ppc<=*ppd);A(*ppe<=*ppf);
    return pivot;
}
