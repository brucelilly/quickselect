/*INDENT OFF*/

/* Description: C source code for select_pivot */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    pivot_src.h copyright 2017-2018 Bruce Lilly.   \ pivot_src.h $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is pivot_src.h version 1.13 dated 2018-03-20T19:31:20Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/include/s.pivot_src.h */

/********************** Long description and rationale: ***********************
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.
 Partitioning can still result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
******************************************************************************/

/* Minimum _XOPEN_SOURCE version for C99 (else illumos compilation fails) */
#undef MAX_XOPEN_SOURCE_VERSION
#undef MIN_XOPEN_SOURCE_VERSION
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# define MIN_XOPEN_SOURCE_VERSION 600 /* >=600 for illumos */
#else
# define MAX_XOPEN_SOURCE_VERSION 500 /* <=500 for illumos */
#endif

/* feature test macros defined before any header files are included */
#ifndef _XOPEN_SOURCE
# ifdef MIN_XOPEN_SOURCE_VERSION
#  define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
# else
#  ifdef MAX_XOPEN_SOURCE_VERSION
#   define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#  endif
# endif
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MIN_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE < MIN_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MAX_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE > MAX_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#endif

#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
   ID_STRING_PREFIX is suitable for the what(1) and ident(1) utilities.
   MODULE_DATE uses modern SCCS extensions.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: pivot_src.h ~|^` @(#)"
#define SOURCE_MODULE "pivot_src.h"
#define MODULE_VERSION "1.13"
#define MODULE_DATE "2018-03-20T19:31:20Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
#define COPYRIGHT_DATE "2017-2018"

/* local header files needed */
#include "exchange.h"           /* EXCHANGE_SWAP */
#include "quickselect_config.h" /* QUICKSELECT_INLINE */
#include "tables.h"             /* sampling_table_struct SAMPLING_TABLE_SIZE */
#if ! QUICKSELECT_BUILD_FOR_SPEED
#include "initialize_src.h"
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* system header files */
#include <assert.h>             /* assert */
#include <errno.h>              /* errno E* (maybe errno_t [N1570 K3.2]) */
#include <stddef.h>             /* size_t NULL (maybe rsize_t) */
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# if __STDC_VERSION__ >= 201001L
    /* [N1570 6.10.8.1] (minimum value: y=0,mm=01) */
#  include <stdio.h>            /* (maybe errno_t rsize_t [N1570 K3.5]) */
#  include <stdlib.h>           /* (maybe errno_t rsize_t constraint_handler_t
                                   [N1570 K3.6]) */
# endif /* N1570 */
#endif /* C99 or later */

#if __STDC_WANT_LIB_EXT1__
/* Preliminary support for 9899:201x draft N1570 qsort_s w/ "context".
   "context" is similar to glibc qsort_r; N1570 also has provision for
   runtime-constraint violation detection and handling. "Preliminary"
   because of the apparent lack of a convincing use-case for "context" and
   due to the poorly defined semantics and interface for constraint
   violation handling.

   Consequences of "context" are wide-ranging: any operation that requires
   comparisons (pivot selection, partitioning, dedicated sorting and/or
   selection, and support functions for any of those) has to be rewritten.
   The only operations unaffected are sampling, basic swaps, blockmoves using
   swaps, rank comparisons, and partition size evaluation; sampling and
   repivoting tables may also be reused without change.
   Executable code size is roughly doubled, not including external
   constraint-handler function code.
   Use case of "context" is questionable; one could simply use an appropriate
   comparison function.  Published supposed examples (e.g.
   https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/qsort-s
   tend to be rather silly (in the specific example above:
      1. functions are defined for specific locales, but not specifically
         implementing locale-specific collation -- one could at least as easily
         define locale-specific string comparison functions using the standard
         strcoll [+] function and use these with qsort to perform the
         locale-specific sorts with no need for "context", and avoiding the
         other implementation issues detailed below.
      2. Aside from inconsistent "context" argument order...
      3. ... the implementation comparison function copies (!) (leading portions
         of) supplied strings to fixed size (!!)[*] local buffers, then makes a
         second set of passes (!!!) over the copies to perform a conversion
         (which is discarded (!!!!) when the comparison function returns), which
         is then subjected to a third (!!!!!) pass to perform the comparison.
         Note that qsort implementations typically call the comparison function
         N log N times for an array of N elements; the above implementation
         makes 2 N log N copies and 6 N log N passes over data representing
         the strings to be sorted.  In particular, at each stage of partitioning
         qsort implementations compare a pivot element to many other elements;
         in the above implementation the string corresponding to that pivot
         element is copied, the copy modified and examined, only to be discarded
         before repeating those steps anew with the same pivot element's string
         for the next comparison.
      4. Although the copies (see #3 above) ignore the actual length of the
         original strings, strlen is subsequently called for each string (copy),
         resulting in a fourth (!!!!!!) pass over the data. Had strlen been
         called for the initial strings, the copies could have been made
         appropriate sizes (assuming that one still naively wished to make, then
         discard such copies).
      * a possibly-valid use of "context" *might* be to provide the maximum
        string length, avoiding magic numbers and failure to fully compare
        strings which have long identical leading substrings... *if* one
        insisted on the naive implementation involving copies (which are
        subsequently discarded) and multiple passes over the data.  It would
        be much more efficient to make one-time initial transformations (e.g.
        w/ strxfrm [+]) of the original string data supplemented by an index
        indicating the original order (or a pointer to the original string
        data), sorting the transformed and supplemented data using standard
        strcmp on the transformed strings.  That would involve N combined
        transformations and copies (instead of N log N copies and N log N
        transformations) plus N log N standard strcmp string comparisons (rather
        than 6 N log N passes over data), followed by access of the orginal
        string data via the indices or pointers for output.
      + Note that strcoll and strxfrm have been standardized since C89 (a.k.a.
        C90).
   ). In summary, there is no convincing use-case for "context" to justify
   doubling the size of library code.
*/
#endif /* __STDC_WANT_LIB_EXT1__ */

/* fmed3 is called by remedian and select_pivot; remedian is also called by
   select_pivot. select_pivot is called by quickselect_loop[_s], introsort,
   mbmqsort, sqsort, wqsort.
*/
/* Median of sets of 3 elements:
   Optimized ternary median-of-3: 1-3 comparisons.
   Minimum number of comparisons (because in the qsort model (external function
   for comparison), comparisons are expensive).  If any two elements (of the 3)
   compare equal, either can be chosen for the median (the value is the median
   of the 3, regardless of the value of the third element).  Likewise, the
   median may be determined by the first two comparisons, e.g. a < b and b < c.
   In the worst case, 3 comparisons are required.  Return value is biased to pb,
   then pa.  The function does not modify the pointers or the data array
   elements to which they point.  However, they are not declared with the
   "const" qualifier as that would inevitably lead to a cacsade of spurious
   "discarding const qualifier" warnings (or worse, spurious "errors"). Median
   of 3 is used for pivot selection, and the pivot element (as well as other
   elements) are rearranged, and that rearrangement precludes "const" as the
   element pointed to has its data replaced (usually swapped with) data from
   another element.
*/
static QUICKSELECT_INLINE
char * FMED3_FUNCTION_NAME (char *pa, char *pb, char *pc, COMPAR_DECL)
{
    register int c;
#if ((DEBUG_CODE)>0) && defined(DEBUGGING)
    if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
        (V)fprintf(stderr, "/* %s: pa=%p, pb=%p, pc=%p */\n",
        __func__,(void *)pa,(void *)pb,(void *)pc);
    }
#endif
    c=COMPAR(pa,pb);
    if (0!=c) {
        register int d=COMPAR(pb,pc);
        if (0!=d) {
            if ((0<d)&&(0>c)) {
                if (0>COMPAR(pa,pc)) return pc; else return pa;
            } else if ((0>d)&&(0<c)) {
                if (0<COMPAR(pa,pc)) return pc; else return pa;
            }
        }
    }
#if ((DEBUG_CODE)>0) && defined(DEBUGGING)
    if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(MEDIAN_DEBUG)) {
        (V)fprintf(stderr, "/* %s: pb=%p */\n",
        __func__,(void *)pb);
    }
#endif
    return pb;
}

/* Remedian (base 3) of samples, recursive implementation.
   The function does not modify the value pointed to by middle, but it is not
   declared as const to avoid spurious compiler warnings about discarding the
   const qualifier when passing middle to fmed3 (which also doesn't make
   modifications, but see the rationale there)

   Row and sample spacings are in elements.
   The variable idx is the index into the sampling table (with number of samples
      equal to the idx'th power of 3), which provides an inexpensive way of
      determining when to end the recursion
   Uniform sample spacing is maintained, recursively.
*/
static QUICKSELECT_INLINE
char *REMEDIAN_FUNCTION_NAME(char *middle, size_t row_spacing,
    register size_t sample_spacing, register size_t size,
    register unsigned int idx, COMPAR_DECL, unsigned int options)
{
    register char *pa, *pb, *pc;
    register size_t o;
#if (DEBUG_CODE > 0) && defined(DEBUGGING)
    if (DEBUGGING(REMEDIAN_DEBUG)) {
        (V)fprintf(stderr,"/* %s: middle=%p, row_spacing=%lu, sample_spacing="
            "%lu, idx=%u */\n",__func__,(void *)middle,
            (unsigned long)row_spacing,(unsigned long)sample_spacing,idx);
    }
#endif
    A((SAMPLING_TABLE_SIZE)>idx);
    if (0U < --idx) {
        register size_t s=sample_spacing/3UL;

        o=s*size;
        pa=REMEDIAN_FUNCTION_NAME(middle-o,row_spacing,s,size,idx,COMPAR_ARGS,
            options);
        pb=REMEDIAN_FUNCTION_NAME(middle,row_spacing,s,size,idx,COMPAR_ARGS,
            options);
        pc=REMEDIAN_FUNCTION_NAME(middle+o,row_spacing,s,size,idx,COMPAR_ARGS,
            options);
        if (0U!=(options&(QUICKSELECT_INDIRECT))) {
            char *pr= FMED3_FUNCTION_NAME(*((char **)pa),
                *((char **)pb), *((char **)pc),COMPAR_ARGS);
            if (pr==*((char **)pa)) return pa;
            if (pr==*((char **)pc)) return pc;
            return pb;
        } else
            return FMED3_FUNCTION_NAME(pa,pb,pc,COMPAR_ARGS);
    }
    o=row_spacing*size;
    if (0U!=(options&(QUICKSELECT_INDIRECT))) {
        char *pr;
        pa=middle-o, pc=middle+o;
        pr = FMED3_FUNCTION_NAME(*((char **)pa),*((char **)middle),
            *((char **)pc),COMPAR_ARGS);
        if (pr==*((char **)pa)) return pa;
        if (pr==*((char **)pc)) return pc;
        return middle;
    } else
        return FMED3_FUNCTION_NAME(middle-o,middle,middle+o,COMPAR_ARGS);
}

/* quickselect_loop declaration */
#if ! defined(QUICKSELECT_LOOP_DECLARED)
QUICKSELECT_EXTERN
# include "quickselect_loop_decl.h"
;
# define QUICKSELECT_LOOP_DECLARED 1
#endif /* QUICKSELECT_LOOP_DECLARED */

/* Pivot selection: select_pivot (or some such name) */
static QUICKSELECT_INLINE
char * SELECT_PIVOT_FUNCTION_NAME (char *base, size_t first, size_t beyond,
    size_t size, COMPAR_DECL, void (*swapf)(char *, char *, size_t),
    size_t alignsize, size_t size_ratio, unsigned int table_index,
    const size_t *pk, size_t cachesz, size_t pbeyond, unsigned int options,
    char **ppc, char **ppd, char **ppe, char **ppf)
{
    size_t nmemb=beyond-first;
    register size_t n, r=nmemb/3UL;     /* 1/3 #elements */
    register char *pivot;

    A((SAMPLING_TABLE_SIZE)>table_index);
    switch (options&((QUICKSELECT_STABLE)|(QUICKSELECT_RESTRICT_RANK))) {
#if QUICKSELECT_STABLE
        case ((QUICKSELECT_RESTRICT_RANK)|(QUICKSELECT_STABLE)) :
            /* almost full remedian */
            while (table_index<(SAMPLING_TABLE_SIZE)-1U) {
                n=sorting_sampling_table[table_index].samples;
                if (n>r) break;
                table_index++;
            }
            while ((n=sorting_sampling_table[table_index].samples)>r)
                table_index--;
            if (table_index==(SAMPLING_TABLE_SIZE)-1U) {
                for (; n<r; table_index++)
                    n*=3UL;
                if (n>r) table_index--;
            }
        /*FALLTHROUGH*/
#endif
        default:
            /*Fast pivot selection:1 sample, median-of-3, remedian of samples.*/
            pivot=base+size*(first+(nmemb>>1));     /* [upper-]middle element */
            if (0U<table_index) {       /* 3 or more samples */
                A(base+first*size<=pivot);A(pivot<base+beyond*size);
                pivot=REMEDIAN_FUNCTION_NAME(pivot,r,r,size,table_index,
                    COMPAR_ARGS,options);
            }
#if DEBUG_CODE + ASSERT_CODE
            else { /* should never use a single sample! */
                (V)fprintf(stderr,
                    "/* %s: %lu sample%s: nmemb=%lu, pivot=%p[%lu], pl=%p"
                    ", pu=%p, table_index=%u, pk=%p, options=0x%x */\n",
                    __func__,sorting_sampling_table[table_index].samples,
                    sorting_sampling_table[table_index].samples==1UL?"":"s",
                    nmemb,(void *)pivot,(pivot-base)/size,
                    (void *)(base+first*size),(void *)(base+beyond*size),
                    table_index,(const void *)pk,options);
# if defined(DEBUGGING)
                    print_some_array(base,first,beyond-1UL, "/* "," */",
                        options);
# endif
                A(0U<table_index);
            }
#endif
            *ppc=*ppd=pivot, *ppe=*ppf=pivot+size;
        break;
        case (QUICKSELECT_RESTRICT_RANK) :
            {   size_t karray[1];
                register size_t o;
                register char *pa, *pb, *pc, *pm;
#if __STDC_WANT_LIB_EXT1__
                errno_t ret=0;
#endif /* __STDC_WANT_LIB_EXT1__ */

                A(NULL!=base);A(NULL!=compar);
                A(8UL<nmemb); /* at least 9 elements (3 sets of 3) */
                A((SAMPLING_TABLE_SIZE)>table_index);
                A(NULL!=ppc);A(NULL!=ppd);A(NULL!=ppe);A(NULL!=ppf);
                /* rearranges elements; precludes stable sort/selection */
                A(0U==(options&(QUICKSELECT_STABLE)));
                /* Finding a pivot with guaranteed intermediate rank. Ideally,
                   median (50%).  Blum, Floyd, Pratt, Rivest, Tarjan
                   median-of-medians using sets of 5 elements with recursion
                   guarantees rank in (asymptotically) 30-70% range, often
                   better; can guarantee linear median-finding, N log(N)
                   sorting. Simplification ignores "leftover" elements with a
                   slight increase in rank range.  Non-recursive method (using
                   separate linear median finding) can use sets of 3 elements to
                   provide a tighter 33.33% to 66.67% range (again, slightly
                   wider if "leftover" elements are ignored) at lower
                   computational cost.
                */
                pc=base+first*size;
                /* Medians of sets of 3 elements. */
                A(1UL<r); /* never repivot for nmemb<9 */
                /*3 element sets (columns); medians->1st row, ignore leftovers*/
                for (o=0UL,n=r*size; o<n; o+=size) {
                    pa=pc+o;
                    pb=pa+n; /* middle element */
                    A(pb+n<base+beyond*size);
                    if (0U!=(options&(QUICKSELECT_INDIRECT))) {
                        pm=FMED3_FUNCTION_NAME(*((char **)pb),*((char **)pa),
                            *((char **)(pb+n)),COMPAR_ARGS);
                        /*medians at start of sub-array*/
                        /*compare returned data pointer,swap indirect pointers*/
                        if (pm!=*((char **)pa)) {
                            if (pm==*((char **)pb))
                                EXCHANGE_SWAP(swapf,pa,pb,size,alignsize,
                                    size_ratio,SWAP_COUNT_STATEMENT);
                            else
                                EXCHANGE_SWAP(swapf,pa,pb+n,size,alignsize,
                                    size_ratio,SWAP_COUNT_STATEMENT);
                        }
                    } else
                    if ((pa!=(pm=(char *)FMED3_FUNCTION_NAME(pb,pa,pb+n,
                                           COMPAR_ARGS))) /*bias to pa*/
                    ) { /* place medians at start of sub-array */
                        EXCHANGE_SWAP(swapf,pm,pa,size,alignsize,size_ratio,
                            SWAP_COUNT_STATEMENT);
                    }
                }
                *ppc=pc; /* first median */
                /* median of medians */
                karray[0]=first+(r>>1); /* upper-median for even size arrays */
                beyond=first+r; /* past last median */
                A(first<=karray[0]);A(karray[0]<beyond);
                *ppf=base+beyond*size; /* past last median */
# if ASSERT_CODE
                A((NULL!=ppd)&&(NULL!=ppe));
                *ppd=*ppe=NULL; /* clear to avoid random values */
# endif
                /* select median of medians; partitions medians */
#if __STDC_WANT_LIB_EXT1__
                A(0==ret);ret=
#endif
                /* table_index may be higher, as the number of medians
                   is about 1/3 of the number of samples; but the middle
                   sampling table will be used for the median of medians; the
                   current table_index is probably a good starting point
                */
                QUICKSELECT_LOOP(base,first,beyond,size,COMPAR_ARGS,
                    karray,0UL,1UL,swapf,alignsize,size_ratio,table_index,
                    cachesz,pbeyond,options&(~(QUICKSELECT_RESTRICT_RANK)),ppd,ppe);
#if __STDC_WANT_LIB_EXT1__
                A(0==ret);if(0!=ret) return NULL;
#endif
                pivot=base+karray[0]*size; /* pointer to median of medians */
                /* First third of array (medians) is partitioned. */
#if ASSERT_CODE + DEBUG_CODE
                if ((*ppe<=pivot||(*ppd>pivot)))  {
                    size_t d, e, l;
                    l=(pivot-base)/size;
                    if (NULL!=ppd) d=(*ppd-base)/size; else d=first;
                    if (NULL!=ppe) e=(*ppe-base)/size; else e=beyond;
                    (V)fprintf(stderr,
                        "/* %s: nmemb=%lu, first=%lu, pivot=%p[%lu], ppd=%p, "
                        "*ppd=%p[%lu], ppe=%p, *ppe=%p[%lu], beyond=%lu, "
                        "options=0x%x */\n",
                        __func__,nmemb,first,(void *)pivot,l,
                        (void *)ppd,NULL!=ppd?(void *)(*ppd):NULL,d,
                        (void *)ppe,NULL!=ppe?(void *)(*ppe):NULL,e,
                        beyond,options);
                    A((NULL!=ppd)&&(NULL!=ppe));
                    A((NULL!=*ppd)&&(NULL!=*ppe));
# if defined(DEBUGGING)
                    if (d<l) l=d;
                        print_some_array(base,l-1UL,l+1UL,"/* "," */",options);
                        print_some_array(base,d-1UL,d+1UL,"/* "," */",options);
                        print_some_array(base,e-1UL,e+1UL,"/* "," */",options);
# endif
                }
#endif
            }
        break;
    }
    A(NULL!=pivot);A(base+first*size<=pivot);A(pivot<base+beyond*size);
#if ASSERT_CODE + DEBUG_CODE
    if ((*ppe<=pivot||(*ppd>pivot)))  {
        size_t d, e, l;
        l=(pivot-base)/size;
        if (NULL!=ppd) d=(*ppd-base)/size; else d=first;
        if (NULL!=ppe) e=(*ppe-base)/size; else e=beyond;
        (V)fprintf(stderr,
            "/* %s: nmemb=%lu, first=%lu, pivot=%p[%lu], ppd=%p, *ppd=%p[%lu], "
            "ppe=%p, *ppe=%p[%lu], beyond=%lu, options=0x%x */\n",
            __func__,nmemb,first,(void *)pivot,l,
            (void *)ppd,NULL!=ppd?(void *)(*ppd):NULL,d,
            (void *)ppe,NULL!=ppe?(void *)(*ppe):NULL,e,
            beyond,options);
# if defined(DEBUGGING)
        if (d<l) l=d;
        if (e<first+nmemb) e++;
        print_some_array(base,l,e-1UL,"/* "," */",options);
# endif
    }
#endif
    A(*ppd<=pivot);A(pivot<*ppe);A(*ppc<=*ppd);A(*ppe<=*ppf);
    return pivot;
}
