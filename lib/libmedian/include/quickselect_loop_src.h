#ifndef QUICKSELECT_LOOP_SRC_H_INCLUDED
# define QUICKSELECT_LOOP_SRC_H_INCLUDED 1
/*INDENT OFF*/

/* Description: C source code for quickselect_loop */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    quickselect_loop_src.h copyright 2017-2019 Bruce Lilly.   \ quickselect_loop_src.h $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is quickselect_loop_src.h version 1.31 dated 2019-03-15T14:07:14Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/include/s.quickselect_loop_src.h */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and a pair of indices brackets the sub-array
 being processed.  The indices correspond to the ranks of elements.  A similar
 scheme is used by Musser's introsort, described in "Introspective Sorting and
 Selection Algorithms".  The same method is used for the array of desired order
 statistic ranks, similar to that described by Lent & Mahmoud.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.
 Partitioning can still result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by efficient inline swap functions.  No attempt
 is made to optimize for specific array element types, but swapping can be
 performed in units of basic language types.  The swap functions avoid useless
 work (e.g. when given two pointers to the same element).  No specialized macros
 are required.
******************************************************************************/

/* Nothing to configure below this line. */
/* Minimum _XOPEN_SOURCE version for C99 (else illumos compilation fails) */
#undef MAX_XOPEN_SOURCE_VERSION
#undef MIN_XOPEN_SOURCE_VERSION
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# define MIN_XOPEN_SOURCE_VERSION 600 /* >=600 for illumos */
#else
# define MAX_XOPEN_SOURCE_VERSION 500 /* <=500 for illumos */
#endif

/* feature test macros defined before any header files are included */
#ifndef _XOPEN_SOURCE
# ifdef MIN_XOPEN_SOURCE_VERSION
#  define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
# else
#  ifdef MAX_XOPEN_SOURCE_VERSION
#   define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#  endif
# endif
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MIN_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE < MIN_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#if defined(_XOPEN_SOURCE) \
&& defined(MAX_XOPEN_SOURCE_VERSION) \
&& ( _XOPEN_SOURCE > MAX_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MAX_XOPEN_SOURCE_VERSION
#endif

#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
   ID_STRING_PREFIX is suitable for the what(1) and ident(1) utilities.
   MODULE_DATE uses modern SCCS extensions.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: quickselect_loop_src.h ~|^` @(#)"
#define SOURCE_MODULE "quickselect_loop_src.h"
#define MODULE_VERSION "1.31"
#define MODULE_DATE "2019-03-15T14:07:14Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
#define COPYRIGHT_DATE "2017-2019"

/* Although the implementation is different, several concepts are adapted from:
   qsort -- qsort interface implemented by faster quicksort.
   J. L. Bentley and M. D. McIlroy, SPE 23 (1993) 1249-1265.
   Copyright 1993, John Wiley.
*/

#define QUICKSELECT_FMED3_STATIC static
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# define QUICKSELECT_FMED3_INLINE inline
#endif

/* local header files needed */
#include "quickselect_config.h" /* QUICKSELECT_INLINE */
#include "quickselect.h"        /* sampling_table_struct quickselect QSORT_FUNCTION_NAME */
#include "quickselect_constants.h"      /* pointer_and_a_half */
#include "exchange.h"           /* EXCHANGE_SWAP */
#include "tables.h"             /* SAMPLING_TABLE_SIZE */
#if ! QUICKSELECT_BUILD_FOR_SPEED
#include "initialize_src.h"
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* system header files */
#include <assert.h>             /* assert */
#include <errno.h>              /* errno E* (maybe errno_t [N1570 K3.2]) */
#include <limits.h>             /* *_MAX */
#include <stddef.h>             /* size_t NULL (maybe rsize_t) */
#if defined(__STDC__) && ( __STDC__ == 1) && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
# include <stdint.h>            /* *int*_t (maybe RSIZE_MAX [N1570 K3.4]) */
# if __STDC_VERSION__ >= 201001L
    /* [N1570 6.10.8.1] (minimum value: y=0,mm=01) */
#  include <stdio.h>            /* (maybe errno_t rsize_t [N1570 K3.5]) */
#  include <stdlib.h>           /* (maybe errno_t rsize_t constraint_handler_t
                                   [N1570 K3.6]) */
# endif /* N1570 */
#endif /* C99 or later */

#if ASSERT_CODE + DEBUG_CODE
# include <stdio.h>
#endif

#if  ! __STDC_WANT_LIB_EXT1__
# if ! defined(LIBMEDIAN_TEST_CODE) || (LIBMEDIAN_TEST_CODE == 0)
# define DEDICATED_SORT_SRC_FILE_HERE 1
# define INSERTION_SORT_SRC_FILE_HERE 1
# define QUICKSELECT_LOOP_SRC_FILE_HERE 1
# define REPIVOT_SRC_FILE_HERE 1
# endif
#endif

#ifndef QUICKSELECT_LOOP_SRC_FILE_HERE
extern char quickselect_loop_src_file[];
extern char quickselect_loop_src_file_initialized;
#else
char quickselect_loop_src_file[PATH_MAX];
char quickselect_loop_src_file_initialized=0;
#endif

#if QUICKSELECT_BUILD_FOR_SPEED
# include "dedicated_sort_src.h"
# include "repivot_src.h"
# include "select_max_src.h"
# include "select_min_src.h"
# include "find_minmax_src.h"
# include "select_minmax_src.h"
#endif /* QUICKSELECT_BUILD_FOR_SPEED */

/* structures */
/* regions resulting from partitioning */
struct region_struct {
    size_t first;               /* range in base array */
    size_t beyond;
    size_t *pk;
    size_t firstk;              /* range of order statistics */
    size_t beyondk;
    size_t neq;
    size_t nne;
    unsigned int options;
    unsigned char process;      /* 0=false */
    int c;                      /* repivot factor2 counter */
};

/* select_pivot may call quickselect_loop (for median of medians or median of samples pivot selection); it is included here */
#include "pivot_src.h"

/* Recursive divide-and-conquer method to find both minimum and maximum.
   Split into two parts; (recursively) find minimum and maximum of each part.
   Overall minimum is the smaller of the two minima; overall maximum is the
   larger of the two maxima.
*/
/* function to consolidate logic and calls to special-case selection functions */
/* also sets sampling table, determines whether to sort */
static
QUICKSELECT_INLINE
int special_cases(char *base, size_t first, size_t beyond, size_t size,
    COMPAR_DECL, void (*swapf)(char *, char *, size_t), size_t alignsize,
    size_t size_ratio, size_t nmemb, const size_t *pk, size_t firstk,
    size_t beyondk, size_t cachesz, size_t pbeyond, unsigned int options,
    char **ppeq, char **ppgt, unsigned int *pdistribution, const size_t **ppk)
{
    int ret=1; /* caller continues */
    size_t nk=beyondk-firstk;
    /* Check for special-case selection: 1-2 order statistic ranks */
    if ((3UL>nk)&&((2UL>nk)||(NULL==ppeq))) {
        size_t fk=pk[firstk],  /* first (smallest) rank requested */
            ek=pk[beyondk-1UL],/* end rank requested */
            lp=beyond-1UL;     /* last element rank */
#if (DEBUG_CODE > 0)
        if ((0UL==nk)||(ek<first)||(fk>=beyond)||(ek<fk)) {
            (V)fprintf(stderr,
                "/* %s: %s line %d: (0==nk)||(ek<first)||(fk>=beyond)||(ek<fk):"
                " first=%lu, beyond=%lu, pk=%p, firstk=%lu, beyondk=%lu, nk=%lu"
                ", fk=%lu, ek=%lu */\n",__func__,quickselect_loop_src_file,
                __LINE__,first,beyond,(const void *)pk,firstk,beyondk,nk,fk,ek);
            (V)fprintf(stderr,"/* pk[%lu]=%lu, pk[%lu]=%lu */\n",
                firstk,pk[firstk],beyondk-1UL,pk[beyondk-1UL]);
            abort();
        }
#endif
        A(fk>=first);A(ek<beyond); /* arg sanity */
        A((beyondk==firstk+1UL)||(fk!=ek)); /* no duplicate rank requests */
        switch (nk) {
            case 1UL : /* smallest or largest */
                if (fk==first) {
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                    d_select_min_s
# else
                    d_select_min
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                    select_min_s
# else
                    select_min
# endif
#endif
                    (base,first,beyond,size,
#if __STDC_WANT_LIB_EXT1__
                        compar,context,
#else
                        compar,
#endif
                        swapf,alignsize,size_ratio,options,ppeq,ppgt);
                    return 0 ;
                } else if (ek==lp) {
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                    d_select_max_s
# else
                    d_select_max
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                    select_max_s
# else
                    select_max
# endif
#endif
                    (base,first,beyond,size,
#if __STDC_WANT_LIB_EXT1__
                        compar,context,
#else
                        compar,
#endif
                        swapf,alignsize,size_ratio,options,ppeq,ppgt);
                    return 0 ;
                }
            break;
            case 2UL : /* smallest & largest */
                A(NULL==ppeq);
                if ((fk==first)&&(ek==lp)) { /* smallest & largest */
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
                    d_select_minmax_s
# else
                    d_select_minmax
# endif
#else
# if __STDC_WANT_LIB_EXT1__
                    select_minmax_s
# else
                    select_minmax
# endif
#endif
                    (base,first,beyond,size,
#if __STDC_WANT_LIB_EXT1__
                        compar,context,
#else
                        compar,
#endif
                        swapf,alignsize,size_ratio,options);
                    return 0 ;
                }
            break;
        }
    }
    *pdistribution=
#if LIBMEDIAN_TEST_CODE
            d_sampling_table
#else
            sampling_table
#endif
       (first,beyond,pk,firstk,beyondk,ppeq,ppk,nmemb,size_ratio,options);
    return ret;
}

/* Update order statistic ranks array limits. */
static
QUICKSELECT_INLINE
void rank_tests(char *base, size_t first, size_t p, size_t q,
    size_t beyond, size_t size, const size_t *pk, size_t firstk,
    size_t beyondk, size_t *plk, size_t *prk, char **ppeq, char **ppgt)
{
    /* revised range of order statistic ranks (always) */
    /* < region indices [first,p), order statistics [firstk,lk) */
    /* > region indices [q,beyond), order statistics [rk,beyondk) */
#if LIBMEDIAN_TEST_CODE
     d_klimits
#else
     klimits
#endif
    (p,q,pk,firstk,beyondk,plk,prk);
    /* Special-case below only for median-of-medians w/ region extents for
       avoidance of recomparisons after median selection.
    */
    if ((0UL==firstk)&&(1UL==beyondk)&&(NULL!=ppeq)) {
        /* Only applicable for median-of-medians (one order statistic (the
           median) with non-NULL ppeq and ppgt pointers); extents of region
           containing the median.
        */
        size_t r=pk[0]; /* desired rank */
        A(p<q);A(first<=p);A(q<=beyond);
        /*Update range pointers if median (of medians) is [in] one of 3 regions.
          This is the only place where the extents (ppeq and ppgt) are updated;
          when the desired (median of medians) rank is in the = region or is the
          only element in the < or > region.
        */
        if ((p<=r)&&(r<q)) /* in = region */
            *ppeq=base+p*size, *ppgt=base+q*size;
        else if ((first+1UL==p)&&(first<=r)&&(r<p)) /* < region only element */
            *ppeq=base+first*size, *ppgt=base+p*size;
        else if ((q+1UL==beyond)&&(q<=r)&&(r<beyond)) /* > region only element */
            *ppeq=base+q*size, *ppgt=base+beyond*size;
        /* If the extents are set, none of the regions from this partition need
           be (and will not be) further partitioned.  Otherwise, only the region
           containing the median's (of medians) rank will be processed.
        */
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(SORT_SELECT_DEBUG)||DEBUGGING(PARTITION_DEBUG))
            (V) fprintf(stderr,
                "/* %s: %s line %d: first=%lu, beyond=%lu, p=%lu, q=%lu, r=%lu */\n",
                __func__,quickselect_loop_src_file,__LINE__,first,beyond,p,q,r);
#endif
    }
    A(*plk>=firstk);A(*prk<=beyondk);A(*plk<=*prk);
}

/* quickselect_loop definition (internal interface) */
/* Never called for nmemb<2UL. */

#if  __STDC_WANT_LIB_EXT1__
/* Preliminary support for 9899:201x draft N1570 qsort_s w/ "context".
   "context" is similar to glibc qsort_r; N1570 also has provision for
   runtime-constraint violation detection and handling. "Preliminary"
   because of the apparent lack of a convincing use-case for "context" and
   due to the poorly defined semantics and interface for constraint
   violation handling.

   Consequences of "context" are wide-ranging: any operation that requires
   comparisons (pivot selection, partitioning, dedicated sorting and/or
   selection, and support functions for any of those) has to be rewritten.
   The only operations unaffected are sampling, basic swaps, blockmoves using
   swaps, rank comparisons, and partition size evaluation; sampling and
   repivoting tables may also be reused without change.
   Executable code size is roughly doubled, not including external
   constraint-handler function code.
   Use case of "context" is questionable; one could simply use an appropriate
   comparison function.  Published supposed examples (e.g.
   https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/qsort-s
   tend to be rather silly (in the specific example above:
      1. functions are defined for specific locales, but not specifically
         implementing locale-specific collation -- one could at least as easily
         define locale-specific string comparison functions using the standard
         strcoll [+] function and use these with qsort to perform the
         locale-specific sorts with no need for "context", and avoiding the
         other implementation issues detailed below.
      2. Aside from inconsistent "context" argument order...
      3. ... the implementation comparison function copies (!) (leading portions
         of) supplied strings to fixed size (!!)[*] local buffers, then makes a
         second set of passes (!!!) over the copies to perform a conversion
         (which is discarded (!!!!) when the comparison function returns), which
         is then subjected to a third (!!!!!) pass to perform the comparison.
         Note that qsort implementations typically call the comparison function
         N log N times for an array of N elements; the above implementation
         makes 2 N log N copies and 6 N log N passes over data representing
         the strings to be sorted.  In particular, at each stage of partitioning
         qsort implementations compare a pivot element to many other elements;
         in the above implementation the string corresponding to that pivot
         element is copied, the copy modified and examined, only to be discarded
         before repeating those steps anew with the same pivot element's string
         for the next comparison (N-1 times for each partition of N elements).
      4. Although the copies (see #3 above) ignore the actual length of the
         original strings, strlen is subsequently called for each string (copy),
         resulting in a fourth (!!!!!!) pass over the data. Had strlen been
         called for the initial strings, the copies could have been made
         appropriate sizes (assuming that one still naively wished to make, then
         discard such copies).
      5. "context" is declared as void *, not const void *, which implies that
         either the qsort_s implementation or the called comparison function
         may modify the object pointed to by "context", which invites
         non-deterministic, non-repeatable, (i.e. unspecified and undefined)
         behavior.
      * a possibly-valid use of "context" *might* be to provide the maximum
        string length, avoiding magic numbers and failure to fully compare
        strings which have long identical leading substrings... *if* one
        insisted on the naive implementation involving copies (which are
        subsequently discarded) and multiple passes over the data.  It would
        be much more efficient to make one-time initial transformations (e.g.
        w/ strxfrm [+]) of the original string data supplemented by an index
        indicating the original order (or a pointer to the original string
        data), sorting the transformed and supplemented data using standard
        strcmp on the transformed strings.  That would involve N combined
        transformations and copies (instead of N log N copies and N log N
        transformations) plus N log N standard strcmp string comparisons (rather
        than 6 N log N passes over data), followed by access of the orginal
        string data via the indices or pointers for output, or rearrangement
        of the original string data based on the indices associated with the
        sorted transformed strings.
      + Note that strcoll and strxfrm have been standardized since C89 (a.k.a.
        C90).
   ). In summary, there is no convincing use-case for "context" to justify
   doubling the size of library code.

   Runtime-constraint violation detection is OK, but error handling is poorly
   defined.  It is unclear whether the handler is supposed to be global, or
   per-process, or per-thread.  The only interface is set_constraint_handler_s,
   which changes the handler; there is no way to determine what the handler is
   (e.g. in order to actually call it) without (at least potentially) changing
   it.  It may be possible to reset it (provided no other process or thread made
   an intervening change), but there is an inherent window of vulnerability.
   No provision is made for mutexes or other synchronization mechanisms to avoid
   the vulnerability.
*/
#endif /* __STDC_WANT_LIB_EXT1__ */

/* definition */
#if __STDC_WANT_LIB_EXT1__
QUICKSELECT_QUICKSELECT_LOOP_S
#else
QUICKSELECT_QUICKSELECT_LOOP
#endif
{
#if __STDC_WANT_LIB_EXT1__
    errno_t
#else
    int
#endif
        ret=0;
    auto int c=0; /* repivot factor2 count for iterative operation */
    auto unsigned int distribution=0U; /* sorting */
    auto size_t lneq=0UL, lnne=0UL;
#if ( SIZE_MAX > 65535 ) /* > 16 bits */
# if ( SIZE_MAX > 4294967295 ) /* > 32 bits */
#  define QUICKSELECT_MAX_STACK 64
# else /* 32 bits */
# define QUICKSELECT_MAX_STACK 32
# endif /* 32 bits */
#else /* 16 bits */
# define QUICKSELECT_MAX_STACK 16
#endif /* 16 bits */
    struct region_struct stack[QUICKSELECT_MAX_STACK];
    unsigned char stack_top=(unsigned char)(QUICKSELECT_MAX_STACK);
    int method;
    size_t cache_limit, nel, nmemb, samples;

#if ! QUICKSELECT_BUILD_FOR_SPEED
    if ((char)0==file_initialized) initialize_file(__FILE__);
#endif /* QUICKSELECT_BUILD_FOR_SPEED */
#if (ASSERT_CODE > 0) || LIBMEDIAN_TEST_CODE
    if ((char)0==quickselect_loop_src_file_initialized) {
        (V)path_basename(__FILE__,quickselect_loop_src_file,PATH_MAX);
        quickselect_loop_src_file_initialized++;
    }
#endif
#if LIBMEDIAN_TEST_CODE
    if (DEBUGGING(SORT_SELECT_DEBUG)||DEBUGGING(REPIVOT_DEBUG)) {
        if (NULL!=pk)
            (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, beyond=%lu, pk=%p,"
                " firstk=%lu, beyondk=%lu, pk[%lu]=%lu, pk[%lu]=%lu, ppeq=%p, "
                "ppgt=%p */\n",__func__,quickselect_loop_src_file,__LINE__,first,beyond,
                (const void *)pk,firstk,beyondk,firstk,pk[firstk],beyondk-1UL,
                pk[beyondk-1UL],(void *)ppeq,(void *)ppgt);
        else
            (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, beyond=%lu, "
                "pk=NULL */\n",__func__,quickselect_loop_src_file,__LINE__,first,beyond);
    }
#endif
    A(first<beyond);
    nmemb=beyond-first;
    A(2UL<=nmemb);
    /* ppeq,ppgt consistency: both or neither NULL */
    A(((NULL==ppeq)&&(NULL==ppgt))||((NULL!=ppeq)&&(NULL!=ppgt)));
    if (size>sizeof(char*)) /* direct sorting in data cache */
        cache_limit=(cachesz<<1)/size/3UL; /* 1.5*size within cache */
    else /* indirect mergesort */
        /* pointer_and_a_half is a compile-time constant */
        cache_limit=cachesz/pointer_and_a_half; /* 1.5 pointers within cache */
    for (nel=nmemb; 2UL<=nmemb;) { /* loop until done */
        char *pc, *pd, *pe, *pf, *pivot;
        struct region_struct lt_region, gt_region, *ps_region, *pl_region;

        if (NULL!=pk) { /* selection only */
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(SORT_SELECT_DEBUG)||DEBUGGING(PARTITION_DEBUG))
                (V) fprintf(stderr,
                    "/* %s: %s line %d: first=%lu, beyond=%lu, firstk=%lu, "
                    "beyondk=%lu, pk[%lu]=%lu, pk[%lu]=%lu */\n",
                    __func__,quickselect_loop_src_file,__LINE__,first,beyond,
                    firstk,beyondk,firstk,pk[firstk],beyondk-1UL,
                    pk[beyondk-1UL]);
#endif
            /* Check for special-case selection: 1-2 order statistic ranks */
            if (0==special_cases(base,first,beyond,size,
#if __STDC_WANT_LIB_EXT1__
                compar,context,
#else
                compar,
#endif
                swapf,alignsize,size_ratio,nmemb,pk,firstk,beyondk,cachesz,
                pbeyond,options,ppeq,ppgt,&distribution,&pk))
                goto pop_stack ; /* selection in this region is complete */
        }

        /* Separate test, not else clause; special_cases may change pk. */
        if (NULL==pk) { /* sorting only */
            A(NULL==ppeq);
            if ((5UL>nmemb) /* small sub-array; network no worse than best-case D&C */
/* stable and optimize comparison methods only work within cache limits */
            ||((nmemb<=cache_limit)&&
              ((0U!=(options&(QUICKSELECT_STABLE))) /* stable methods */
              ||(0U!=(options&(QUICKSELECT_OPTIMIZE_COMPARISONS))) /* minimize comparisons */
              ||(
              (nel>nmemb)&& /* ! 1st partition; D&C in case constant, binary */
              /* can only determine non-constant, non-binary, non-ternary after 1st partition */
              (lneq<=(lnne>>2)))) /* not constant, binary, ternary */
              )
            ) {
                /* small array or not 1st sub-array and not M-ary input */
#if LIBMEDIAN_TEST_CODE
                if (nmemb<=quickselect_small_array_cutoff) {
#endif
                    ret= 
#if LIBMEDIAN_TEST_CODE
# if  __STDC_WANT_LIB_EXT1__
                        d_dedicated_sort_s
# else
                        d_dedicated_sort
# endif
#else
# if  __STDC_WANT_LIB_EXT1__
                        dedicated_sort_s
# else
                        dedicated_sort
# endif
#endif
			(base,first,beyond,size,
#if __STDC_WANT_LIB_EXT1__
                        compar,context,
#else
                        compar,
#endif
                        swapf,alignsize,size_ratio,cachesz,pbeyond,options);
                    switch (ret) {
                        case 0 : /* sorting (of this region) is complete */
                        goto pop_stack ;
                        case EINVAL : /* error */
#if ASSERT_CODE + DEBUG_CODE
                            fflush(stderr); fflush(stdout);
                            (V)fprintf(stderr,
                                "/* %s: line %d: EINVAL return %d from "
                                "dedicated_sort */\n",
                                __func__,__LINE__,ret);
                            A(ret!=EINVAL);
#endif
                        return ret ;
                        case EAGAIN : /* continue with divide-and-conquer */
                            ret = 0; /* for quickselect_loop return */
                        break;
                        default : /* ? */
#if ASSERT_CODE + DEBUG_CODE
                            fflush(stderr); fflush(stdout);
                            (V)fprintf(stderr,
                                "/* %s: line %d: unexpected return %d from "
                                "dedicated_sort */\n",
                                __func__,__LINE__,ret);
                            A(ret==0);
#endif
                        return ret ;
                    }
#if LIBMEDIAN_TEST_CODE
                }
#endif
            }
#if LIBMEDIAN_TEST_CODE
            else
                if (DEBUGGING(SORT_SELECT_DEBUG)||DEBUGGING(METHOD_DEBUG)) {
                    (V)fprintf(stderr,
                        "/* %s: %s line %d: first=%lu, beyond=%lu, nmemb=%lu, "
                        "nel=%lu, size=%lu, lneq=%lu, lnne=%lu, size_ratio=%lu,"
                        " pbeyond=%lu, compar=%s, cachesz=%lu, cache_limit=%lu,"
                        " options=0x%x"
                        " */\n",__func__,quickselect_loop_src_file,__LINE__,
                        (unsigned long)first,(unsigned long)beyond,
                        (unsigned long)nmemb,(unsigned long)nel,
                        (unsigned long)size,(unsigned long)lneq,
                        (unsigned long)lnne,(unsigned long)size_ratio,
                        (unsigned long)pbeyond,comparator_name(compar),
                        (unsigned long)cachesz,(unsigned long)cache_limit,
                        options);
                }
#endif
        }

        /* Divide-and-conquer. */

#if LIBMEDIAN_TEST_CODE
        /* count repivots */
        if ((0U!=((QUICKSELECT_RESTRICT_RANK)&options))
#if 1 /* 0 count or 1 don't count repivoting for median-of-medians */
        && (NULL==ppeq)
#endif
        ) {
            nrepivot++;
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(SORT_SELECT_DEBUG)||DEBUGGING(SHOULD_REPIVOT_DEBUG))
                (V)fprintf(stderr,"/* %s: %s line %d: repivoting region "
                    "first=%lu, beyond=%lu, firstk=%lu, beyondk=%lu, "
                    "options=0x%x */\n",__func__,quickselect_loop_src_file,__LINE__,first,
                    beyond,firstk,beyondk,options);
# endif
        }
#endif

        /* select a pivot element, update method and samples */
        pivot=
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
            d_select_pivot_s
# else
            d_select_pivot
# endif
#else
# if __STDC_WANT_LIB_EXT1__
            select_pivot_s
# else
            select_pivot
# endif
#endif
	    (base,first,beyond,size,
#if __STDC_WANT_LIB_EXT1__
            compar,context,
#else
            compar,
#endif
            swapf,alignsize,size_ratio,distribution,pk,firstk,beyondk,cachesz,
            pbeyond,options,&pc,&pd,&pe,&pf,&method,&samples);
        A(NULL!=pivot);
        if (NULL==pivot) {
#if LIBMEDIAN_TEST_CODE
            fprintf(stderr,"/* %s: line %d: NULL pivot */\n",__func__,__LINE__);
            abort();
#endif
            return ret=errno;
        }
#if ASSERT_CODE
        if ((pivot<base+first*size)||(pivot>=base+beyond*size)) {
            (V)fprintf(stderr, "/* %s: %s line %d: pivot=%p(%d), pl=%p, pu=%p */\n",
                __func__,quickselect_loop_src_file,__LINE__,(void *)pivot,*((int *)pivot),
                base+first*size,base+beyond*size);
            print_some_array(base,first,beyond-1UL, "/* "," */",options);
        }
#endif /* ASSERT_CODE */
        A(NULL!=pivot);A(base+first*size<=pivot);A(pivot<base+beyond*size);
        A(pc<=pd);A(pd<pe);A(pe<=pf);A(pd<=pivot);A(pivot<pe);
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(REPIVOT_DEBUG)||DEBUGGING(PIVOT_SELECTION_DEBUG)) {
            size_t x=(pivot-base)/size;
            (V)fprintf(stderr, "/* %s line %d: pivot=%p[%lu], pc@%lu, pd@%lu, pe@%lu, "
                "pf@%lu */\n", __func__,__LINE__,(void *)pivot,x,(pc-base)/size,
                (pd-base)/size,(pe-base)/size,(pf-base)/size);
            if (pivot!=base+size*x)
                (V)fprintf(stderr, "/* %s line %d: pivot %p is misaligned: %p */\n",
                    __func__,__LINE__,pivot,base+size*x);
            if (nmemb<=MAX_ARRAY_PRINT)
                print_some_array(base,first,beyond-1UL, "/* "," */",options);
        }
#endif

        /* Partition the array around the pivot element into less-than,
           equal-to, and greater-than (w.r.t. the pivot) regions.  The
           equal-to region requires no further processing. The large region in
           particular should have the pk pointer saved as special_cases may set
           pk to NULL for some small region before the large region is popped
           from the stack.
        */
        lt_region.pk=gt_region.pk=pk;
        lt_region.first=first, gt_region.beyond=beyond;
#if LIBMEDIAN_TEST_CODE
# if __STDC_WANT_LIB_EXT1__
        d_partition_s
# else
        d_partition
# endif
#else
# if __STDC_WANT_LIB_EXT1__
        partition_s
# else
        partition
# endif
#endif
        (base,first,beyond,pc,pd,pivot,pe,pf,size,
#if __STDC_WANT_LIB_EXT1__
            compar,context,
#else
            compar,
#endif
            swapf,alignsize,size_ratio,cachesz,options,
            &(lt_region.beyond),&(gt_region.first));
        lt_region.neq=gt_region.neq=lneq=gt_region.first-lt_region.beyond;
        lt_region.nne=gt_region.nne=lnne=nmemb-lneq;
        /* regions: < [first,lt_region.beyond)
                    > [gt_region.first,beyond)
        */
        A(lt_region.beyond<gt_region.first);A(lt_region.beyond<=beyond);
        A(lt_region.first<=lt_region.beyond);
        A(gt_region.first<=gt_region.beyond);A(first<=gt_region.first);
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(CORRECTNESS_DEBUG)) {
            size_t x;
            x=test_array_partition(base,first,lt_region.beyond,
                gt_region.first-1UL,beyond-1UL,size,compar,options,NULL,NULL);
            if (x!=lt_region.beyond) {
                (void)fprintf(stderr,"/* %s: line %d: bad partition at %lu, "
                    "pivot at %lu */\n",__func__,__LINE__,
                    x,lt_region.beyond);
                print_some_array(base,first,beyond-1UL,"/* ",
                    " */",options);
                abort();
            }
        }
#endif

        if (NULL!=pk) { /* selection only; desired ranks for regions */
            rank_tests(base,first,lt_region.beyond,gt_region.first,beyond,size,
                pk,firstk,beyondk,&(lt_region.beyondk),&(gt_region.firstk),ppeq,
                ppgt);
            lt_region.firstk=firstk, gt_region.beyondk=beyondk;
        }
#if LIBMEDIAN_TEST_CODE
        else /* sorting */
            /* for graphing ratios during sorting */
            lt_region.firstk=lt_region.beyondk=gt_region.firstk=gt_region.beyondk=0UL;
#endif

        /* Which region(s) should be processed? */
#define PROCESS_ELEMENTS   1U /* process region with more than 1 element */
#define PROCESS_STATISTICS 2U /* process region with at least one order statistic for selection */
        lt_region.process=gt_region.process=0U;
        if (NULL!=pk) { /* selection */
            /* requirements for processing:
                  firstk<beyondk (at least one order statistic)
                  first+1UL<beyond (at least 2 elements)
            */
            if ((lt_region.firstk<lt_region.beyondk)
            &&(lt_region.first+1UL<lt_region.beyond)) {
                lt_region.process |= PROCESS_STATISTICS ;
            }
            if ((gt_region.firstk<gt_region.beyondk)
            &&(gt_region.first+1UL<gt_region.beyond)) {
                gt_region.process |= PROCESS_STATISTICS ;
            }
        } else { /* sorting */
            if (lt_region.first+1UL<lt_region.beyond)
                lt_region.process |= PROCESS_ELEMENTS ;
            if (gt_region.first+1UL<gt_region.beyond)
                gt_region.process |= PROCESS_ELEMENTS ;
        }

        /* Categorize less-than and greater-than regions as small and large. */
        if (lt_region.beyond-lt_region.first<gt_region.beyond-gt_region.first) {
            ps_region=&lt_region, pl_region=&gt_region;
        } else {
            ps_region=&gt_region, pl_region=&lt_region;
        }

        if (0U!=((QUICKSELECT_RESTRICT_RANK)&options))
            c=0; /* reset factor2 count if pivot was median-of-medians */
        /* default pivot selection uses array SAMPLES */
        options &= ~(QUICKSELECT_RESTRICT_RANK);

        pl_region->options=ps_region->options=options;
        ps_region->c=0;

        /* Process less-than and/or greater-than regions by relative size. */
#if LIBMEDIAN_TEST_CODE
        if (DEBUGGING(PARTITION_DEBUG)) {
            (V)fprintf(stderr,"/* %s: %s line %d: small region from partition "
                "of nmemb=%lu, s=%lu, e=%lu, t=%lu, pk=%p, small region "
                "firstk=%lu, beyondk=%lu, ppeq=%p%s */\n",__func__,
                quickselect_loop_src_file,__LINE__,nmemb,
                ps_region->beyond-ps_region->first,
                gt_region.first-lt_region.beyond,
                pl_region->beyond-pl_region->first,
                (const void *)pk, ps_region->firstk, ps_region->beyondk,
                (void *)ppeq, (0U==ps_region->process)?" (ignored)":"");
        }
        if (((NULL==ppeq)||(DEBUGGING(PARTITION_DEBUG)))
           &&(DEBUGGING(PARTITION_ANALYSIS_DEBUG))
        ) { /* for graphing ratios during sorting */
            size_t n=pl_region->beyond-pl_region->first, r;
            r = n/(nmemb-n);
            (V)fprintf(stderr,"/* %s: %s line %d: regions from partition of nme"
                "mb=%lu, s=%lu, e=%lu, t=%lu, distribution=%u, size_ratio=%lu, "
                "method=%d, samples=%lu, pk=%p, ppeq=%p, large region "
                "firstk=%lu, beyondk=%lu, count=%d, ratio=%lu, options=0x%x%s "
                "*/\n",__func__,
                quickselect_loop_src_file,__LINE__,nmemb,
                ps_region->beyond-ps_region->first,
                gt_region.first-lt_region.beyond,n,distribution,size_ratio,
                method,samples,(const void *)pk,(void *)ppeq,
                pl_region->firstk,pl_region->beyondk,
                c,r,options,(0U==pl_region->process)?" (ignored)":"");
            if (DEBUGGING(PARTITION_DEBUG))
                print_some_array(base,first,beyond-1UL,"/* "," */",options);
        }
#endif

        /* If both regions are to be processed, put the large region on the
           stack.  If only the large region is to be processed, set up variables
           and iterate.  If neither region is to be processed, do nothing here
           (fall through to next section, which will pop a region from the stack
           for processing, or, if the stack is empty, will return to the
           caller).  If the large region is to be processed, determine whether
           to repivot.
        */
        if (0U!=pl_region->process) { /* Process large region. */
            /* Should large region be repivoted? */
            /* Determine whether or not to repivot/repartition region of size r
               elements (large region) resulting from a partition of nmemb
               elements.  Assumed that continued processing of the region w/o
               repivoting will yield a similarly poor split.  Repivot if the
               cost of repivoting plus processing the resulting regions is
               expected to be less than the cost of processing the region w/o
               repivoting.
            */
            if (0U==(options&(QUICKSELECT_NO_REPIVOT)))
                pl_region->options|=
#if LIBMEDIAN_TEST_CODE
                    d_should_repivot
#else
                    should_repivot
#endif
                    (nmemb,pl_region->beyond-pl_region->first,samples,method,
                    options,pk,&c);
            pl_region->c=c;
            if (0U!=ps_region->process) { /* Iterate on small region (below). */
#if LIBMEDIAN_TEST_CODE
                if (DEBUGGING(SORT_SELECT_DEBUG))
                    (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, beyond=%lu"
                        ", nmemb=%lu, both regions [%lu,%lu), [%lu,%lu) */\n",
                        __func__,quickselect_loop_src_file,__LINE__,first,
                        beyond,nmemb,ps_region->first,ps_region->beyond,
                        pl_region->first,pl_region->beyond);
                if (NULL!=pk) {
                    if ((pk[ps_region->beyondk-1UL]<ps_region->first)
                       ||(pk[ps_region->firstk]<ps_region->first)
                       ||(pk[ps_region->firstk]>=ps_region->beyond)
                       ||(pk[ps_region->beyondk-1UL]>=ps_region->beyond)
                    ) {
                       (V)fprintf(stderr,"/* %s: %s line %d: (0==nk)||"
                           "(ek<first)||(fk>=beyond)||(ek<fk): first=%lu, "
                           "beyond=%lu, pk=%p, firstk=%lu(%lu), beyondk=%lu"
                           "(-1:%lu) */\n",__func__,quickselect_loop_src_file,__LINE__,
                           ps_region->first,ps_region->beyond,(const void *)pk,
                           ps_region->firstk,pk[ps_region->firstk],
                           ps_region->beyondk,pk[ps_region->beyondk-1UL]);
                        abort();
                    }
                    if ((pk[pl_region->beyondk-1UL]<pl_region->first)
                       ||(pk[pl_region->firstk]<pl_region->first)
                       ||(pk[pl_region->firstk]>=pl_region->beyond)
                       ||(pk[pl_region->beyondk-1UL]>=pl_region->beyond)
                    ) {
                       (V)fprintf(stderr,"/* %s: %s line %d: (0==nk)||"
                           "(ek<first)||(fk>=beyond)||(ek<fk): first=%lu, "
                           "beyond=%lu, pk=%p, firstk=%lu(%lu), beyondk=%lu"
                           "(-1:%lu) */\n",__func__,quickselect_loop_src_file,__LINE__,
                           pl_region->first,pl_region->beyond,(const void *)pk,
                           pl_region->firstk,pk[pl_region->firstk],
                           pl_region->beyondk,pk[pl_region->beyondk-1UL]);
                        abort();
                    }
                }
#endif /* LIBMEDIAN_TEST_CODE */
                 /* Push large region onto stack for later processing. */
                if (0U<stack_top) {
                    stack[--stack_top]=*pl_region; /* structure copy */
#if LIBMEDIAN_TEST_CODE
                    if (DEBUGGING(SORT_SELECT_DEBUG)) {
                        unsigned char x;
                        for (x=stack_top; x<QUICKSELECT_MAX_STACK; x++)
                            (V)fprintf(stderr,"/* %s: %s line %d: stack[%u]: "
                                "first=%lu, beyond=%lu, firstk=%lu, beyondk=%lu,"
                                " options=0x%x */\n",
                                __func__,quickselect_loop_src_file,__LINE__,x,
                                stack[x].first,stack[x].beyond,stack[x].firstk,
                                stack[x].beyondk,stack[x].options);
                    }
#endif /* LIBMEDIAN_TEST_CODE */
                 }
            } else { /* Large region only; iterate now. */
                first=pl_region->first, beyond=pl_region->beyond,
                    firstk=pl_region->firstk, beyondk=pl_region->beyondk,
                    options=pl_region->options;
                nmemb=beyond-first; /* update nmemb after should_repivot call */
#if LIBMEDIAN_TEST_CODE
                if (DEBUGGING(SORT_SELECT_DEBUG))
                    (V)fprintf(stderr,"/* %s: %s line %d: first=%lu, beyond=%lu"
                        ", nmemb=%lu, large region */\n",
                        __func__,quickselect_loop_src_file,__LINE__,first,
                        beyond,nmemb);
#endif /* LIBMEDIAN_TEST_CODE */
                continue;
            }
        }

        /* If the small region is to be processed, set up variables and iterate;
           otherwise, pop a region from the stack and set up variables to
           iterate, unless there are no regions on the stack, in which case
           return to caller.
        */
        if (0U!=ps_region->process) { /* Iterate on small region. */
            first=ps_region->first, beyond=ps_region->beyond,
                firstk=ps_region->firstk, beyondk=ps_region->beyondk,
                options=ps_region->options, c=0;
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG))
                (V)fprintf(stderr,"/* %s: %s line %d: small region: first=%lu, "
                    "beyond=%lu, firstk=%lu, beyondk=%lu: %s */\n",__func__,
                    quickselect_loop_src_file,__LINE__,first,beyond,firstk,beyondk,
                    "continuing");
#endif
            nmemb=beyond-first; /* update nmemb after should_repivot call */
            continue;
        } else {
            /* not processing small region (nor large region) */
pop_stack:  if (QUICKSELECT_MAX_STACK>stack_top) {
#if LIBMEDIAN_TEST_CODE
                if (DEBUGGING(SORT_SELECT_DEBUG)) {
                    unsigned char x;
                    for (x=stack_top; x<QUICKSELECT_MAX_STACK; x++)
                        (V)fprintf(stderr,"/* %s: %s line %d: stack[%u]: "
                            "first=%lu, beyond=%lu, firstk=%lu, beyondk=%lu,"
                            " options=0x%x */\n",
                            __func__,quickselect_loop_src_file,__LINE__,x,
                            stack[x].first,stack[x].beyond,stack[x].firstk,
                            stack[x].beyondk,stack[x].options);
                }
#endif /* LIBMEDIAN_TEST_CODE */
                first=stack[stack_top].first,
                    beyond=stack[stack_top].beyond,
                    /* restore saved pk, as special_cases may have set pk to NULL */
                    pk=stack[stack_top].pk,
                    firstk=stack[stack_top].firstk,
                    beyondk=stack[stack_top].beyondk,
                    lneq=stack[stack_top].neq,
                    lnne=stack[stack_top].nne,
                    options=stack[stack_top].options,
                    c=stack[stack_top].c;
                stack_top++;
                nmemb=beyond-first; /* update nmemb after should_repivot call */
#if LIBMEDIAN_TEST_CODE
                if (DEBUGGING(REPARTITION_DEBUG))
                    (V)fprintf(stderr,"/* %s: %s line %d: popped region: first=%lu, "
                        "beyond=%lu, firstk=%lu, beyondk=%lu: %s */\n",__func__,
                        quickselect_loop_src_file,__LINE__,first,beyond,firstk,beyondk,
                        "continuing");
#endif
                continue;
            }
#if LIBMEDIAN_TEST_CODE
            if (DEBUGGING(REPARTITION_DEBUG))
                (V)fprintf(stderr,"/* %s: %s line %d: %s */\n",__func__,
                    quickselect_loop_src_file,__LINE__,"done");
#endif
            if (NULL!=ppeq) { A(NULL!=*ppeq); A(NULL!=*ppgt); }
#if LIBMEDIAN_TEST_CODE
            if ((NULL!=ppeq)&&(1UL==beyondk-firstk)) {
                /* *ppeq must be within sub-array */
                if ((*ppeq<base+first*size)||(*ppeq>=base+beyond*size)) {
                    (V)fprintf(stderr,
                        "/* %s line %d: first=%lu, beyond=%lu, firstk=%lu, beyondk="
                        "%lu, *ppeq@%lu, *ppgt@%lu */\n",__func__,__LINE__,first,
                        beyond,firstk,beyondk,(*ppeq-base)/size,(*ppgt-base)/size);
                    print_some_array(base,first,beyond-1UL,"/* "," */",options);
                    abort();
                }
            }
#endif
            return ret ; /* Process neither; nothing left to do. */
        }
    }
    return ret;
}
#endif /* QUICKSELECT_LOOP_SRC_H_INCLUDED */
