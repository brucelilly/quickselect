/*INDENT OFF*/

/* Description: C source code for quickselect tables */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    repivot_tables.c copyright 2017 Bruce Lilly.   \ repivot_tables.c $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is repivot_tables.c version 1.3 dated 2018-04-18T01:11:42Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/src/s.repivot_tables.c */

/********************** Long description and rationale: ***********************
 Partitioning can result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 The tables defined by this file determine how lopsided a prtition may be before
 the large region is repartitioned.
******************************************************************************/

/* Nothing to configure below this line. */

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
   ID_STRING_PREFIX is suitable for the what(1) and ident(1) utilities.
   MODULE_DATE uses modern SCCS extensions.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: repivot_tables.c ~|^` @(#)"
#define SOURCE_MODULE "repivot_tables.c"
#define MODULE_VERSION "1.3"
#define MODULE_DATE "2018-04-18T01:11:42Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
#define COPYRIGHT_DATE "2017"

/* local header files needed */
#include "quickselect_config.h" /* SORTING_TABLE_ENTRIES */
#include "tables.h"             /* struct repivot_table_struct */

/* system header files */
#include <stddef.h>             /* size_t */

/* data structures */
/*
   Repivoting with median-of medians always results in a ratio of the large
      region size to the remaining elements less than 3:1 (worst case is at size
      8 (2 sets of 3, with 2 elements left over; largest possible large region
      size is 6 for a ratio of 3:1), but sub-arrays of size 8 are never
      repivoted; the practical worst case is then at size 14 (4 sets of 3, with
      2 elements left over; worst case large region size 10 for a ratio of
      5:2)).
   With 729 or more samples, the ratio of the large region size to the remaining
      elements is rarely as high as 3:1, so factor2 and factor1 for those
      repivot table entries can safely be set to 3UL without any noticeable
      effect on the performance for random and/or frequently encountered
      structured input sequences.
   The factor2 member is set by finding the worst-case adversarial performance
      for sorting and for selection, and reducing the factor2 value at the
      appropriate max_nmemb entry to eliminate that worst-case performance,
      repeating the process until some desired absolute worst-case is achieved
      or the worst-case performance point cannot be eliminated by reducing
      factor2.
   When factor2 reduction is no longer able to eliminate a worst-case
      performance point, factor1 may be reduced to eliminate the worst-case
      performance point. This may be repeated (after first trying factor2!)
      until a desired absolute worst-case performance point is reached, no
      further improvement can be obtained using factor2 and factor1, or the
      elimination of a worst-case performance point entails too large of a
      performance penalty for random input sequences.
   The "disabled" and "transparent" repivot table factor1 and factor2 entries
      for 243 and fewer samples are set such that repivoting 'never' occurs for
      random input sequences for different variations of 'never', where 'never'
      represents some very low probability.
   The "loose" table entries are set to achieve a worst-case sorting comparison
      complexity of <= 2.0 N log(N) comparisons without further affecting random
      input sequences.
   The "relaxed" table entries are set to achieve the minimum comparison
      complexities possible for sorting using primarily factor2, and only
      decreasing factor1 when absolutely necessary.
   The "aggressive" table entries use both factors as far as possible (i.e.
      until some worst-case performance point cannot be eliminated or the
      performance penalty becomes too great).
*/
/* repivot factors are relatively small unsigned integers */

/* sorting repivot tables */
struct repivot_table_struct sorting_repivot_table_transparent[] = {
  /* 3 */ {  40U,  39U }, /* sorting transparent */ /* median-of-3 */
  /* 9 */ {  57U,  56U }, /* sorting transparent */ /* remedian of samples */
 /* 27 */ {  57U,  56U }, /* sorting transparent */
 /* 81 */ {  16U,  15U }, /* sorting transparent */
/* 243 */ {   7U,   6U }, /* sorting transparent */
/* 729 */ {   4U,   3U }, /* sorting transparent */
};
struct repivot_table_struct sorting_repivot_table_loose[] = {
  /* 3 */ {  40U,  39U }, /* sorting loose */ /* median-of-3 */
  /* 9 */ {  57U,  10U }, /* sorting loose */ /* remedian of samples */
 /* 27 */ {  57U,   6U }, /* sorting loose */
 /* 81 */ {  16U,  15U }, /* sorting loose */
/* 243 */ {   7U,   6U }, /* sorting loose */
/* 729 */ {   4U,   3U }, /* sorting loose */
};
struct repivot_table_struct sorting_repivot_table_relaxed[] = {
  /* 3 */ {  40U,  39U }, /* sorting relaxed */ /* median-of-3 */
  /* 9 */ {  57U,  10U }, /* sorting relaxed */ /* remedian of samples */
 /* 27 */ {  57U,   6U }, /* sorting relaxed */
 /* 81 */ {  16U,  15U }, /* sorting relaxed */
/* 243 */ {   7U,   6U }, /* sorting relaxed */
/* 729 */ {   4U,   3U }, /* sorting relaxed */
};
struct repivot_table_struct sorting_repivot_table_aggressive[] = {
  /* 3 */ {  40U,   9U }, /* sorting aggressive */ /* median-of-3 */
  /* 9 */ {  11U,  10U }, /* sorting aggressive */ /* remedian of samples */
 /* 27 */ {  57U,   6U }, /* sorting aggressive */
 /* 81 */ {  16U,  15U }, /* sorting aggressive */
/* 243 */ {   7U,   6U }, /* sorting aggressive */
/* 729 */ {   4U,   3U }, /* sorting aggressive */
};
struct repivot_table_struct sorting_repivot_table_disabled[] = {
  /* 3 */ { 255U, 255U }, /* disabled */
  /* 9 */ { 255U, 255U }, /* disabled */
 /* 27 */ { 255U, 255U }, /* disabled */
 /* 81 */ { 255U, 255U }, /* disabled */
/* 243 */ { 255U, 255U }, /* disabled */
/* 729 */ { 255U, 255U }, /* disabled */
};

struct repivot_table_struct *sorting_repivot_table =
#if SORTING_TABLE_ENTRIES == TRANSPARENT
    sorting_repivot_table_transparent
#elif SORTING_TABLE_ENTRIES == LOOSE
    sorting_repivot_table_loose
#elif SORTING_TABLE_ENTRIES == RELAXED
    sorting_repivot_table_relaxed
#elif SORTING_TABLE_ENTRIES == AGGRESSIVE
    sorting_repivot_table_aggressive
#else
    sorting_repivot_table_disabled
#endif
;

/* selection repivot table; always very aggressive due to the much greater
   sensitivity of selection performance to lopsided partitions.
*/
struct repivot_table_struct selection_repivot_table[] = {
  /* 3 */ {  30U,   3U }, /* selection aggressive */ /* median-of-3 */
/* XXX 9 samples factor1=4 (@3, median cost at 1172 adverse sequence elements increases) */
  /* 9 */ {   4U,   3U }, /* selection aggressive */ /* remedian of samples */
 /* 27 */ {   6U,   6U }, /* selection aggressive */
 /* 81 */ {  16U,  15U }, /* selection aggressive */
/* 243 */ {   7U,   6U }, /* selection aggressive */
/* 729 */ {   4U,   3U }, /* selection aggressive */
};

/* All repivot tables have the same size. */
const size_t repivot_table_size
    = sizeof(selection_repivot_table)/sizeof(selection_repivot_table[0]);
