/*INDENT OFF*/

/* Description: C source code for quickselect tables */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    tables.c copyright 2017 Bruce Lilly.   \ tables.c $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is tables.c version 1.1 dated 2017-09-15T04:28:41Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/src/s.tables.c */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and a pair of indices brackets the sub-array
 being processed.  The indices correspond to the ranks of elements.  A similar
 scheme is used by Musser's introsort, described in "Introspective Sorting and
 Selection Algorithms".  The same method is used for the array of desired order
 statistic ranks, similar to that described by Lent & Mahmoud.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.
 Partitioning can still result in an unfavorable split of the initial sub-array;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by efficient inline swap functions.  No attempt
 is made to optimize for specific array element types, but swapping can be
 performed in units of basic language types.  The swap functions avoid useless
 work (e.g. when given two pointers to the same element).  No specialized macros
 are required.
******************************************************************************/

/* Nothing to configure below this line. */

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
   ID_STRING_PREFIX is suitable for the what(1) and ident(1) utilities.
   MODULE_DATE uses modern SCCS extensions.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: tables.c ~|^` @(#)"
#define SOURCE_MODULE "tables.c"
#define MODULE_VERSION "1.1"
#define MODULE_DATE "2017-09-15T04:28:41Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
#define COPYRIGHT_DATE "2017"

/* local header files needed */
#include "quickselect_config.h" /* quickselect QSORT_FUNCTION_NAME */
#include "tables.h"     /* sampling_table_struct SAMPLING_TABLE_SIZE */

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* system header files */
#include <limits.h>             /* *_MAX */
#include <stddef.h>             /* size_t NULL */

/* data structures */
struct sampling_table_struct sorting_sampling_table[] = { /* 000 q -> SORTING 5U */
   {                     2UL,           1UL }, /* sorting */
   {                    79UL,           3UL }, /* sorting */
   {                   551UL,           9UL }, /* sorting */
   {                  3567UL,          27UL }, /* sorting */
   {                 23958UL,          81UL }, /* sorting */
   {                179087UL,         243UL }, /* sorting */
   {               1611788UL,         729UL }, /* sorting */
   {              14506098UL,        2187UL }, /* sorting */
   {             130554892UL,        6561UL }, /* sorting */
   {            1174994040UL,       19683UL }, /* sorting */
#if (SIZE_MAX) > 4294967295
   {           10574946371UL,       59049UL }, /* sorting */
   {           95174517350UL,      177147UL }, /* sorting */
   {          856570656158UL,      531441UL }, /* sorting */
   {         7709135905434UL,     1594323UL }, /* sorting */
   {        69382223148914UL,     4782969UL }, /* sorting */
   {       624440008340237UL,    14348907UL }, /* sorting */
   {      5619960075062138UL,    43046721UL }, /* sorting */
   {     50579640675559248UL,   129140163UL }, /* sorting */
   {    455216766080033152UL,   387420489UL }, /* sorting */
   {   4096950894720299008UL,  1162261467UL }, /* sorting */
#else
   {   (SIZE_MAX),                  59049UL },
   {   (SIZE_MAX),                 177147UL },
   {   (SIZE_MAX),                 531441UL },
   {   (SIZE_MAX),                1594323UL },
   {   (SIZE_MAX),                4782969UL },
   {   (SIZE_MAX),               14348907UL },
   {   (SIZE_MAX),               43046721UL },
   {   (SIZE_MAX),              129140163UL },
   {   (SIZE_MAX),              387420489UL },
   {   (SIZE_MAX),             1162261467UL },
#endif
   {            (SIZE_MAX),    3486784401UL }, /* sorting */
};
struct sampling_table_struct ends_sampling_table[] = { /* 001 e -> ENDS 1U */
   {                     2UL,           1UL }, /* ends */
   {                   108UL,           3UL }, /* ends */
   {   (SIZE_MAX),                      9UL }, /* ends */
   {   (SIZE_MAX),                     27UL }, /* ends */
   {   (SIZE_MAX),                     81UL }, /* ends */
   {   (SIZE_MAX),                    243UL }, /* ends */
   {   (SIZE_MAX),                    729UL }, /* ends */
   {   (SIZE_MAX),                   2187UL }, /* ends */
   {   (SIZE_MAX),                   6561UL }, /* ends */
   {   (SIZE_MAX),                  19683UL },
   {   (SIZE_MAX),                  59049UL },
   {   (SIZE_MAX),                 177147UL },
   {   (SIZE_MAX),                 531441UL },
   {   (SIZE_MAX),                1594323UL },
   {   (SIZE_MAX),                4782969UL },
   {   (SIZE_MAX),               14348907UL },
   {   (SIZE_MAX),               43046721UL },
   {   (SIZE_MAX),              129140163UL },
   {   (SIZE_MAX),              387420489UL },
   {   (SIZE_MAX),             1162261467UL },
   {   (SIZE_MAX),             3486784401UL },
};
struct sampling_table_struct middle_sampling_table[] = { /* 010 m -> MIDDLE 2U */
   {                     2UL,           1UL }, /* middle */
   {                    29UL,           3UL }, /* middle */
   {                   149UL,           9UL }, /* middle */
   {                   899UL,          27UL }, /* middle */
   {                  4204UL,          81UL }, /* middle */
   {                 21027UL,         243UL }, /* middle */
   {                102563UL,         729UL }, /* middle */
   {                328153UL,        2187UL }, /* middle */
   {               1658941UL,        6561UL }, /* middle */
   {               8386583UL,       19683UL }, /* middle */
   {              42397374UL,       59049UL }, /* middle */
   {             214334865UL,      177147UL }, /* middle */
   {            1083544306UL,      531441UL }, /* middle */
#if (SIZE_MAX) > 4294967295
   {            5477728782UL,     1594323UL }, /* middle */
   {           27692003385UL,     4782969UL }, /* middle */
   {          139993614503UL,    14348907UL }, /* middle */
   {          707720991818UL,    43046721UL }, /* middle */
   {         3577798916285UL,   129140163UL }, /* middle */
   {        18087134949157UL,   387420489UL }, /* middle */
   {        91437349701199UL,  1162261467UL }, /* middle */
#else
   {   (SIZE_MAX),                1594323UL },
   {   (SIZE_MAX),                4782969UL },
   {   (SIZE_MAX),               14348907UL },
   {   (SIZE_MAX),               43046721UL },
   {   (SIZE_MAX),              129140163UL },
   {   (SIZE_MAX),              387420489UL },
   {   (SIZE_MAX),             1162261467UL },
#endif
   {   (SIZE_MAX),             3486784401UL },
};

/* Sampling for selection depends on the distribution of order statistic ranks.
   Specifically on whether or not there are desired order statistic ranks near
   the middle of the sub-array.  If there are desired ranks near the middle,
   more samples for pivot selection leads to an improved rank (i.e. closer to
   the median) for the pivot, and a better chance of selecting one of the
   desired ranks as the pivot (which eliminates it from further processing).
   Otherwise, fewer samples may be used to reduce the cost of pivot selection,
   as partitioning need not be so precise.  The distribution of desired order
   statistic ranks starts with a determination of a "raw" distribution, based on
   the presence or absence of desired ranks in three bands of the sub-array,
   leading to 8 possible values: 000, 001, 010, 011, 100, 101, 110, and 111,
   where a 1 indicates presence of desired order statistic ranks in a band.  The
   8 raw distribution values are then translated to one of 2 values for sampling
   for selection, based on whether or not there are desired ranks near the
   middle of the sub-array, as noted above (the middle band is tested first, and
   one other band is checked if necessary to discriminate between distributions
   which have ranks in 2 or 3 bands).  Sorting (as distinct from order statistic
   selection) uses a separate sampling table.  When selecting a large number of
   order statistics, it may be more efficient to simply sort the sub-array,
   where "large" depends on the distribution of order statistics as well as
   their number and the size of the sub-array.  Order statistics ranks which are
   widely distributed result in an advantage to sorting at a lower proportion of
   desired ranks to the sub-array size than for other distributions.  A table
   with two columns, for widely-distributed and for others, is used to indicate
   when sorting is preferred to continued selection; rows of the table
   correspond to sub-array size and the table entry values represent the largest
   number of desired order statistic ranks for which continued selection is
   appropriate.  The raw order statistic distribution is translated into a
   suitable column index value for that table.
*/
/* Lookup table; raw distribution to sampling_distribution_enum value. */
/* The number of array elements is determined by the number of possible raw
   distribution vales, i.e. 8.
*/
unsigned char sampling_distribution_remap[8] = {
    ENDS,      /* 00 000 -> ENDS */
    ENDS,      /* 01 001 -> ENDS */
    MIDDLE,    /* 02 010 -> MIDDLE */
    MIDDLE,    /* 03 011 -> MIDDLE */
    ENDS,      /* 04 100 -> ENDS */
    ENDS,      /* 05 101 -> ENDS */
    MIDDLE,    /* 06 110 -> MIDDLE */
    MIDDLE     /* 07 111 -> MIDDLE */
};
/* sampling table pointers indexed by sampling_distribution_enum value */
struct sampling_table_struct *sampling_tables[SAMPLING_TABLES] = {
    sorting_sampling_table,     /* SORTING 0U */
    ends_sampling_table,        /* ENDS 1U */
    middle_sampling_table,      /* MIDDLE 2U */
};

/* If many order statistics are desired, sorting may be more efficient than
   explicit selection.  The breakpoint where that tradeoff occurs depends on the
   size of the sub-array, the number of desired order statistics, and the
   distribution of the desired order statistic ranks.  For large sub-arrays,
   sorting is more efficient for widely distributed order statistics if their
   quantity is greater than about 10% of the number of sub-array elements.  If
   the order statistics are grouped together or split between the ends of the
   sub-array, selection is more efficient for large sub-arrays with as many as
   90% of the possible ranks as desired order statistics.  Small sub-arrays
   deviate from these rules of thumb, so a small table is used for breakpoints.
   A table of sets of entries with unsigned values less than 256 is used in
   order to keep the table size small.
*/
/* lookup table; raw distribution to selection_distribution */
/* indices 0U through SELECTION_TYPES-1 */
/* order is SEPARATED=0U, ENDS=1U, MIDDLE=2U, DISTRIBUTED=3U */
/* The number of array elements is determined by the number of possible raw
   distribution vales, i.e. 8.
*/
unsigned char selection_distribution_remap[8] = {
    OTHERS,      /* 000 */
    OTHERS,      /* 001 */
    OTHERS,      /* 010 */
    OTHERS,      /* 011 */
    OTHERS,      /* 100 */
    OTHERS,      /* 101 */
    OTHERS,      /* 110 */
    DISTRIBUTED, /* 111 */
};
/* SELECTION_BREAKPOINT_OFFSET is based on avoidance of recomparisons while
       partitioning.
       Selection for median-of-medians is for a single order statistic (the
       median of the medians) and MINMAX is only usable if that desired rank is
       one of the first two or last two elements.  If the first or last, N-1
       comparisons are required (2 at size 3), and if the second or second-last,
       2N-2 comparisons are required (4 at size 3).  At size 3, sorting is
       always at least as efficient as selection.  At size 4, selection is only
       efficient for the first or last element.
*/
/* Selection breakpoints for nmemb SELECTION_BREAKPOINT_OFFSET through
   SELECTION_BREAKPOINT_OFFSET+SELECTION_BREAKPOINTS-1:
   First index is nmemb-BREAKPOINT_OFFSET
   Second index is order statistic distribution remapped via
      selection_distribution_remap[distribution]
      where distribution itself has been remapped from raw distribution via
      sampling_distribution_remap[distribution]
   Value is maximum number of desired order statistics with a certain
     distribution which can be selected via multiple selection; for more
     order statistics, sort the sub-array.
*/
unsigned char selection_breakpoint[SELECTION_BREAKPOINTS][SELECTION_TYPES] = {
/* DISTRIBUTED OTHERS nmemb DISTRIBUTED OTHERS nmemb DISTRIBUTED OTHERS nmemb */
    {   1U,   2U },/*  4*/    {   1U,   3U },/*  5*/    {   1U,   3U },/*  6*/
    {   2U,   4U },/*  7*/    {   2U,   4U },/*  8*/    {   2U,   5U },/*  9*/
    {   3U,   5U },/* 10*/    {   4U,   6U },/* 11*/    {   4U,   7U },/* 12*/
    {   5U,   8U },/* 13*/    {   5U,   9U },/* 14*/    {   5U,  10U },/* 15*/
    {   6U,  11U },/* 16*/    {   6U,  11U },/* 17*/    {   7U,  12U },/* 18*/
    {   7U,  13U },/* 19*/    {   8U,  14U },/* 20*/    {   8U,  14U },/* 21*/
    {   8U,  15U },/* 22*/    {   9U,  16U },/* 23*/    {   9U,  17U },/* 24*/
    {  10U,  18U },/* 25*/    {  10U,  19U },/* 26*/    {   8U,  19U },/* 27*/
    {  11U,  20U },/* 28*/    {  11U,  21U },/* 29*/    {   8U,  21U },/* 30*/
    {   8U,  23U },/* 31*/    {   9U,  22U },/* 32*/    {   9U,  23U },/* 33*/
    {  10U,  23U },/* 34*/    {  10U,  25U },/* 35*/    {  10U,  25U },/* 36*/
    {  11U,  27U },/* 37*/    {  11U,  27U },/* 38*/    {  11U,  29U },/* 39*/
    {  12U,  29U },/* 40*/    {  12U,  30U },/* 41*/    {  12U,  30U },/* 42*/
    {  13U,  31U },/* 43*/    {  13U,  32U },/* 44*/    {  13U,  33U },/* 45*/
    {  14U,  34U },/* 46*/    {  14U,  35U },/* 47*/    {  14U,  35U },/* 48*/
    {  15U,  36U },/* 49*/    {  15U,  37U },/* 50*/    {  15U,  38U },/* 51*/
    {  15U,  39U },/* 52*/    {  16U,  40U },/* 53*/    {  16U,  40U },/* 54*/
    {  16U,  41U },/* 55*/    {  17U,  42U },/* 56*/    {  17U,  43U },/* 57*/
    {  17U,  44U },/* 58*/    {  18U,  45U },/* 59*/    {  18U,  46U },/* 60*/
    {  18U,  47U },/* 61*/    {  19U,  47U },/* 62*/    {  19U,  48U },/* 63*/
    {  19U,  49U },/* 64*/    {  20U,  50U },/* 65*/    {  20U,  51U },/* 66*/
    {  20U,  52U },/* 67*/    {  21U,  53U },/* 68*/    {  21U,  53U },/* 69*/
    {  21U,  54U },/* 70*/    {  21U,  55U },/* 71*/    {  22U,  56U },/* 72*/
    {  22U,  57U },/* 73*/    {  22U,  58U },/* 74*/    {  23U,  59U },/* 75*/
    {  23U,  60U },/* 76*/    {  23U,  60U },/* 77*/    {  24U,  61U },/* 78*/
    {  24U,  62U },/* 79*/    {  25U,  63U },/* 80*/    {  25U,  64U },/* 81*/
    {  25U,  65U },/* 82*/    {  26U,  66U },/* 83*/    {  26U,  67U },/* 84*/
    {  26U,  68U },/* 85*/    {  27U,  68U },/* 86*/    {  27U,  69U },/* 87*/
    {  27U,  70U },/* 88*/    {  27U,  71U },/* 89*/    {  28U,  72U },/* 90*/
    {  28U,  73U },/* 91*/    {  28U,  74U },/* 92*/    {  29U,  74U },/* 93*/
    {  29U,  75U },/* 94*/    {  29U,  76U },/* 95*/    {  30U,  77U },/* 96*/
    {  30U,  78U },/* 97*/    {  30U,  79U },/* 98*/    {  31U,  80U },/* 99*/
    {  31U,  81U },/*100*/    {  31U,  81U },/*101*/    {  32U,  82U },/*102*/
    {  32U,  83U },/*103*/    {  32U,  84U },/*104*/    {  33U,  85U },/*105*/
    {  33U,  86U },/*106*/    {  33U,  87U },/*107*/    {  33U,  88U },/*108*/
    {  34U,  89U },/*109*/    {  34U,  89U },/*110*/    {  34U,  90U },/*111*/
    {  35U,  91U },/*112*/    {  35U,  92U },/*113*/    {  35U,  93U },/*114*/
    {  36U,  94U },/*115*/    {  36U,  95U },/*116*/    {  36U,  96U },/*117*/
    {  37U,  96U },/*118*/    {  37U,  97U },/*119*/    {  37U,  98U },/*120*/
    {  38U,  99U },/*121*/    {  38U, 100U },/*122*/    {  38U, 101U },/*123*/
    {  39U, 102U },/*124*/    {  39U, 103U },/*125*/    {  39U, 104U },/*126*/
    {  40U, 104U },/*127*/    {  40U, 105U },/*128*/    {  40U, 106U },/*129*/
    {  40U, 107U },/*130*/    {  41U, 108U },/*131*/    {  41U, 109U },/*132*/
    {  42U, 110U },/*133*/    {  42U, 111U },/*134*/    {  42U, 112U },/*135*/
    {  43U, 113U },/*136*/    {  43U, 114U },/*137*/    {  43U, 114U },/*138*/
    {  43U, 115U },/*139*/    {  44U, 116U },/*140*/    {  44U, 117U },/*141*/
    {  45U, 118U },/*142*/    {  45U, 119U },/*143*/    {  45U, 120U },/*144*/
    {  45U, 120U },/*145*/    {  46U, 121U },/*146*/    {  46U, 122U },/*147*/
    {  64U, 132U },/*148*/    {  47U, 124U },/*149*/    {  36U, 121U },/*150*/
    {  36U, 121U },/*151*/    {  37U, 122U },/*152*/    {  37U, 123U },/*153*/
    {  37U, 124U },/*154*/    {  37U, 125U },/*155*/    {  38U, 126U },/*156*/
    {  38U, 127U },/*157*/    {  38U, 128U },/*158*/    {  47U, 129U },/*159*/
    {  39U, 130U },/*160*/    {  39U, 131U },/*161*/    {  39U, 132U },/*162*/
    {  49U, 133U },/*163*/    {  40U, 133U },/*164*/    {  40U, 134U },/*165*/
    {  40U, 135U },/*166*/    {  50U, 136U },/*167*/    {  41U, 137U },/*168*/
    {  51U, 138U },/*169*/    {  51U, 139U },/*170*/    {  51U, 140U },/*171*/
    {  42U, 140U },/*172*/    {  42U, 141U },/*173*/    {  52U, 142U },/*174*/
    {  53U, 143U },/*175*/    {  43U, 144U },/*176*/    {  53U, 145U },/*177*/
    {  54U, 146U },/*178*/    {  54U, 147U },/*179*/    {  54U, 148U },/*180*/
    {  55U, 149U },/*181*/    {  55U, 150U },/*182*/    {  55U, 151U },/*183*/
    {  56U, 152U },/*184*/    {  56U, 153U },/*185*/    {  56U, 153U },/*186*/
    {  57U, 154U },/*187*/    {  57U, 155U },/*188*/    {  57U, 156U },/*189*/
    {  58U, 157U },/*190*/    {  58U, 158U },/*191*/    {  58U, 159U },/*192*/
    {  59U, 160U },/*193*/    {  59U, 160U },/*194*/    {  59U, 162U },/*195*/
    {  60U, 163U },/*196*/    {  60U, 164U },/*197*/    {  60U, 164U },/*198*/
    {  61U, 165U },/*199*/    {  61U, 166U },/*200*/    {  61U, 167U },/*201*/
    {  62U, 168U },/*202*/    {  62U, 169U },/*203*/    {  62U, 170U },/*204*/
    {  63U, 171U },/*205*/    {  63U, 171U },/*206*/    {  63U, 173U },/*207*/
    {  64U, 173U },/*208*/    {  64U, 174U },/*209*/    {  64U, 175U },/*210*/
    {  64U, 176U },/*211*/    {  65U, 177U },/*212*/    {  65U, 178U },/*213*/
    {  66U, 179U },/*214*/    {  66U, 180U },/*215*/    {  66U, 181U },/*216*/
    {  67U, 182U },/*217*/    {  67U, 183U },/*218*/    {  67U, 183U },/*219*/
    {  67U, 184U },/*220*/    {  68U, 185U },/*221*/    {  68U, 186U },/*222*/
    {  68U, 187U },/*223*/    {  69U, 188U },/*224*/    {  69U, 189U },/*225*/
    {  69U, 190U },/*226*/    {  70U, 191U },/*227*/    {  70U, 191U },/*228*/
    {  70U, 192U },/*229*/    {  71U, 193U },/*230*/    {  71U, 194U },/*231*/
    {  71U, 195U },/*232*/    {  72U, 196U },/*233*/    {  72U, 197U },/*234*/
    {  72U, 198U },/*235*/    {  73U, 199U },/*236*/    {  73U, 199U },/*237*/
    {  73U, 200U },/*238*/    {  74U, 201U },/*239*/    {  74U, 202U },/*240*/
    {  74U, 203U },/*241*/    {  74U, 204U },/*242*/    {  75U, 205U },/*243*/
    {  75U, 206U },/*244*/    {  75U, 206U },/*245*/    {  76U, 207U },/*246*/
    {  76U, 208U },/*247*/    {  76U, 209U },/*248*/    {  77U, 210U },/*249*/
    {  77U, 211U },/*250*/    {  77U, 212U },/*251*/    {  77U, 212U },/*252*/
    {  78U, 213U },/*253*/    {  78U, 214U },/*254*/    {  79U, 215U },/*255*/
    {  79U, 216U },/*256*/    {  79U, 217U },/*257*/    {  79U, 218U },/*258*/
    {  80U, 218U },/*259*/    {  80U, 219U },/*260*/    {  80U, 220U },/*261*/
    {  81U, 221U },/*262*/    {  81U, 222U },/*263*/    {  81U, 223U },/*264*/
    {  82U, 224U },/*265*/    {  82U, 225U },/*266*/    {  82U, 226U },/*267*/
    {  83U, 227U },/*268*/    {  83U, 228U },/*269*/    {  83U, 228U },/*270*/
    {  83U, 229U },/*271*/    {  84U, 230U },/*272*/    {  84U, 231U },/*273*/
    {  84U, 232U },/*274*/    {  85U, 233U },/*275*/    {  85U, 233U },/*276*/
    {  85U, 234U },/*277*/    {  85U, 235U },/*278*/    {  86U, 236U },/*279*/
    {  86U, 237U },/*280*/    {  86U, 238U },/*281*/    {  87U, 239U },/*282*/
    {  87U, 240U },/*283*/    {  87U, 240U },/*284*/    {  88U, 241U },/*285*/
    {  88U, 242U },/*286*/    {  88U, 243U },/*287*/    {  89U, 244U },/*288*/
    {  89U, 245U },/*289*/    {  89U, 246U },/*290*/    {  90U, 247U },/*291*/
    {  90U, 248U },/*292*/    {  90U, 249U },/*293*/    {  90U, 249U },/*294*/
    {  91U, 250U },/*295*/    {  91U, 251U },/*296*/    {  91U, 252U },/*297*/
    {  92U, 253U },/*298*/    {  92U, 254U },/*299*/    {  92U, 255U },/*300*/
    {  93U, 255U },/*301*/
};

/*
   Repivoting with median-of medians always results in a ratio of the large
      region size to the remaining elements less than 3:1 (worst case is at size
      8 (2 sets of 3, with 2 elements left over; largest possible large region
      size is 6 for a ratio of 3:1), but sub-arrays of size 8 are never
      repivoted; the practical worst case is then at size 14 (4 sets of 3, with
      2 elements left over; worst case large region size 10 for a ratio of
      5:2)).
   With 729 or more samples, the ratio of the large region size to the remaining
      elements is rarely as high as 3:1, so factor2 and factor1 for those
      repivot table entries can safely be set to 3UL without any noticeable
      effect on the performance for random and/or frequently encountered
      structured input sequences.
   The factor2 member is set by finding the worst-case adversarial performance
      for sorting and for selection, and reducing the factor2 value at the
      appropriate max_nmemb entry to eliminate that worst-case performance,
      repeating the process until some desired absolute worst-case is achieved
      or the worst-case performance point cannot be eliminated by reducing
      factor2.
   When factor2 reduction is no longer able to eliminate a worst-case
      performance point, factor1 may be reduced to eliminate the worst-case
      performance point. This may be repeated (after first trying factor2!)
      until a desired absolute worst-case performance point is reached, no
      further improvement can be obtained using factor2 and factor1, or the
      elimination of a worst-case performance point entails too large of a
      performance penalty for random input sequences.
   The "disabled" and "transparent" repivot table factor1 and factor2 entries
      for 243 and fewer samples are set such that repivoting 'never' occurs for
      random input sequences for different variations of 'never', where 'never'
      represents some very low probability.
   The "loose" table entries are set to achieve a worst-case sorting comparison
      complexity of <= 2.0 N log(N) comparisons without further affecting random
      input sequences.
   The "relaxed" table entries are set to achieve the minimum comparison
      complexities possible for sorting using primarily factor2, and only
      decreasing factor1 when absolutely necessary.
   The "aggressive" table entries use both factors as far as possible (i.e.
      until some worst-case performance point cannot be eliminated or the
      performance penalty becomes too great).
*/
/* repivot factors are relatively small unsigned integers */

/* sorting repivot tables */
struct repivot_table_struct sorting_repivot_table_transparent[] = {
  /* 3 */ { 255U,  38U }, /* sorting transparent */ /* median-of-3 */
  /* 9 */ { 255U,  40U }, /* sorting transparent */ /* remedian of samples */
 /* 27 */ { 255U,  14U }, /* sorting transparent */
 /* 81 */ { 255U,   5U }, /* sorting transparent */
/* 243 */ { 255U,   3U }, /* sorting transparent */
/* 729 */ { 255U,   3U }, /* sorting transparent */
};
struct repivot_table_struct sorting_repivot_table_loose[] = {
  /* 3 */ { 255U,  17U }, /* sorting loose */ /* median-of-3 */
  /* 9 */ { 255U,  26U }, /* sorting loose */ /* remedian of samples */
 /* 27 */ { 255U,  14U }, /* sorting loose */
 /* 81 */ { 255U,   5U }, /* sorting loose */
/* 243 */ { 255U,   3U }, /* sorting loose */
/* 729 */ { 255U,   3U }, /* sorting loose */
};
struct repivot_table_struct sorting_repivot_table_relaxed[] = {
  /* 3 */ { 255U,  10U }, /* sorting relaxed */ /* median-of-3 */
  /* 9 */ { 255U,  19U }, /* sorting relaxed */ /* remedian of samples */
 /* 27 */ { 255U,  14U }, /* sorting relaxed */
 /* 81 */ { 255U,   5U }, /* sorting relaxed */
/* 243 */ { 255U,   3U }, /* sorting relaxed */
/* 729 */ { 255U,   3U }, /* sorting relaxed */
};
struct repivot_table_struct sorting_repivot_table_aggressive[] = {
  /* 3 */ {   9U,   9U }, /* sorting aggressive */ /* median-of-3 */
  /* 9 */ {  19U,  18U }, /* sorting aggressive */ /* remedian of samples */
 /* 27 */ {  15U,  14U }, /* sorting aggressive */
 /* 81 */ {   6U,   5U }, /* sorting aggressive */
/* 243 */ {   3U,   3U }, /* sorting aggressive */
/* 729 */ {   3U,   3U }, /* sorting aggressive */
};
struct repivot_table_struct sorting_repivot_table_disabled[] = {
  /* 3 */ { 255U, 255U }, /* disabled */
  /* 9 */ { 255U, 255U }, /* disabled */
 /* 27 */ { 255U, 255U }, /* disabled */
 /* 81 */ { 255U, 255U }, /* disabled */
/* 243 */ { 255U, 255U }, /* disabled */
/* 729 */ { 255U, 255U }, /* disabled */
};

struct repivot_table_struct *sorting_repivot_table =
#if SORTING_TABLE_ENTRIES == TRANSPARENT
    sorting_repivot_table_transparent
#elif SORTING_TABLE_ENTRIES == LOOSE
    sorting_repivot_table_loose
#elif SORTING_TABLE_ENTRIES == RELAXED
    sorting_repivot_table_relaxed
#elif SORTING_TABLE_ENTRIES == AGGRESSIVE
    sorting_repivot_table_aggressive
#else
    sorting_repivot_table_disabled
#endif
;

/* selection repivot table; always very aggressive due to the much greater
   sensitivity of selection performance to lopsided partitions.
*/
struct repivot_table_struct selection_repivot_table[] = {
  /* 3 */ {   8U,   8U }, /* selection aggressive */ /* median-of-3 */
  /* 9 */ {  19U,   7U }, /* selection aggressive */ /* remedian of samples */
 /* 27 */ {  15U,  14U }, /* selection aggressive */
 /* 81 */ {   6U,   5U }, /* selection aggressive */
/* 243 */ {   3U,   3U }, /* selection aggressive */
/* 729 */ {   3U,   3U }, /* selection aggressive */
};

/* All repivot tables have the same size. */
const size_t repivot_table_size
    = sizeof(selection_repivot_table)/sizeof(selection_repivot_table[0]);
