/*INDENT OFF*/

/* Description: C source code for quickselect */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    quickselect.c copyright 2016-2017 Bruce Lilly.   \ quickselect.c $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is quickselect.c version 1.55 dated 2017-02-08T09:30:17Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/src/s.quickselect.c */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and an internal stack is used to handle
 processing of subarrays resulting from partitioning.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size limited to the
 logarithm of the array size with a configurable base of 7 or greater. The
 cumulative number of comparisons (assuming the ideal case of perfectly balanced
 partitioning) is then lower than for use of Tukey's "ninther" as used in
 Bentley & McIlroy's qsort ("Engineering a Sort Function").
 Moreover, the comparisons are better distributed among the various
 subarray sizes, with the sample size increasing for larger arrays, and an
 improved (and O (log(N)) rather than O(1)) guarantee of pivot rank.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe).
 Partitioning uses a method described by Bentley & McIlroy.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.  
 Partitioning can still result in an unfavorable split of the initial subarray;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by an efficient inline general-purpose swap
 function.  No attempt is made to optimize for particular array element types.
 The swap function avoids useless work (e.g. when given two pointers to the
 same element).  No specialized macros are required; the swap function requires
 no initialization.
******************************************************************************/

/* compile-time configuration options */
#define ASSERT_CODE                 0    /* adds size and cost to aid debugging. 0 for tested production code. */

/* quick settings to approximate Bentley&McIlroy qsort */
#define SIMULATE_BM                 0
#if SIMULATE_BM
# undef ASSERT_CODE
# define ASSERT_CODE                0
# define INSERTION_CUTOFF           6UL /* equivalent to B&M 7 */
# define BUILD_NOTES                "simulation of B&M"
# define NINTHER_CUTOFF             40UL /* B&M */
// # define M3_CUTOFF                  8 /* ONLY for poor performance! (like B&M) */
#endif

/* analysis at small N indicates an INSERTION_CUTOFF of 6 or perhaps a little higher is optimal */
#ifndef INSERTION_CUTOFF
# define INSERTION_CUTOFF           6UL /* use insertion sort for sorting arrays of this size or smaller */ /* best */ /* like B&M 7 */
// # define INSERTION_CUTOFF            7UL /* use insertion sort for sorting arrays of this size or smaller */ /* good */
#endif

/* SAMPLE_BASE (specific to remedian of samples pivot selection) */
/* suggested values: 7, 8, 9; 8 is optimum */
#define SAMPLE_BASE                 8UL

/* cutoff for transition from singleton to median-of-3 pivot selection */
/* Switch from organ-pipe-preferred (1/4 sample)
   to median-of-3 (1/4,1/2,3/4) for nmemb>=M3_CUTOFF.
     11 128Ki integers 1.00499 random, 2.01765@34 pk adversary
     12 128Ki integers 1.00501 random, 1.98841@33 pk adversary
     13 128Ki integers 1.00474 random, 1.98841@33 pk adversary
     14 128Ki integers 1.00479 random, 1.97038@33 pk adversary
     15 128Ki integers 1.00469 random, 1.97038@33 pk adversary
     16 128Ki integers 1.00471 random, 1.95236@33 pk adversary
     17 128Ki integers 1.00489 random, 1.95236@33 pk adversary
     18 128Ki integers 1.00499 random, 1.93434@33 pk adversary
   11 gives better performance for sorted input than Bentley & McIlroy qsort,
      but other input sequences (especially randomized ones) fare poorly due
      to the increased number of comparisons for median-of-3 for every small
      subarray resulting from partitions.
   13-16 gives reasonable performance for randomized input sequences, though
      performance for already-sorted input is a bit slower than Bentley &
      McIroy's qsort.
*/
#ifndef M3_CUTOFF
# define M3_CUTOFF                  15UL /* optimum 13-16 */
#endif /* M3_CUTOFF */

/* Repivoting parameters REPIVOT_FACTOR and REPIVOT_CUTOFF:
   Subarrays with more than REPIVOT_CUTOFF elements are checked for a large
   region which is more than (REPIVOT_FACTOR-1)/REPIVOT_FACTOR times the
   total number of elements in the subarray.
   To avoid integer overflow, the number of elements in the large region is
   divided by REPIVOT_FACTOR for comparison (bit shifts are used for
   REPIVOT_FACTOR at powers of 2).
   Median-of-3 pivot selection guarantees at least 1 element in the small
   region.  That plus the pivot guarantees that the large region has at most
   nmemb-2 elements.
   Therefore, as long as REPIVOT_CUTOFF is greater than M3_CUTOFF (and it
   should be), REPIVOT_CUTOFF should be at least REPIVOT_FACTOR+2 to avoid
   unnecessary division and comparison.
   Small REPIVOT_FACTOR (e.g. 13UL) keeps adverse inputs from requiring
   excessive comparisons due to poor partition splits, but causes extra
   comparisons for random inputs due to an occasional lopsided partition.
   Large REPIVOT_FACTOR (e.g. 64UL) allows adverse inputs to require many
   comparisons to resolve marginally poor (not bad enough to repivot)
   partition splits, but has negligible effect on random sequences which
   rarely have extremely lopsided partitions.
   Examples for REPIVOT_FACTOR,REPIVOT_CUTOFF at M3_CUTOFF=15, SAMPLE_BASE=8:
       13,27 128Ki integers 1.0069 random, 1.72743@91 pk adversary
       14,18 128Ki integers 1.0075 random, 1.67508@91 pk adversary
       14,19 128Ki integers 1.0073 random, 1.66495@91 pk adversary
       14,20 128Ki integers 1.0072 random, 1.66495@91 pk adversary
       14,21 128Ki integers 1.0070 random, 1.66495@91 pk adversary
       14,24 128Ki integers 1.0068 random, 1.66495@91 pk adversary
       14,27 128Ki integers 1.0061 random, 1.66495@91 pk adversary
       15,27 128Ki integers 1.0059 random, 1.66495@91 pk adversary
       16,18 128Ki integers 1.0067 random, 1.67508@19 pk adversary
       16,19 128Ki integers 1.0068 random, 1.66495@91 pk adversary
       16,24 128Ki integers 1.0062 random, 1.66495@91 pk adversary
       16,25 128Ki integers 1.0062 random, 1.66495@91 pk adversary
       16,26 128Ki integers 1.0059 random, 1.66495@91 pk adversary
       16,27 128Ki integers 1.0059 random, 1.66495@91 pk adversary
       16,28 128Ki integers 1.0058 random, 1.737@27 pk adversary
       17,34 128Ki integers 1.0052 random, 1.97038@33 pk adversary
       21,32 128Ki integers 1.0048 random, 1.89478@31 pk adversary
       21,34 128Ki integers 1.0047 random, 1.97038@33 pk adversary
       32,34 128Ki integers 1.0044 random, 1.97038@33 pk adversary
       32,35 128Ki integers 1.0041 random, 1.98296@34 pk adversary
       32,36 128Ki integers 1.0041 random, 2.04428@35 pk adversary
       32,39 128Ki integers 1.0042 random, 2.13117@38 pk adversary
       huge  128Ki integers 1.0037 random
*/
#ifndef REPIVOT_FACTOR
# define REPIVOT_FACTOR             16UL
#endif
#ifndef REPIVOT_CUTOFF
# define REPIVOT_CUTOFF             27UL
#endif

/* Nothing to configure below this line. */

/* sanity checks */
#if SAMPLE_BASE
# if SAMPLE_BASE < 7UL
#  error SAMPLING_TABLE_SIZE will be too small
# endif
#endif

/* defaults */
#if ! M3_CUTOFF
# ifdef M3_CUTOFF
#  undef M3_CUTOFF
# endif
# define M3_CUTOFF                   15UL
#endif
#if ! SAMPLE_BASE
# ifdef SAMPLE_BASE
#  undef SAMPLE_BASE
# endif
# define SAMPLE_BASE                 8UL
#endif
#if ! REPIVOT_FACTOR
# ifdef REPIVOT_FACTOR
#  undef REPIVOT_FACTOR
#  define REPIVOT_FACTOR             16UL
# endif
#endif
#if ! REPIVOT_CUTOFF
# ifdef REPIVOT_CUTOFF
#  undef REPIVOT_CUTOFF
#  define REPIVOT_CUTOFF             27UL
# endif
#endif

/* graph generation for paper */
#ifndef M3_GRAPH
# define M3_GRAPH                    0    /* non-zero to plot effect of M3_CUTOFF */
#endif
#if M3_GRAPH
# undef M3_CUTOFF
# define M3_CUTOFF                   M3_GRAPH
#endif

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* Minimum _XOPEN_SOURCE version for C99 (else compilers on illumos have a tantrum) */
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
# define MIN_XOPEN_SOURCE_VERSION 600
#else
# define MIN_XOPEN_SOURCE_VERSION 500
#endif

/* feature test macros defined before any header files are included */
#ifndef _XOPEN_SOURCE
# define _XOPEN_SOURCE 600  /* code uses C99 'inline', XOPEN 'LONG_BIT' */
#endif
#if defined(_XOPEN_SOURCE) && ( _XOPEN_SOURCE < MIN_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components are version control fields */
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: quickselect.c ~|^` @(#)"
#define SOURCE_MODULE "quickselect.c"
#define MODULE_VERSION "1.55"
#define MODULE_DATE "2017-02-08T09:30:17Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
/* Although the implementation is different, several concepts are adapted from:
   qsort -- qsort interface implemented by faster quicksort.
   J. L. Bentley and M. D. McIlroy, SPE 23 (1993) 1249-1265.
   Copyright 1993, John Wiley.
*/
#define COPYRIGHT_DATE "2016-2017"

/* local header files needed */
#include "quickselect.h"        /* quickselect QSORT_FUNCTION_NAME */
#include "zz_build_str.h"       /* build_id build_strings_registered copyright_id register_build_strings */

#include <sys/types.h>          /* *_t */
#include <assert.h>             /* assert */
#include <errno.h>              /* errno E* */
#include <limits.h>             /* *_MAX */
#include <stddef.h>             /* NULL */
#if ASSERT_CODE
#include <stdio.h>              /* fprintf stderr */
#endif /* ASSERT_CODE */
#include <string.h>             /* strrchr */

/* macros */
/* Shared stack and array LONG_BIT is enough for the stack, 3 is sufficient for
   the array, 8 is generous.
*/
#undef NREGIONS
#define NREGIONS (LONG_BIT)+8

/* space-saving */
#undef V
#define V void
#undef A
#define A(me) assert(me)

/* stringification (don't change!) */
#undef xbuildstr
#define xbuildstr(s) buildstr(s)
#undef buildstr
#define buildstr(s) #s

/* static data (for version tracking for debugging/error reports) */
static char quickselect_initialized=(char)0;
static const char *filenamebuf= __FILE__ ;
static const char *source_file= NULL;
const char *quickselect_build_options="@(#)quickselect.c: "
    "built with configuration options: "
    "ASSERT_CODE=" xbuildstr(ASSERT_CODE)
#ifdef BUILD_NOTES
    ", BUILD_NOTES=" BUILD_NOTES
#endif
#ifdef INSERTION_CUTOFF
    ", INSERTION_CUTOFF=" xbuildstr(INSERTION_CUTOFF)
#endif
#if M3_CUTOFF
    ", M3_CUTOFF=" xbuildstr(M3_CUTOFF)
#endif
#if M3_GRAPH
    ", M3_GRAPH=" xbuildstr(M3_GRAPH)
#endif
#if REPIVOT_FACTOR
    ", REPIVOT_FACTOR=" xbuildstr(REPIVOT_FACTOR)
#endif
#if REPIVOT_CUTOFF
    ", REPIVOT_CUTOFF=" xbuildstr(REPIVOT_CUTOFF)
#endif
#ifdef SAMPLE_BASE
    ", SAMPLE_BASE=" xbuildstr(SAMPLE_BASE)
#endif
    ;

/* data structures */

/* Region (resulting from partitioning) information is stored in an array of
   structures.  This might seem like overkill (it does increase object code size
   somewhat), but it makes for simpler, more compact, more easily understood and
   maintained source code, and is easily extensible (e.g. for handling the
   additional regions resulting from multiple pivots).
   The same structure is used in the implementation of a program stack, without
   which an additional function parameter would be required so that order
   statistic ranks could be correlated with array item positions.
   The partitioning regions and the program stack share a common array.
*/
struct region_struct {
    char   *p;  /* pointer to the start of the (sub)array */
    size_t n;   /* number of (sub)array elements */
    /* n may be set to 0UL to indicate no processing */
};

/* To avoid repeatedly calculating the number of samples required vs. nmemb,
   which is expensive, a table is generated (lazily); then determining the
   number of samples simply requires a search of the (small) table.
*/
struct sampling_table_struct {
    size_t min_nmemb;
    size_t samples;
};
/* 24 entries is sufficient for SAMPLE_BASE>=7, 64-bit size_t */
#define SAMPLING_TABLE_SIZE 24
static struct sampling_table_struct sampling_table[SAMPLING_TABLE_SIZE];
static unsigned char sampling_table_initialized=0U;
/* first entry will be 1,1
   second entry will be (M3_CUTOFF),3
   third entry will be SAMPLE_BASE^2,9
   subsequent entries have min_nmemb SAMPLE_BASE * previous entry,
       samples 3* previous entry
   E.g. for M3_CUTOFF=15, SAMPLE_BASE=8
     1      1
     15     3
     64     9
     512   27
     4096  81 etc.
   The static table is shared; once set, entries never change (sampling
   base and median-of-3 cutoff are compile-time settings).
*/

/* assume sizeof(foo) etc. are powers of 2 */
/* logarithms of two for index as sizeof */
/* table in lieu of calculation for speed */
/* valid up to sizeof(foo) = 32 */
static const
int log2s[]={0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5};
/* Type sizes. It is assumed that sizeof(double)>=sizeof(char *)... */
static const size_t typsz[6] = {
    sizeof(double),sizeof(char *),sizeof(long),sizeof(int),sizeof(short),1UL
};
/* mask off low-order bits */
static const unsigned long bitmask[6] = {
    0x0UL, 0x01UL, 0x03UL, 0x07UL, 0x0fUL, 0x01fUL
};

#define is_aligned(var,shift) (0U==(((unsigned long)(var))&bitmask[(shift)]))

/* forward declarations */
static inline void quickselect_internal(void *base, size_t nmemb,
    const size_t size, int (*compar)(const void *,const void *),
    const size_t *pk, const size_t nk
    );

/* static functions */

/* initialization of static strings at run-time */
static inline void initialize_quickselect(V)
{
    size_t q;
    const char *s;

    /* Initialize sampling_table if necessary */
    if (0U==sampling_table_initialized) {
        for (q=3UL; q<SAMPLING_TABLE_SIZE; q++)
            sampling_table[q].min_nmemb=0UL;
        sampling_table[0].min_nmemb=1UL;
        sampling_table[0].samples=1UL; /* 1,1 */
        sampling_table[1].min_nmemb=(M3_CUTOFF);
        sampling_table[1].samples=3UL; /* M3_CUTOFF,3 */
        sampling_table[2].min_nmemb=SAMPLE_BASE*SAMPLE_BASE;
        sampling_table[2].samples=9UL; /* SAMPLE_BASE^2,9 */
        sampling_table_initialized=1U;
    }
    s=strrchr(filenamebuf,'/');
    if (NULL==s) s=filenamebuf; else s++;
    quickselect_initialized=register_build_strings(quickselect_build_options,
        &source_file,s);
}

/* array element swaps */
/* called many times from quickslect_internal, medians3 */
static inline void swap(char *pa, char *pb, size_t bytes, int swaptype)
{
    if (pa!=pb) { /* else nothing to do */
        if (5==swaptype) { /* char */
            for (;0UL<bytes; pa++,pb++,bytes--) {
                char t = *pa;
                *pa=*pb, *pb=t;
            }
        } else {
            size_t s=typsz[swaptype]; /* chars */
            A(bytes>=s);A(0==bytes%s);
            switch (swaptype) {
                case 0 : /* double */
                    for (;0UL<bytes; pa+=s,pb+=s,bytes-=s) {
                        double t = *((double *)pa);
                        *((double *)pa)=*((double *)pb), *((double *)pb)=t;
                    }
                break;
                case 3 : /* int */
                    for (;0UL<bytes; pa+=s,pb+=s,bytes-=s) {
                        int t = *((int *)pa);
                        *((int *)pa)=*((int *)pb), *((int *)pb)=t;
                    }
                break;
                case 4 : /* short */
                    for (;0UL<bytes; pa+=s,pb+=s,bytes-=s) {
                        short t = *((short *)pa);
                        *((short *)pa)=*((short *)pb), *((short *)pb)=t;
                    }
                break;
            }
        }
    }
}

/* region manipulation */

/* Compute the effective size (as count of elements) of a region.  The size is
   zero if there is only a single element or if the region is not needed to find
   requested order statistics.
   N.B. argument pu points past the last element in the region.
*/
/* pk[k] is the 0-based rank of an array element, based on the full array
   (origin has been saved in pointer po).  The entire pk array is scanned for
   each region unless/until an order statistic is found that requires processing
   the region.  Therefore, neither uniqueness nor order are required of the
   order statistic values in the pk array.
*/
/* If the elements of pk were in sorted order, binary search would be possible,
   but linear search is faster for reasonable numbers of order statistics
   (<= 100).  A large number of order statistics is not expected.  Also, if the
   elements of pk were in sorted order, linear search could be conducted over a
   limited range, and the range of indices into pk could be restricted for
   processing sub-arrays of the base array.  It is simplest (both for the caller
   and for the implementation code) not to impose any ordering requirement on
   the values in array pk.  The linear search terminates early if some rank
   may reside in a region.
*/
/* called twice from partition() */
static inline size_t effective_size(char *pl, char *pu, char *po,
    const size_t size, const size_t *pk, const size_t nk)
{
    size_t n=0UL;

    if (pu>pl) {
        n=(pu-pl)/size; /* # elements */
        if (NULL!=pk) {/* selection: is region required? */
            size_t i, bigrank, minrank;

            /* Smallest ranks in region and just beyond. */
            minrank=(pl-po)/size, bigrank=(pu-po)/size;
            /* Loop through requested order statistics, break if/when an order
               statistic in region is requested.
            */
            for (i=0UL; (i<nk)&&((pk[i]<minrank)||(pk[i]>=bigrank)); i++)
                ;
            if (i>=nk) n=0UL; /* no requested rank in region */
        }
    }
    return n;
}

/* medians of sets of 3 elements */
/* Given base, size, and compar as for qsort, plus a row offset and sample
   offset, both in chars, find medians of sets of 3 elements where the three
   elements for each median are taken from three rows starting with base, and
   each subsequent set of three elements is offset from the previous set by
   sample_offset. As each median is determined, it is placed in the position of
   the middle element of the set.
   The return value is a pointer to the first median (which has been moved as
   described above).
   N.B. base is not necessarily the first element in the array passed to qsort.
*/
/* called three times from partition() */
static inline char *medians3(char *base, size_t size,
    int(*compar)(const void *, const void *), size_t row_offset,
    size_t sample_offset, size_t row_samples, int swaptype)
{
    int c;
    char *pa, *pb;
    size_t n, o;

    for (n=o=0UL; n<row_samples; n++,o+=sample_offset) {
        pa=base+o;
        pb=pa+row_offset; /* middle element */
        /* Optimized ternary median-of-3: 1-3 comparisons.
           Minimum number of comparisons (because in the qsort model (external
           function for comparison), comparisons are expensive).  If any two
           elements (of the 3) compare equal, either can be chosen for the
           median (the value is the median of the 3, regardless of the value of
           the third element).  Likewise, the median may be determined by the
           first two comparisons, e.g. a < b and b < c.  In the worst case, 3
           comparisons are required. The median element is swapped to the middle
           position.
        */
        c=compar(pa,pb);
        if (0!=c) {
            char *pc=pb+row_offset;
            int d=compar(pb,pc);
            if (0!=d) {
                if ((0<d)&&(0>c)) {
                    if (0>compar(pa,pc)) swap(pb,pc,size,swaptype);
                    else swap(pa,pb,size,swaptype);
                } else if ((0>d)&&(0<c)) {
                    if (0<compar(pa,pc)) swap(pb,pc,size,swaptype);
                    else swap(pa,pb,size,swaptype);
                }
            }
        }
    }
    return base+row_offset; /* middle row */
}

/* array partitioning */

/* Set *pbig to the size of the larger region (in elements).  If the
   (N.B.) effective size of the smaller region is more than one, add it to the
   list of regions.  If the larger region does not need to be repivoted, also
   add it to the list of regions and return 0.  But if the larger region does
   need to be repivoted, set pointer pointed to be ppb to the start of the
   larger region and return 1.
   plg and slg are start and size (chars) of the large region; psm, ssm for
   the small region.
*/
/* called twice from examine_regions() */
static inline int process_regions(char *plg, size_t slg, char *psm,
    size_t ssm, size_t nmemb, const size_t size, char *po, const size_t *pk,
    const size_t nk, char **ppb, size_t *pbig, struct region_struct *pr,
    int *pnr, int ns)
{
    int t;
    size_t n;

    *pbig=slg/size; /* large region elements */
    /* maybe add small region to regions list */
    n=effective_size(psm,psm+ssm,po,size,pk,nk);
    if (1UL<n) {
        t=ns+*pnr; pr[t].p=psm, pr[t].n=n; ++*pnr;
    }
    /* process large region */
    n=effective_size(plg,plg+slg,po,size,pk,nk);
    if (1UL<n) {
        /* Determine whether or not to repivot/repartition region of size n
           elements (large region) resulting from a partition of nmemb elements.
           Assumed that continued processing of the region w/o repivoting will
           yield a similar split.  Repivot if the cost of repivoting plus
           processing the resulting regions is expected to be less than the cost
           of processing the region w/o repivoting.  Tuning parameters used here
           are defined near the top of this file.
        */
        if ( ((REPIVOT_CUTOFF)<=nmemb)
          && (
#if REPIVOT_FACTOR == 16UL
              (n>>4)
#elif REPIVOT_FACTOR == 32UL
              (n>>5)
#elif REPIVOT_FACTOR == 64UL
              (n>>6)
#else
              (n/(REPIVOT_FACTOR))
#endif
                              >=nmemb-n-1UL)
        ) { /* repivot large region */
            *ppb=plg; return 1;
        } else {
            t=ns+*pnr; pr[t].p=plg, pr[t].n=n; ++*pnr;
        }
    }
    return 0;
}

/* quickselect definition (internal interface) */
static inline void quickselect_internal(void *base, size_t nmemb,
    const size_t size, int (*compar)(const void *,const void *),
    const size_t *pk, const size_t nk
   )
{
    char *pl;  /* left (or lowest) end of array being processed */
    char *po;  /* origin of array (maintained so that ranks can be computed) */
    int top=0; /* stack: regions[0..top-1], partition regions above stack */
    int swaptype; /* index into array of type sizes for swapping size */
    size_t s;  /* general size_t variable */

    if (2UL>nmemb) return; /* Return early if there's nothing to do. */

    /* Save the original pointer to the start of the (entire) array, so that
       element ranks can be determined for selection.  Also initialize the
       character pointer pl to the start (left side) of the array.  And save
       the original number of elements so that the original end of the array
       can be recomputed.
    */
    pl=po=(char *)base;

    /* Determine size of data chunks to copy for element swapping.  Size is
       determined by element size and alignment. swaptype is an index into an
       array of type sizes (double, pointer, long, int, short, char).
    */
    s=typsz[swaptype=0]; /* double */
    if ((size<s)||(!(is_aligned(base,log2s[s])))) {
        s=typsz[swaptype=3]; /* int */
        if ((size<s)||(!(is_aligned(base,log2s[s])))) {
            s=typsz[swaptype=4]; /* short */
            if ((size<s)||(!(is_aligned(base,log2s[s])))) {
                swaptype=5; /* char */
            }
        }
    }

    /* Outer processing loop: process regions on the stack */
    /* When there is nothing left to do in the inner loop, the outer processing
       loop pops a pointer and size from the stack of regions to be processed
       unless the stack is empty, in which case the sort or selection is
       complete.
    */
    while (1) { /* stack-not-empty loop: break out when stack is empty */
        struct region_struct regions[(NREGIONS)], *pr;
        int nregions;       /* number of partition regions above stack */

        /* The inner processing loop iterates while there is a region of size
           2 or greater to be processed (regions of size 1 are by definition
           already sorted).
        */
        for (nregions=0; 1UL<nmemb;) { /* current region iteration loop */
            int c, d, i, j;              /* general integer variables */
            char *pa, *pb, *pc, *pd, *pe, *pf, *pivot, *pu;
            size_t n, p, q, r, t;

            if ((NULL==pk) /* sorting only */
            && (nmemb<=(INSERTION_CUTOFF))) {
                /* Handle small regions with insertion sort. */
                /* At the end of insertion sort, break out of the inner loop. */
                for (pa=pl,pu=pl+(nmemb-1UL)*size; pa<pu; pa+=size)
                    for (pb=pa; (pb>=pl)&&(0<compar(pb,pc=pb+size)); pb-=size)
                        swap(pb,pc,size,swaptype);
        /* <- */break; /* Done; break out of inner loop, check stack. */
            }

            /* Partition the array into <, =, and > regions. */
            /* Modified (for fast_pivot initialization, deferred pivot swap,
               cache-friendly comparison, good_pivot break-glass, swap2,
               final blockmoves) Bentley&McIlroy "split end" partition.
            */
            /* Initially: */
            /* +-------------------------------------------------------------+ */
            /* |                              ?                              | */
            /* +-------------------------------------------------------------+ */
            /*  a                                                             e*/
            /*  b                                                             f*/
            /*  c                                                             u*/
            /* Invariant pointer pl -> first [sub-]array element.    */
            /* = elements (by comparison to pivot) are in a region on the left,
                  delimited by pl (first element) and pb (past last element.
            */
            /* Elements comparing small vs. pivot are in region delimited by pb
                  (first element) and pc (past last element).
            */
            /* Unknown region delimited by pc (first element) and pe (past last
                  element.  pb<=pc (always; they are equal if there are no ?
                  elements)
            */
            /* Elements comparing large vs. pivot are in region [pe,pf).
                  Pointer pu points past the last element.
            */
            /* A second = region is [pf,pu).                                  */
            /* Pointer pd may be used to scan from pc or pe into the unknown
                  region.  pc<=pd<=pe
            */
            /* After the optimized inner loops, pointer pe is a pointer
               to the start of the > region rather than the end of the unknown
               region; this is to facilitate calls to blockmove
            */
            /* +-------------------------------------------------------------+ */
            /* |     =  |      <      | = |    ?      | = |    >    |   =    | */
            /* +-------------------------------------------------------------+ */
            /*  pl     a b             c   d   or    d   E e         f        u*/
            /* Upper and lower diagram lines henceforth omitted for brevity. */
            /* select a pivot element using a fast method w/ only poor rank guarantee */
            /* adaptive pivot selection: remedian of samples, ninther, median-of-3,
               singleton.  The number of samples depends on array size and sampling base
               for remedian of samples.
            */
            /* Determine how many samples to take from the array for pivot selection. */
            /* Find sampling_table entry appropriate for array size. Lazy table update.
            */
            for (r=sampling_table[q=0UL].samples; q<SAMPLING_TABLE_SIZE; q++) {
            /* simulation stuff is for generating data for graphs for companion paper */
#if SIMULATE_BM
                p=r;
#endif /* SIMULATE_BM */
                n=sampling_table[q].min_nmemb;
                if (0UL==n) { /* lazy update */
                    n=sampling_table[q-1U].min_nmemb;
                    if ((ULONG_MAX)/SAMPLE_BASE<n) /* avoid overflow */
                        n=sampling_table[q].min_nmemb=(ULONG_MAX);
                    else {
                        n*=SAMPLE_BASE;
                        sampling_table[q].min_nmemb=n;
                    }
                    r*=3UL;
                    sampling_table[q].samples=r;
                } else r=sampling_table[q].samples;
                if (nmemb<n) { /* stop looking in table */
#if SIMULATE_BM
                    /* nmemb < n ; use p samples */
                    /* special-cases for BL_ADAPTIVE: ninther above NINTHER_CUTOFF
                    */
                    if ((9UL!=p)&&((NINTHER_CUTOFF)<nmemb)) q=3UL,p=9UL;
#endif /* SIMULATE_BM */
                    break;
                }
            }
            if (0UL<q) q--; /* sampling table index */
            n=sampling_table[q].samples; /* total samples (a power of 3) */
            /* Samples uniformly spaced in rows (which are also uniformly spaced), but
               N.B. sample spacing from the end of one row to the first sample on the
               next row is NOT necessarily the same as sample spacing within a row.
               Always 3 rows. Set s to chars sample spacing within rows. Set r to row
               spacing in chars.
            */
            if (1UL==n) {
                pivot=pl+(nmemb>>2)*size; /* best for organ-pipe, reasonable for others */
                s=r=0UL;
#if ASSERT_CODE
                t=n;
#endif /* ASSERT_CODE */
            } else {
                t = n/3UL;                               /* samples per row */
                if (0UL<t) s=(p=nmemb>>2)/t; else s=0UL; /* sample spacing (elements) */
                if (1UL>=t) r=((nmemb+2UL)>>2); else r=p+s; /* row spacing (elements) */
                s*=size, r*=size;                        /* spacing in chars */
                pivot=pl+size*(nmemb>>1)                 /* middle element */
                    -r                                   /* now middle of first row */
                    -(t>>1)*s;                           /* minus half samples/row */
            }
#if ASSERT_CODE
            A(pl<=pivot);A(pivot<pl+nmemb*size); /* p is in the array */
            /* assertion below asserts that last sample < pu
               i.e. pl+(r<<1)*(t-1UL)*s<pl+nmemb*size
            */
            if (0UL!=t); A((r<<1)+(t-1UL)*s<nmemb*size);
#endif /* ASSERT_CODE */
            /* Select a pivot element from the array samples */
            if (1UL<n) { /* median or remedian of (at least 3) samples */
                /* First stage may have r!=3*s */
                n=sampling_table[--q].samples;
                pivot=medians3(pivot,size,compar,r,s,n,swaptype);
                /* remaining stages start with r=s*n, then r/=3 */
                /* loop control using sampling_table sample sizes */
                while (0UL<q) {
                    n=sampling_table[--q].samples;
                    /* For each set of 3 samples, set one element to the median of
                       the set. medians3 returns a pointer to the first element of
                       the resulting set of medians, which are uniformly offset by
                       the sample spacing s.
                    */
                    pivot=medians3(pivot,size,compar,n*s,s,n,swaptype);
                    /* Repeat for the samples in the medians row (i.e. the medians
                       of this group of sets) until only a single median remains
                       (i.e. row spacing < sample spacing). That final median (the
                       pivot element) is located at pivot.
                    */
                }
            }
            pe=(pf=pu=(pa=pb=pc=pl)+nmemb*size)-size;
            /* Partitioning per se. */
            /* NO disorder-causing swap of pivot initially */
            while (1) { /* outer loop: repivot/repartition until satisfactory */
                while (1) { /* middle loop - partitioning */
                    /* pivot updated when swapped */
                    while ((pc<=pe)&&(0<=(c=compar(pivot,pc)))) { /* scan up from pc */
                        if (c==0) { swap(pivot=pb,pc,size,swaptype); pb+=size; }
                        pc+=size;
                    }
                    while ((pc<=pe)&&(0>=(d=compar(pivot,pe)))) { /* scan <- from pe */
                        if (d==0) { pf-=size; swap(pe,pivot=pf,size,swaptype); }
                        pe-=size;
                    }
                    if (pc>pe) break;
                    swap(pc,pe,size,swaptype); /* <, > */
                    pc+=size; pe-=size;
                }
                pe+=size; /* now start of > region */
                /* |     =  |      <               |               >    |   =    | */
                /*  pl     a b                      c=e                  f        u*/
                /* swap > and upper = regions, set pd to start of > */
                if (pf<pu) { /* pd= original pe if pf>=pu */
                    if (pe<pf) { /* pd= original pu if pf>=pe */
                        p=pu-pf, n=pf-pe; if (p<n) n=p;
                        swap(pe,pu-n,n,swaptype); pd=pe+p;
                    } else pd=pu;
                } else pd=pe;
                /* |     =  |      <               |        =      |      >      | */
                /*  pl     a b                      c=e             d             u*/
                /* swap left = and < regions */
                if (pb<pe) { /* pb= original pl if pb>=pe */
                    if (pl<pb) { /* pb= original pc if pb>=pa */
                        p=pe-pb, n=pb-pl; if (p<n) n=p;
                        swap(pl,pe-n,n,swaptype); pb=pl+p;
                    } else pb=pe;
                } else pb=pl;
                /* |        <            |            =            |      >      | */
                /*  pl                    b                         d             u*/
                /* Examine sizes of < and > regions and determine whether to repivot. */
                q=pb-pl; /* size of the < region, in chars */
                r=pu-pd;  /* size of the > region, in chars */
                if ((q)<(r)) /* > region is larger */
                    d=process_regions(pd,r,pl,q,nmemb,size,po,pk,nk,&pl,&n,
                        regions,&nregions, top);
                else /* < region is larger, or regions are the same size */
                    d=process_regions(pl,q,pd,r,nmemb,size,po,pk,nk,&pl,&n,
                        regions,&nregions, top);
                if (0==d) break; /* repivot not required */
                /* repivot/repartition large region w/ pl, n from examine_regions */
                /* |        <            |            =            |      >      | */
                /*  pl                    b                         d             u*/
                /* Finding a pivot with guaranteed intermediate rank. Ideally, median
                   (50%).  Blum, Floyd, Pratt, Rivest, Tarjan median-of-medians using
                   sets of 5 elements with recursion guarantees rank in (asymptotically)
                   30-70% range, often better; can guarantee linear median-finding,
                   N log(N) sorting. Simplification ignores "leftover" elements with a
                   slight increase in rank range.  Non-recursive method (using separate
                   linear median finding) can use sets of 3 elements to provide a
                   tighter 33.33% to 66.67% range (again, slightly wider if "leftover"
                   elements are ignored) at lower computational cost.
                */
                nmemb=n; pivot=pl;
                n/=3UL;    /* number of complete sets */
                if (1UL<=n)
                    pivot=medians3(pl,size,compar,n*size,size,n,swaptype);
                if (1UL<n) { /* median of medians */
                    size_t karray[1];
                    karray[0]=n>>1; /* upper-median for even size arrays */
                    quickselect_internal(pivot,n,size,compar,karray,1UL);
                    pivot+=karray[0]*size; /* pointer to median */
                }
                /* |   ?   : < :=p=: > :   ?   | */
                /*          a   b   c   d       u*/
                /* reinitialize for repartitioning */
                /* |   ?   : < :=p=: > :   ?   | */
                /*  pl                  d       u*/
                /*  a=b=c                     e f*/
                pe=(pf=pu=(pa=pb=pc=pl)+nmemb*size)-size;
                /* partial partitioning information is lost */
            }

            /* Array is partitioned into 3 or more regions around pivot element;
               some regions may require processing.  Sort regions by effective
               size.
            */
            /* Sorting the regions by size (with regions not requiring
               processing counted as zero size) provides for processing the
               regions in an appropriate order, i.e. the largest region to be
               processed will be at regions[top], and regions[top+nregions-1]
               either requires no processing or is the smallest region.
               Et cetera.
               An in-line selection sort is used as the number of regions is
               expected to be small, and the region size is compared directly
               (selection sort uses minimum swaps, which dominate the cost when
               comparisons are cheap, as in this case).
            */
            for (c=top,j=top+nregions; c<j; c++) {
                for (i=d=c; d<j; d++)
                    if (regions[d].n>regions[i].n) i=d;
                if (i!=c) {
                    /* dedicated swap */
                    struct region_struct temp;
                    temp=regions[i], regions[i]=regions[c], regions[c]=temp;
                }
            }

            /* Process partitioned regions.
               Push the largest region(s) on a stack for later processing, and
               process the smallest region first, iteratively.  The smallest
               region (which is expected to use less stack depth to process) is
               disposed of first; after it has been processed, the stack
               resources used in processing it have been released, the problem
               size has been reduced, and the large region(s) can be processed.
               If processing only one region, do so iteratively.
               If no region needs to be processed, the sort (or selection) is
               complete.
            */
            /* Regions have been sorted: largest first.  */
            /* process smallest size >1 region iteratively, defer other(s) */
            for (i=top+nregions-1; top<=i; i--)
                if (1UL<regions[i].n) break;
            if (top<=i) {
                pl=regions[i].p, nmemb=regions[i].n; /* process iteratively */
                if (i>top) top=i;  /* others become part of the stack */
            } else break;
            nregions=0;

            /* The inner loop handles iterative processing, while nmemb > 1 */
        } /* 1UL<nmemb loop */
        /* Check stack for more work; if the stack is empty, quickselect is
           finished.  Otherwise, pop a region from the stack and process it.
        */
        if (0>=top) break; /* Done; function returns to caller. */
        /* Pop a set of parameters for a sub-array to be processed */
        pr=&(regions[--top]); pl=pr->p, nmemb=pr->n;
    } /* stack not empty loop */
    /* Done. */
}

/* public quickselect definition */
void quickselect(void *base, size_t nmemb, const size_t size,
    int (*compar)(const void *,const void *), const size_t *pk, const size_t nk)
{
    /* Validate supplied parameters.  Provide a hint by setting errno if
       supplied parameters are invalid.
    */
    if ((NULL==base) || (0UL==size) || (NULL==compar)) {
        errno=EINVAL;
        return;
    }
    /* Initialization of strings is performed here (rather than in
       quickselect_internal) so that quickselect_internal can be made inline.
    */
    if ((char)0==quickselect_initialized) initialize_quickselect();
    /* Simplify tests for selection vs. sorting by ensuring a NULL pointer when
       sorting.
    */
    if (0UL==nk) pk=NULL;
    quickselect_internal(base,nmemb,size,compar,pk,nk);
}

/* Using quickselect to replace qsort: */
void QSORT_FUNCTION_NAME (void *base, size_t nmemb, size_t size,
    int (*compar)(const void *,const void *))
{
    /* Validate supplied parameters.  Provide a hint by setting errno if
       supplied parameters are invalid.
    */
    if ((NULL==base) || (0UL==size) || (NULL==compar)) {
        errno=EINVAL;
        return;
    }
    /* Initialization of strings is performed here (rather than in
       quickselect_internal) so that quickselect_internal can be made inline.
    */
    if ((char)0==quickselect_initialized) initialize_quickselect();
    quickselect_internal(base,nmemb,size,compar,NULL,0UL);
}
