/*INDENT OFF*/

/* Description: C source code for quickselect */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    quickselect.c copyright 2016-2017 Bruce Lilly.   \ quickselect.c $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is quickselect.c version 1.78 dated 2017-04-03T06:09:05Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/src/s.quickselect.c */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and a pair of indices brackets the subarray
 being processed.  The indices correspond to the ranks of elements.  A similar
 scheme is used by Musser's introsort, described in "Introspective Sorting and
 Selection Algorithms".  The same method is used for the array of desired order
 statistic ranks, similar to that described by Lent & Mahmoud.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size approximately the
 square root of the array size as described in "Optimal Sampling Strategies for
 Quicksort" by McGeoch and Tygar, and in "Optimal Sampling Strategies in
 Quicksort and Quickselect" by Martinez and Roura.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe, already-sorted).
 Partitioning uses a method described by Bentley & McIlroy, with a modification
 to reduce disorder induced in arrays.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.  
 Partitioning can still result in an unfavorable split of the initial subarray;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by efficient inline swap functions.  No attempt
 is made to optimize for specific array element types, but swapping can be
 performed in units of basic language types.  The swap functions avoid useless
 work (e.g. when given two pointers to the same element).  No specialized macros
 are required.
******************************************************************************/

/* compile-time configuration options */
#define ASSERT_CODE         0 /* Adds size and cost to aid debugging.
                                 0 for tested production code. */

/* When repivoting is necessary using median-of-medians, the middle third of
   the array is partitioned as a result of finding the median of the medians.
   This partial partitioning may be preserved to avoid some recomparisons
   when repartitioning. Careful coding does not affect regular partitioning,
   but object file size may increase due to the additional code required to
   preserve and use the partial partitioning information to avoid some
   comparisons. (Or object file might be smaller when saving partial
   partitioning, depending on compiler options.)
   Saving partial partitioning recomparisons improves performance on adverse
   inputs by about 2% for sorting, about 10% for selection.  But it adds a
   little overhead for non-adverse inputs.
*/
#define SAVE_PARTIAL        0

/* tuning */
/* Repivoting parameters control the tradeoff between minimal effect on random
   inputs and effective repivoting of adverse inputs.
   Choices are (defined by macros later):
      DISABLED          repivot only under extreme circumstances
      TRANSPARENT	(almost) no repivots for random inputs
      LOOSE		worst adverse performance < 2 N log(N)
      RELAXED		worst adverse performance ~ 1.5 N log(N)
      AGGRESSIVE	performance penalty ~ 0.1% for random inputs
*/
#define TABLE_ENTRIES       AGGRESSIVE

/* Nothing to configure below this line. */

/* defaults */
#ifndef SAVE_PARTIAL
# define SAVE_PARTIAL       0
#endif
#ifndef TABLE_ENTRIES
# define TABLE_ENTRIES AGGRESSIVE
#endif

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* Minimum _XOPEN_SOURCE version for C99 (else illumos compilation fails) */
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
# define MIN_XOPEN_SOURCE_VERSION 600
#else
# define MIN_XOPEN_SOURCE_VERSION 500
#endif

/* feature test macros defined before any header files are included */
#ifndef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#if defined(_XOPEN_SOURCE) && ( _XOPEN_SOURCE < MIN_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: quickselect.c ~|^` @(#)"
#define SOURCE_MODULE "quickselect.c"
#define MODULE_VERSION "1.78"
#define MODULE_DATE "2017-04-03T06:09:05Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
/* Although the implementation is different, several concepts are adapted from:
   qsort -- qsort interface implemented by faster quicksort.
   J. L. Bentley and M. D. McIlroy, SPE 23 (1993) 1249-1265.
   Copyright 1993, John Wiley.
*/
#define COPYRIGHT_DATE "2016-2017"

/* local header files needed */
#include "quickselect.h"        /* quickselect QSORT_FUNCTION_NAME */
#include "zz_build_str.h"       /* build_id build_strings_registered
                                   copyright_id register_build_strings */

/* system header files */
#include <assert.h>             /* assert */
#include <errno.h>              /* errno E* */
#include <limits.h>             /* *_MAX */
#include <stddef.h>             /* size_t NULL */
#if ASSERT_CODE
# include <stdio.h>             /* for fprintf when debugging */
#endif
#include <string.h>             /* strrchr */

/* macros */
/* repivot tuning */
#define DISABLED    0
#define TRANSPARENT 1 /* (almost) no repivots for random inputs */
#define LOOSE       2 /* adversary < 2 N log N */
#define RELAXED     3 /* adversary < 1.5 N log N */
#define AGGRESSIVE  4 /* penalty < 0.1% */

/* space-saving */
#undef V
#define V void
#undef A
#define A(me) assert(me)

/* stringification (don't change!) */
#undef xbuildstr
#define xbuildstr(s) buildstr(s)
#undef buildstr
#define buildstr(s) #s

/* static data (for version tracking for debugging/error reports) */
static char quickselect_initialized=(char)0;
static const char *filenamebuf= __FILE__ ;
static const char *source_file= NULL;
const char *quickselect_build_options="@(#)quickselect.c: "
    "built with configuration options: "
    "ASSERT_CODE=" xbuildstr(ASSERT_CODE)
#ifdef BUILD_NOTES
    ", BUILD_NOTES=" BUILD_NOTES
#endif
#ifdef SAVE_PARTIAL
    ", SAVE_PARTIAL=" xbuildstr(SAVE_PARTIAL)
#endif
    ", TABLE_ENTRIES="
#if TABLE_ENTRIES == TRANSPARENT
        "transparent"
#elif TABLE_ENTRIES == LOOSE
        "loose"
#elif TABLE_ENTRIES == RELAXED
        "relaxed"
#elif TABLE_ENTRIES == AGGRESSIVE
        "aggressive"
#else
        "disabled"
#endif
    ;

#ifndef SIZE_T_MAX /* not defined on Solaris */
# define SIZE_T_MAX ULONG_MAX
#endif

/* data structures */

/* To avoid repeatedly calculating the number of samples required for pivot
   element selection vs. nmemb, which is expensive, a table is used; then
   determining the number of samples simply requires a search of the (small)
   table.  As the number of samples in each table entry is a power of 3, the
   table may also be used to avoid multiplication and/or division by 3.
   McGeoch & Tygar, in "Optimal Sampling Strategies for Quicksort" also
   suggest use of a table, and determine the optimal sample size as proportional
   to the square root of the array size. The table min_nmemb cutoff values
   mostly correspond to that relationship (cutoff is the square of the number of
   samples) except for a few entries where a different optimum has been found.
*/
struct sampling_table_struct {
    size_t min_nmemb;    /* smallest subarray for this number of samples */
    size_t samples;      /* the number of samples used for pivot selection */
    size_t factor1;      /* lopsided ratio for immediate repivoting */
    size_t factor2;      /* lopsided ratio for repivoting on 2nd occurrence */
};
#if (SIZE_T_MAX) > 4294967295
# define SAMPLING_TABLE_SIZE 22
#else
# define SAMPLING_TABLE_SIZE 12
#endif
/* N.B.: The table's samples member for sampling_table[x] is the x'th power of
          3. Several parts of the code depend on this. Don't add entries for
          sample sizes which are not powers of 3!
*/
static struct sampling_table_struct sampling_table[SAMPLING_TABLE_SIZE] = {
   {                    1UL,           1UL, 2UL,   2UL }, /* single sample */
#if TABLE_ENTRIES == TRANSPARENT
   {                    3UL,           3UL, 40UL, 37UL }, /* median-of-3 */ /* transparent */
   {                   81UL,           9UL, 45UL, 24UL }, /* remedian of samples */ /* transparent */
   {                  729UL,          27UL, 12UL,  5UL }, /* transparent */
#elif TABLE_ENTRIES == LOOSE
   {                    3UL,           3UL, 40UL, 34UL }, /* median-of-3 */ /* loose */
   {                   81UL,           9UL, 45UL, 20UL }, /* remedian of samples */ /* loose */
   {                  729UL,          27UL, 12UL,  5UL }, /* loose */
#elif TABLE_ENTRIES == RELAXED
   {                    3UL,           3UL, 40UL, 17UL }, /* median-of-3 */ /* relaxed */
   {                   81UL,           9UL, 23UL, 20UL }, /* remedian of samples */ /* relaxed */
   {                  729UL,          27UL,  8UL,  5UL }, /* relaxed */
#elif TABLE_ENTRIES == AGGRESSIVE
   {                    3UL,           3UL, 24UL,  7UL }, /* median-of-3 */ /* aggressive */
   {                   81UL,           9UL, 17UL,  9UL }, /* remedian of samples */ /* aggressive */
   {                  729UL,          27UL,  8UL,  5UL }, /* aggressive */
#else /* DISABLED */
   {                    3UL,           3UL, 40UL, 40UL }, /* median-of-3 */ /* disabled */
   {                   81UL,           9UL,182UL,182UL }, /* disabled */
   {                  729UL,          27UL,820UL,820UL }, /* disabled */
#endif
   {                 6561UL,          81UL,  4UL,  3UL }, /* common */
   {                59049UL,         243UL,  2UL,  2UL },
   {               531441UL,         729UL,  2UL,  2UL },
   {              4782969UL,        2187UL,  2UL,  2UL },
   {             41701511UL,        6561UL,  2UL,  2UL },
   {            387420489UL,       19683UL,  2UL,  2UL },
   {           3486784401UL,       59049UL,  2UL,  2UL },
#if (SIZE_T_MAX) > 4294967295
      /* silly to include large sizes?  check again in a decade or two */
   {          31381059609UL,      177147UL,  2UL,  2UL },
   {         282429536481UL,      531441UL,  2UL,  2UL },
   {        2541865828329UL,     1594323UL,  2UL,  2UL },
   {       22876792454961UL,     4782969UL,  2UL,  2UL },
   {      205891132094649UL,    14348907UL,  2UL,  2UL },
   {     1853020188851841UL,    43046721UL,  2UL,  2UL },
   {    16677181699666569UL,   129140163UL,  2UL,  2UL },
   {   150094635296999121UL,   387420489UL,  2UL,  2UL },
   {  1350851717672992089UL,  1162261467UL,  2UL,  2UL },
   { 12157665459056928801UL,  3486784401UL,  2UL,  2UL },
   {   (SIZE_T_MAX),         10460353203UL,  2UL,  2UL }
#else
   {   (SIZE_T_MAX),              177147UL,  2UL,  2UL }
#endif
};

/* Element swap/rotation code depends on the size and alignment of elements. */
/* Assume basic types sizeof(foo) etc. are powers of 2. */
#define NTYPES 6 /* double, pointer, long, int, short, char */
/* Logarithms of size indexed by sizeof: table in lieu of calculation for speed,
   valid up to sizeof(foo) = 32.
*/
static const
int log2s[]={0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5};
/* Type sizes. It is assumed that sizeof(double)>=sizeof(char *)... */
static const size_t typsz[NTYPES] = {
    sizeof(double),sizeof(char *),sizeof(long),sizeof(int),sizeof(short),1UL
};
/* Mask off low-order bits, indexed by log of type size.  */
static const unsigned long bitmask[NTYPES] = {
    0x0UL, 0x01UL, 0x03UL, 0x07UL, 0x0fUL, 0x01fUL
};

/* alignment; no fiddly bits */
#define is_aligned(var,shift) (0U==(((unsigned long)(var))&bitmask[(shift)]))

/* static functions */

/* initialization of static strings at run-time */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void initialize_quickselect(V)
{
    const char *s;

    /* Initialize strings */
    s=strrchr(filenamebuf,'/');
    if (NULL==s) s=filenamebuf; else s++;
    quickselect_initialized=register_build_strings(quickselect_build_options,
        &source_file,s);
}

/* Array element swaps and rotations: */
/* Called many times from quickselect_loop, medians3. */
/* count is in chars */
/* versions to swap/rotate by char, short, int, double */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void charswap(char *pa, char *pb, size_t count)
{
    char t;
    A(pa!=pb);A(0UL<count);
    do {
        t=*pa, *pa=*pb, *pb=t;
        if (0UL==--count) break;
        pa++, pb++;
    } while (1);
}

/* Macro for swapping by some type other than char. */
#undef GENERIC_SWAP
# define GENERIC_SWAP(type)                  \
    type *px=(type *)pa, *py=(type *)pb, t; \
    A(pa!=pb);A(0UL<count);                 \
    count /= sizeof(type);                  \
        do {                                \
            t=*px, *px=*py, *py=t;          \
            if (0UL==--count) break;        \
            px++, py++;                     \
        } while (1) /* terminating semicolon in macro call */

static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void shortswap(char *pa, char *pb, size_t count)
{
    GENERIC_SWAP(short);
}

static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void intswap(char *pa, char *pb, size_t count)
{
    GENERIC_SWAP(int);
}

static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void doubleswap(char *pa, char *pb, size_t count)
{
    GENERIC_SWAP(double);
}

/* array element moves in blocks */
/* Given two adjacent blocks of data delimited by pointers
   pa = start of block A, pb = start of block B, and pc pointing just past the
   end of block B, swap the minimum number of chars to place all of block B
   before block A (order within blocks is not preserved), returning a pointer
   to the start of block A (which is now after block B).
 Z |  A |   B  |  C
    pa   pb     pc
    vvvvvvvvvvv
 Z |  B  |  A  |  C
    pa    p     pc
 returned ^
   In addition to reversing the relative order of blocks A and B, this function
   is useful to consolidate like regions separated by a different type of
   region, e.g. when it is desirable to consolidate Z and B and/or A and C in
   the above diagram.
*/
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
char *blockmove(char *pa, char *pb, char *pc,
    void(*swapfunc)(char *,char *,size_t))
{
    A(pa<=pb);A(pb<=pc);
    if (pb<pc) {
        if (pa<pb) {
            size_t p=pc-pb, n=pb-pa;
            if (p<n) n=p;
            swapfunc(pa,pc-n,n); return pa+p;
        } return pc;
    } return pa;
}

/* medians of sets of 3 elements */
/* Optimized ternary median-of-3: 1-3 comparisons.
   Minimum number of comparisons (because in the qsort model (external function
   for comparison), comparisons are expensive).  If any two elements (of the 3)
   compare equal, either can be chosen for the median (the value is the median
   of the 3, regardless of the value of the third element).  Likewise, the
   median may be determined by the first two comparisons, e.g. a < b and b < c.
   In the worst case, 3 comparisons are required.
*/
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
char *fmed3(char *pa, char *pb, char *pc, int(*compar)(const void *,const void *))
{
    int c=compar(pa,pb);
    if (0!=c) {
        int d=compar(pb,pc);
        if (0!=d) {
            if ((0<d)&&(0>c)) {
                if (0>compar(pa,pc)) return pc;
                else return pa;
            } else if ((0>d)&&(0<c)) {
                if (0<compar(pa,pc)) return pc;
                else return pa;
            }
        }
    }
    return pb;
}

/* Given base, size, and compar as for qsort, plus a row offset and sample
   offset, both in chars, find medians of sets of 3 elements where the three
   elements for each median are taken from three rows starting with base, and
   each subsequent set of three elements is offset from the previous set by
   sample_offset. As each median is determined, it is placed in the position of
   the middle element of the set. As a result, the set medians comprise the
   middle row, to which a pointer is returned.
   N.B. base is not necessarily the first element in the array passed to qsort.
*/
/* called from select_pivot() and repivot() */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
char *medians3(char *base, size_t size,
    int(*compar)(const void *, const void *), size_t row_offset,
    size_t sample_offset, size_t row_samples,
    void(*swapfunc)(char *,char *,size_t))
{
    char *pa, *pb;
    size_t n, o;

    for (n=o=0UL; n<row_samples; n++,o+=sample_offset) {
        pa=base+o;
        pb=pa+row_offset; /* middle element */
        pa=fmed3(pa,pb,pb+row_offset,compar);
        if (pa!=pb) swapfunc(pa,pb,size);
    }
    return base+row_offset; /* middle row */
}

/* Remedian of samples, recursive implementation. */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
char *remedian(char *middle, size_t row_spacing, size_t sample_spacing,
    unsigned int idx, int(*compar)(const void*,const void*))
{
    if (0UL < --idx) {
        char *pa, *pb, *pc;
        size_t s=sample_spacing/3UL;

        pa=remedian(middle-s,row_spacing,s,idx,compar);
        pb=remedian(middle,row_spacing,s,idx,compar);
        pc=remedian(middle+s,row_spacing,s,idx,compar);
        return fmed3(pa,pb,pc,compar);
    }
    return fmed3(middle-row_spacing,middle,middle+row_spacing,compar);
}

/* quickselect definition (internal interface) */
/* Never called for nmemb<2UL. */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void quickselect_loop(char *base, size_t first, size_t beyond,
    const size_t size, int(*compar)(const void *,const void *),
    const size_t *pk, size_t firstk, size_t beyondk,
    void(*swapfunc)(char *,char *,size_t), unsigned int table_index
#if SAVE_PARTIAL
    , char **ppeq, char **ppgt
#endif
   )
{
    int nl2=0, nl3=0;
    size_t lk=beyondk, nmemb=beyond-first, rk=firstk;
    char *pa, *pb, *pc, *pd, *pe, *pf, *pg, *pivot, *pl, *pu;

    while (((NULL!=pk)
#if ! SAVE_PARTIAL
          &&(nmemb>4UL) /* sorting networks for nmemb <= 4 for selection */
#endif
          )||(nmemb>8UL) /* sorting networks for nmemb <= 8 for sorting */
    ) {
        int c, d, do_repivot;
        size_t n, p, q, r, s, t;

        A((NULL==pk)||(firstk<beyondk));
        A(first<beyond);
        A(table_index<(SAMPLING_TABLE_SIZE));
        /* Samples of array elements (quantity). */
        n=sampling_table[table_index].samples; /* total samples (power of 3) */

        /* Select samples (quality=uniform spacing) from array elements. */
        pivot=base+size*(first+(nmemb>>1));      /* [upper-]middle element */
        switch (n) {
            case 1UL :
                /* only happens for selection w/ 2<=nmemb<3 */
                s=r=0UL;
            break;
            case 3UL :
                s=r=(nmemb/n)*size;                /* uniform nmemb/3 spacing */
            break;
            default : /* > 3, power of 3 */
                t=sampling_table[table_index-1U].samples; /* per row (n/3) */
                s=nmemb/n;                         /* uniform sample spacing */
                s*=size;                           /* spacing in chars */
                r=s*t;                    /* uniform row spacing (also chars) */
            break;
        }

        /* Pick pivot from samples. Already done for single sample. Use remedian
           of samples using stack for temporary variables.
        */
        if (1UL<n)
            pivot=remedian(pivot,r,r,table_index,compar);

        /* partition the array around the pivot element */
#if ! SAVE_PARTIAL
partition_array: ;
#endif
        /* +-----------------------------------------------------+ */
        /* |   =   |   <   |  ?               ?  |   >   |   =   | */
        /* +-----------------------------------------------------+ */
        /*  pl      a       c                   G g       f       u*/
        pc=pa=pl=base+size*first,pg=(pf=pu=base+beyond*size)-size;
        /* Swap pivot to first or last position. */
        /* Counterintuitively, swapping to the far end yields better results. */
        /* But don't swap if the pivot is already at one end. */
        if (pivot-pl<pu-pivot) { /* pivot is closer to first element */
            if (pl!=pivot) { swapfunc(pg,pivot,size); pivot=pg; }
        } else { /* pivot is closer to last element */
            if (pg!=pivot) { swapfunc(pl,pivot,size); pivot=pl; }
        }

/* Kiwiel's algorithm L (excluding cleanup) as a macro. */
/* Use S1, S2 for pivot pointer update if required. */
/* XXX pivot is swapped (fewer comparisons) */
/* Ref: Kiwiel, K. "Partitioning schemes for quicksort and quickselect" */
#define KIWIEL_L(S1,S2)                                                  \
    if (pivot==pc) pc+=size;                                             \
    else if (pivot==pg) pg-=size;                                        \
    /* I2(K) */                                                          \
    while ((pc<=pg)&&(0==(c=compar(pivot,pc)))) { pc+=size; }            \
    pa=pc;                                                               \
    if ((pc<=pg)&&(0<c)) {                                               \
        /* I3(K) */                                                      \
        for (pc+=size; (pc<=pg)&&(0<=(c=compar(pivot,pc))); pc+=size) {  \
            if (0==c) { A(pa!=pc); swapfunc(pa,pc,size); S1; pa+=size; } \
        }                                                                \
    }                                                                    \
    /* I4(K) */                                                          \
    while ((pc<pg)&&(0==(d=compar(pivot,pg)))) { pg-=size; }             \
    pf=pg+size; /* different semantics from Kiwiel's q */                \
    if ((pc<pg)&&(0>d)) {                                                \
        /* I5(K) */                                                      \
        for (pg-=size; (pc<pg)&&(0>=(d=compar(pivot,pg))); pg-=size) {   \
            if (0==d) { pf-=size; A(pg!=pf); swapfunc(pg,pf,size); S2; } \
        }                                                                \
    }                                                                    \
    while (pc<pg) {                                                      \
        /* I7 (there is no I6) */ A(0>c);A(0<d);                         \
        swapfunc(pc,pg,size);                                            \
        /* I8(J) */  A(pl<=pa);A(pa<=pc);A(pg<pf);A(pf<=pu);             \
        pc+=size, pg-=size;                                              \
        /* I9(J) */                                                      \
        for (; (pc<=pg)&&(0<=(c=compar(pivot,pc))); pc+=size) {          \
            if (0==c) { A(pa!=pc); swapfunc(pa,pc,size); S1; pa+=size; } \
        }                                                                \
        /* I10(J) */                                                     \
        for (; (pc<pg)&&(0>=(d=compar(pivot,pg))); pg-=size) {           \
            if (0==d) { pf-=size; A(pg!=pf); swapfunc(pg,pf,size); S2; } \
        }                                                                \
        /* I11(J): loop */                                               \
    }                                                                    \
    pg = pc-size /* terminating semicolon after macro call */

/* Bentley&McIlroy partitioning algorithm (excluding canonicalization) w/
   self-swapping guards as a macro.
*/
/* Use S1, S2 for pivot pointer update if required. */
#define BENTLEY_MCILROY_PARTITION(S1,S2)                                      \
    if (pivot==pc) pa+=size, pc+=size;                                        \
    else if (pivot==pg) pg-=size, pf-=size;                                   \
    for (;;) { /* loop - partitioning */                                      \
        for (; (pc<=pg)&&(0<=(c=compar(pivot,pc))); pc+=size) {               \
            if (0==c) { if (pa!=pc) { swapfunc(pa,pc,size); S1; } pa+=size; } \
        }                                                                     \
        for (; (pc<=pg)&&(0>=(d=compar(pivot,pg))); pg-=size) {               \
            if (0==d) { pf-=size; if (pg!=pf) { swapfunc(pg,pf,size); S2; } } \
        }                                                                     \
        if (pc>pg) break;                                                     \
        if (pc!=pg) { swapfunc(pc,pg,size);          }                        \
        pc+=size; pg-=size;                                                   \
    }

        KIWIEL_L(/**/,/**/);

        /* |   =   |   <               |             >   |   =   | */
        /*  pl      a                   c                 f       u*/
        /* canonicalize */
        pa=blockmove(pl,pa,pc,swapfunc);
        pg=blockmove(pc,pf,pu,swapfunc);
        /* |       <            |         =           |      >      | */
        /*  pl                   a                     g             u*/

#if SAVE_PARTIAL
check_sizes: ; /* compare partitioned region (effective) sizes */
#endif
        A(pl<=pa);A(pa<pg);A(pg<=pu);
        /* ranks of first = element and element beyond = region */
        p=(pa-base)/size, q=(pg-base)/size;
        /* sizes of < and > regions (elements) */
        s=p-first, t=beyond-q;
        /* revised range of order statistic ranks */
        /* < region indices [first,p), order statistics [firstk,lk) */
        /* > region indices [q,beyond), order statistics [rk,beyondk) */
        if (NULL!=pk) {
            /* binary search through pk to find limits for each region */
            for (n=firstk,r=beyondk,lk=n+((r-n)>>1);(n<r)&&(lk<beyondk);) {
                if (pk[lk]>=p) { if (0UL<lk) r=lk-1UL; else r=lk; }
                else n=lk;
                lk=n+((r+1UL-n)>>1);
            }
            if ((lk<beyondk)&&(pk[lk]<p)) lk++;
            A(lk>=firstk);
            for (n=lk,r=beyondk,rk=n+((r-n)>>1); (n<r)&&(rk<beyondk);) {
                if (pk[rk]<q) { if (rk<beyondk) n=rk+1UL; else n=rk; }
                else r=rk;
                rk=n+((r-n)>>1);
            }
            A((lk==beyondk)||(pk[lk]>=p));A((rk==beyondk)||(pk[rk]>=q));
#if SAVE_PARTIAL
            /*update = region pointers (only applicable for median-of-medians)*/
            if ((0UL==firstk)&&(1UL==beyondk)&&(NULL!=ppeq)&&(NULL!=ppgt)) {
                A(p<q);
                /* update range pointers if median is [in] one of 3 regions */
                r=pk[0];
                if ((p<=r)&&(r<q)) *ppeq=pa, *ppgt=pg;
                else if ((1UL==s)&&(first<=r)&&(r<p)) *ppeq=pl, *ppgt=pa;
                else if ((1UL==t)&&(q<=r)&&(r<beyond)) *ppeq=pg, *ppgt=pu;
            }
#endif
        }
        A(lk>=firstk);A(rk<=beyondk);A(lk<=rk);

        /* process smaller region (unless no processing required) first */
        if (s<t) { /* > region is larger */
            /* recurse on small region, if effective size > 1 */
            if ((1UL<s)&&((NULL==pk)||(lk>firstk))) {
                unsigned int idx=table_index;
                while (s<sampling_table[idx].min_nmemb)
                    idx--;
                quickselect_loop(base,first,p,size,compar,pk,firstk,lk,swapfunc,
                    idx
#if SAVE_PARTIAL
                    ,ppeq,ppgt
#endif
                );
            }
            /* large region [q,beyond) size t, order statistics [rk,beyondk) */
            first=q, r=t, firstk=rk;
        } else { /* < region is larger, or regions are same size */
            /* recurse on small region, if effective size > 1 */
            if ((1UL<t)&&((NULL==pk)||(beyondk>rk))) {
                unsigned int idx=table_index;
                while (t<sampling_table[idx].min_nmemb)
                    idx--;
                quickselect_loop(base,q,beyond,size,compar,pk,rk,beyondk,
                    swapfunc,idx
#if SAVE_PARTIAL
                    ,ppeq,ppgt
#endif
                );
            }
            /* large region [first,p) size s, order statistics [firstk,lk) */
            beyond=p, r=s, beyondk=lk;
        }
        /* iterate on large region (size r), if effective size > 1 */
        if ((2UL>r)||((NULL!=pk)&&(firstk>=beyondk))) return;
        /* Should large region be repivoted? */
        /* Determine whether or not to repivot/repartition region of size r
           elements (large region) resulting from a partition of nmemb elements.
           Assumed that continued processing of the region w/o repivoting will
           yield a similarly poor split.  Repivot if the cost of repivoting plus
           processing the resulting regions is expected to be less than the cost
           of processing the region w/o repivoting.  Tuning parameters used here
           are defined near the top of this file.
        */
        do_repivot=0; /* optimism */
        if (((NULL==pk)&&(10UL<r)) /* sorting by divide-and-conquer */
        || (8UL<r)) /* or selection of a sufficiently large region */
        {
            n=nmemb-r;
            if (r>n) { /* else ratio is zero; avoid division and tests */
                q=r/n; /* ratio of large region to others */
                /* size-dependent count 1 limit test */
                if (q>=sampling_table[table_index].factor1) {
                    do_repivot=1;
                } else if (q>=sampling_table[table_index].factor2) {
                    /* size-dependent count 2 limit test */
                    if (++nl2>=2) do_repivot=1;
                }
            }
        }
        nmemb=r;
        /* Update table index for region size (new nmemb). Updated index is
           required for sampling if not repivoting, and for next round of
           repivoting decisions whether or not this region is repivoted.
        */
        while (nmemb<sampling_table[table_index].min_nmemb)
            table_index--;
        A(table_index<(SAMPLING_TABLE_SIZE));
        if (0!=do_repivot) {
#if SAVE_PARTIAL
            char *ph;
#endif

            /* Yes, repivot: do it and check resulting sizes. */
            nl2=nl3=0; /* clean slate */

            /* Find pivot by median-of-medians, sets of 3 elements. */
            pb=pl=base+first*size;
            /* Finding a pivot with guaranteed intermediate rank. Ideally,
               median (50%).  Blum, Floyd, Pratt, Rivest, Tarjan
               median-of-medians using sets of 5 elements with recursion
               guarantees rank in (asymptotically) 30-70% range, often
               better; can guarantee linear median-finding, N log(N)
               sorting. Simplification ignores "leftover" elements with a
               slight increase in rank range.  Non-recursive method (using
               separate linear median finding) can use sets of 3 elements to
               provide a tighter 33.33% to 66.67% range (again, slightly
               wider if "leftover" elements are ignored) at lower
               computational cost.
               Medians of sets of 3 elements are moved in-place for selection
               of the median-of-medians.
            */
            n=nmemb/3UL;    /* number of complete sets */
            if (1UL<=n) {
                /* For sub-arrays with size not a multiple of 3, offset the
                   samples so that they are approximately centered in the
                   sub-array, preferentially avoiding the first element.
                */
                if (nmemb>3UL*n) pb+=size; /* cheap mod 3 test */
                pb=medians3(pb,size,compar,n*size,size,n,swapfunc);
            }
            pc=pb;
            if (1UL<n) { /* median of medians */
                unsigned int idx=table_index;
                size_t karray[1];
                q=(pb-base)/size; /* first */
                karray[0]=q+(n>>1); /* upper-median for even size arrays */
                s=q+n; /* beyond */
                pf=base+s*size;
                while (n<sampling_table[idx].min_nmemb)
                    idx--;
                quickselect_loop(base,q,s,size,compar,karray,0UL,1UL,swapfunc,
                    idx
#if SAVE_PARTIAL
                    ,&pd,&pe
#endif
                );
#if SAVE_PARTIAL
                /* Middle third of array (medians) is partitioned. */
                pivot=pd;
#else
                pe=pd=pivot=base+karray[0]*size; /* median of medians */
#endif
            } else {
                pf=pb+n*size;
            }

#if SAVE_PARTIAL
            /* McGeoch & Tygar suggest that partial partition information
               from median-of-medians might be used to avoid recomparisons
               during repartitioning.
               Ref: McGeoch, C. & Tygar, J. "Optimal sampling strategies for
               quicksort"
            */
            /* Partition, avoiding recomparison of already partitioned (by
               median-of-medians) elements.  Similar to, but a bit more involved
               than Kiwiel's algorithm L modification of Bentley & McIlroy
               partitioning.  Pivot movement is deferred here because that would
               otherwise place an unknown status element in the
               already-partitioned range.
            */
            /* Separate partitioning loop here to avoid overhead when not
               preserving partial partition. Subtleties involved: empty
               regions (pc-pd, pe-pf, pg-ph, pl-pa, pa-pb), whether pb or pg
               reaches the partially partitioned region first.
            */
            /* +-----------------------------------------------------+ */
            /* |   =   |   <   |  ?  : < :=: > :  ?  |   >   |   =   | */
            /* +-----------------------------------------------------+ */
            /*  pl      a       b     c   d e   f   G g       h       u*/
            pb=pl, pu=base+beyond*size, pg=pu-size;
            while ((pb<pc)&&(0==(c=compar(pivot,pb)))) { pb+=size; }
            pa=pb;
            if ((pb<pc)&&(0<c)) {
                for (pb+=size; (pb<pc)&&(0<=(c=compar(pivot,pb))); pb+=size) {
                    if (0==c) { A(pa!=pb); swapfunc(pa,pb,size); pa+=size; }
                }
            }
            A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=pu);
            /* 2. Within partial partition; no recomparisons. */
            if ((pc<=pb)&&(pb<pf)) { /* partitioned */
                /* First skip over < elements, possibly past pg. */
                if (pd<=pg) { /* If pg didn't, move = block. */
                    if (pb<pe) { /* move = elements as a block */
                        A(pa<=pd);A(pd<=pe);
                        pa=blockmove(pivot=pa,pd,pb=pe,swapfunc);
                        pb=pe, c=-2;
                    }
                } else pb=pg+size; /* < elements */
            }
            A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=pu);
            while ((pb<=pg)&&((pb<pc)||(pf<=pb))&&(0<=(c=compar(pivot,pb)))) {
                if (0==c) { A(pa!=pb); swapfunc(pa,pb,size); pa+=size; }
                pb+=size;
            }
            A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=pu);
            while ((pf<=pg)&&(0==(d=compar(pivot,pg)))) { pg-=size; }
            ph=pg+size;
            A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=ph);A(ph<=pu);
            if ((pf<=pg)&&(0>d)) {
                for (pg-=size; (pf<=pg)&&(0>=(d=compar(pivot,pg))); pg-=size) {
                    if (0==d) { ph-=size; A(pg!=ph); swapfunc(pg,ph,size); }
                }
            }
            /* check for already-partitioned region here (but no comparisons) */
            A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=ph);A(ph<=pu);
            /* 4. Within partial partition; no recomparisons. */
            if ((pc<=pg)&&(pg<pf)) { /* partitioned */
                /* First skip over > elements, possibly past pb. */
                if (pb<pe) { /* If pb didn't, move = block. */
                    if (pd<=pg) { /* move = elements as a block */
                        A(pd<=pe);A(pe<=ph);
                        pivot=ph=blockmove(pd,pe,ph,swapfunc); pg=pd-size; d=2;
                    }
                } else pg=pb-size; /* > elements */
            }
            A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=ph);A(ph<=pu);
            while ((pb<=pg)&&((pf<=pg)||(pg<pc))&&(0>=(d=compar(pivot,pg)))) {
                if (0==d) { ph-=size; A(pg!=ph); swapfunc(pg,ph,size); }
                pg-=size;
            }
            A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=ph);A(ph<=pu);
            while (pb<pg) {
                A(0>c);A(0<d);
                swapfunc(pb,pg,size);
                pb+=size, pg-=size;
                while ((pb<=pg)&&((pb<pc)||(pf<=pb))&&(0<=(c=compar(pivot,pb)))) {
                    if (0==c) { A(pa!=pb); swapfunc(pa,pb,size); pa+=size; }
                    pb+=size;
                }
                A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=ph);A(ph<=pu);
                /* 6. Within partial partition; no recomparisons. */
                if ((pc<=pb)&&(pb<pf)) { /* partitioned */
                    /* First skip over < elements, possibly past pg. */
                    if (pd<=pg) { /* If pg didn't, move = block. */
                        if (pb<pe) { /* move = elements as a block */
                            A(pa<=pd);A(pd<=pe);
                            pa=blockmove(pivot=pa,pd,pb=pe,swapfunc);
                            pb=pe, c=-2;
                        }
                    } else pb=pg+size; /* < elements */
                }
                A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=ph);A(ph<=pu);
                while ((pb<=pg)&&((pf<=pg)||(pg<pc))&&(0>=(d=compar(pivot,pg)))) {
                    if (0==d) { ph-=size; A(pg!=ph); swapfunc(pg,ph,size); }
                    pg-=size;
                }
                A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=ph);A(ph<=pu);
                /* 8. Within partial partition; no recomparisons. */
                if ((pc<=pg)&&(pg<pf)) { /* partitioned */
                    /* First skip over > elements, possibly past pb. */
                    if (pb<pe) { /* If pb didn't, move = block. */
                        if (pd<=pg) { /* move = elements as a block */
                            A(pd<=pe);A(pe<=ph);
                            pivot=ph=blockmove(pd,pe,ph,swapfunc); pg=pd-size;
                            d=2;
                        }
                    } else pg=pb-size; /* > elements */
                }
                A(pl<=pa);A(pa<=pb);A(pc<=pd);A(pd<pe);A(pe<=pf);A(pg<=ph);A(ph<=pu);
            }
            /* pb is start of > region */
            /* canonicalize */
            /* |    =  |      <             |             >    |   =    | */
            /*  pl      a                    b                  h        u*/
            /* swap > and upper = regions, set pg to start of > */
            A(pl<=pa); A(pb<=ph); A(ph<=pu);
            pa=blockmove(pl,pa,pb,swapfunc);
            pg=blockmove(pb,ph,pu,swapfunc);
            A(pl<=pa); A(pa<=pg); A(pg<=pu);
            /* |       <            |         =           |      >      | */
            /*  pl                   a                     g             u*/
            goto check_sizes;
#else
            /* Regular partition; repeats some comparisons. */
            goto partition_array;
#endif
        }
        /* no repivot: just process large region as usual */
    }
    if (2UL>nmemb) return;
    /* network sort for small subarrays */
    /* See J. Gamble http://pages.ripco.net/~jgamble/nw.html */
#define COMPARE_EXCHANGE(ma,mb) if(0<compar(ma,mb))swapfunc(ma,mb,size)
    pl=base+first*size;
    pa=pl+size;
    switch (nmemb) {
        case 2UL : /* 1 comparison/exchange */
            COMPARE_EXCHANGE(pl,pa);
        return;
        case 3UL : /* 3 comparison/exchanges */
            pb=pa+size;
            COMPARE_EXCHANGE(pl,pb);
            COMPARE_EXCHANGE(pl,pa);
            COMPARE_EXCHANGE(pa,pb);
        return;
        case 4UL : /* 5 comparison/exchanges */
            pb=pa+size;
            pc=pb+size;
            /* parallel group */
                COMPARE_EXCHANGE(pl,pb);
                COMPARE_EXCHANGE(pa,pc);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pa);
                COMPARE_EXCHANGE(pb,pc);
            /* parallel group */
                COMPARE_EXCHANGE(pa,pb);
        return;
        case 5UL : /* 9 comparison/exchanges */
            pb=pa+size;
            pc=pb+size;
            pd=pc+size;
            /* parallel group */
                COMPARE_EXCHANGE(pl,pd);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pb);
                COMPARE_EXCHANGE(pa,pc);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pa);
                COMPARE_EXCHANGE(pb,pd);
            /* parallel group */
                COMPARE_EXCHANGE(pb,pc);
                COMPARE_EXCHANGE(pa,pd);
            /* parallel group */
                COMPARE_EXCHANGE(pa,pb);
                COMPARE_EXCHANGE(pc,pd);
        return;
        case 6UL : /* 12 comparison/exchanges */
            pb=pa+size;
            pc=pb+size;
            pd=pc+size;
            pe=pd+size;
            /* parallel group */
                COMPARE_EXCHANGE(pl,pd);
                COMPARE_EXCHANGE(pa,pe);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pb);
                COMPARE_EXCHANGE(pa,pc);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pa);
                COMPARE_EXCHANGE(pb,pd);
                COMPARE_EXCHANGE(pc,pe);
            /* parallel group */
                COMPARE_EXCHANGE(pb,pc);
                COMPARE_EXCHANGE(pd,pe);
            /* parallel group */
                COMPARE_EXCHANGE(pa,pd);
            /* parallel group */
                COMPARE_EXCHANGE(pa,pb);
                COMPARE_EXCHANGE(pc,pd);
        return;
        case 7UL : /* 16 comparison/exchanges */
            pb=pa+size;
            pc=pb+size;
            pd=pc+size;
            pe=pd+size;
            pf=pe+size;
            /* parallel group */
                COMPARE_EXCHANGE(pl,pd);
                COMPARE_EXCHANGE(pa,pe);
                COMPARE_EXCHANGE(pb,pf);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pb);
                COMPARE_EXCHANGE(pa,pc);
                COMPARE_EXCHANGE(pd,pf);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pa);
                COMPARE_EXCHANGE(pb,pd);
                COMPARE_EXCHANGE(pc,pe);
            /* parallel group */
                COMPARE_EXCHANGE(pb,pc);
                COMPARE_EXCHANGE(pd,pe);
            /* parallel group */
                COMPARE_EXCHANGE(pa,pd);
                COMPARE_EXCHANGE(pc,pf);
            /* parallel group */
                COMPARE_EXCHANGE(pa,pb);
                COMPARE_EXCHANGE(pc,pd);
                COMPARE_EXCHANGE(pe,pf);
        return;
        case 8UL : /* 19 comparison/exchanges */
            pb=pa+size;
            pc=pb+size;
            pd=pc+size;
            pe=pd+size;
            pf=pe+size;
            pg=pf+size;
            /* parallel group */
                COMPARE_EXCHANGE(pl,pd);
                COMPARE_EXCHANGE(pa,pe);
                COMPARE_EXCHANGE(pb,pf);
                COMPARE_EXCHANGE(pc,pg);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pb);
                COMPARE_EXCHANGE(pa,pc);
                COMPARE_EXCHANGE(pd,pf);
                COMPARE_EXCHANGE(pe,pg);
            /* parallel group */
                COMPARE_EXCHANGE(pl,pa);
                COMPARE_EXCHANGE(pb,pd);
                COMPARE_EXCHANGE(pc,pe);
                COMPARE_EXCHANGE(pf,pg);
            /* parallel group */
                COMPARE_EXCHANGE(pb,pc);
                COMPARE_EXCHANGE(pd,pe);
            /* parallel group */
                COMPARE_EXCHANGE(pa,pd);
                COMPARE_EXCHANGE(pc,pf);
            /* parallel group */
                COMPARE_EXCHANGE(pa,pb);
                COMPARE_EXCHANGE(pc,pd);
                COMPARE_EXCHANGE(pe,pf);
        return;
    }
}

/* comparison function for sorting order statistic ranks */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
int size_t_cmp(const void *p1, const void *p2)
{
    if ((NULL != p1) && (NULL != p2) && (p1 != p2)) {
        const size_t a = *((const size_t *)p1), b = *((const size_t *)p2);

        if (a > b) return 1;
        if (a < b) return -1;
    }
    return 0;
}

/* determine and return a pointer to an appropriate swap function */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void (*whichswap(char *base, size_t size))(char *, char *, size_t)
{
    int i, t;  /* general integer variables */
    size_t s;  /* general size_t variable */

    /* Determine size of data chunks to copy for element swapping.  Size is
       determined by element size and alignment. typsz is an array of type sizes
       (double, pointer, long, int, short, char).
       Types char, short, int, double have sizes 1, 2, 4, 8 on most (all?)
       32-bit and 64-bit architectures.  Sizes of long and pointer types vary by
       architecture.
    */
    s=typsz[t=0]; /* double */
    if ((size<s)||(!(is_aligned(size,i=log2s[s])))||(!(is_aligned(base,i)))) {
        s=typsz[t=3]; /* int */
        if ((size<s)||(!(is_aligned(size,i=log2s[s])))
        ||(!(is_aligned(base,i)))) {
            s=typsz[t=4]; /* short */
            if ((size<s)||(!(is_aligned(size,i=log2s[s])))
            ||(!(is_aligned(base,i))))
                s=typsz[t=5]; /* char */
        }
    }
    switch (t) {
        case 0 :  return doubleswap;
        case 3 :  return intswap;
        case 4 :  return shortswap;
        default : return charswap;
    }
}

/* public quickselect definition */
void quickselect(void *base, size_t nmemb, const size_t size,
    int (*compar)(const void *,const void *), size_t *pk, size_t nk)
{
    unsigned int table_index=2U; /* optimized for small nmemb */
    size_t s;  /* general size_t variable */

    /* Validate supplied parameters.  Provide a hint by setting errno if
       supplied parameters are invalid.
    */
    if ((NULL==base) || (0UL==size) || (NULL==compar)) {
        errno=EINVAL;
        return;
    }

    if (2UL>nmemb) return; /* Return early if there's nothing to do. */

    /* Initialization of strings is performed here (rather than in
       quickselect_loop) so that quickselect_loop can be made inline.
    */
    if ((char)0==quickselect_initialized) initialize_quickselect();

    /* Simplify tests for selection vs. sorting by ensuring a NULL pointer when
       sorting. Ensure consistency between pk and nk. Ensure sorted pk array.
    */
    if (0UL==nk) pk=NULL;
    else if (NULL==pk) nk=0UL;
    else if (1UL<nk) { /* binary search requires nondecreasing pk */
        for (s=1UL; s<nk; s++) /* verify (linear scan with direct comparison) */
            if (pk[s-1UL]>pk[s]) break;
        if (s<nk) /* fix iff broken */
            QSORT_FUNCTION_NAME ((void *)pk,nk,sizeof(size_t),size_t_cmp);
    }

    /* Initialize the sampling table index for the array size. Sub-array
       sizes will be smalller, and this step ensures that the main loop won't
       have to traverse much of the table during recursion and iteration.
    */
    while ((table_index<(SAMPLING_TABLE_SIZE))
    &&(nmemb>sampling_table[table_index].min_nmemb))
        table_index++;
    while (nmemb<sampling_table[table_index].min_nmemb)
        table_index--;
    A(table_index<(SAMPLING_TABLE_SIZE));

    quickselect_loop(base,0UL,nmemb,size,compar,pk,0UL,nk,
        whichswap(base,size),table_index
#if SAVE_PARTIAL
        ,NULL,NULL
#endif
    );
}

/* Using quickselect to replace qsort: */
void QSORT_FUNCTION_NAME (void *base, size_t nmemb, size_t size,
    int (*compar)(const void *,const void *))
{
    unsigned int table_index=2U; /* optimized for small nmemb */

    /* Validate supplied parameters.  Provide a hint by setting errno if
       supplied parameters are invalid.
    */
    if ((NULL==base) || (0UL==size) || (NULL==compar)) {
        errno=EINVAL;
        return;
    }

    if (2UL>nmemb) return; /* Return early if there's nothing to do. */

    /* Initialization of strings is performed here (rather than in
       quickselect_loop) so that quickselect_loop can be made inline.
    */
    if ((char)0==quickselect_initialized) initialize_quickselect();

    /* Initialize the sampling table index for the array size. Sub-array
       sizes will be smalller, and this step ensures that the main loop won't
       have to traverse much of the table during recursion and iteration.
    */
    while ((table_index<(SAMPLING_TABLE_SIZE))
    &&(nmemb>sampling_table[table_index].min_nmemb))
        table_index++;
    while (nmemb<sampling_table[table_index].min_nmemb)
        table_index--;
    A(table_index<(SAMPLING_TABLE_SIZE));

    quickselect_loop(base,0UL,nmemb,size,compar,NULL,0UL,0UL,
        whichswap(base,size),table_index
#if SAVE_PARTIAL
        ,NULL,NULL
#endif
    );
}
