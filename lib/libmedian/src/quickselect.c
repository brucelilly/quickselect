/*INDENT OFF*/

/* Description: C source code for quickselect */
/******************************************************************************
* This software is covered by the zlib/libpng license.
* The zlib/libpng license is a recognized open source license by
* the Open Source Initiative: http://opensource.org/licenses/Zlib
* The zlib/libpng license is a recognized "free" software license by
* the Free Software Foundation: https://directory.fsf.org/wiki/License:Zlib
*******************************************************************************
******************* Copyright notice (part of the license) ********************
* $Id: ~|^` @(#)    quickselect.c copyright 2016-2017 Bruce Lilly.   \ quickselect.c $
* This software is provided 'as-is', without any express or implied warranty.
* In no event will the authors be held liable for any damages arising from the
* use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it freely,
* subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not claim
*    that you wrote the original software. If you use this software in a
*    product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source distribution.
****************************** (end of license) ******************************/
/* $Id: ~|^` @(#)   This is quickselect.c version 1.64 dated 2017-02-16T14:20:17Z. \ $ */
/* You may send bug reports to bruce.lilly@gmail.com with subject "quickselect" */
/*****************************************************************************/
/* maintenance note: master file /data/projects/automation/940/lib/libmedian/src/s.quickselect.c */

/********************** Long description and rationale: ***********************
 An implementation of multiple quickselect similar to that described by Mahmoud
 & Lent in "Average-case analysis of multiple Quickselect: An algorithm for
 finding order statistics".  The array of items to be sorted by quickselect,
 the array element size, and the comparison function are declared as for qsort,
 with two additional parameters to specify an optional array of desired order
 statistic ranks.
 N.B. the values for the order-statistic array elements are zero-based ranks
 (i.e. 0UL for the minimum, N-1UL for the maximum of an array of N elements,
 (N-1UL)/2UL and N/2UL for the lower- and upper-medians).
 The implementation can also be used to implement qsort; a wrapper function
 (which could alternatively be implemented as a macro) is provided for that
 purpose.
 In order to be able to compute the rank of array elements for selection, the
 initial array base is maintained, and an internal stack is used to handle
 processing of subarrays resulting from partitioning.
 Pivot selection uses Rousseeuw & Basset's remedian, described in "The Remedian:
 A Robust Averaging Method for Large Data Sets", on a sample of a size which is
 a power of 3 taken from the array elements, with sample size limited to the
 logarithm of the array size with a configurable base of 7 or greater. The
 cumulative number of comparisons (assuming the ideal case of perfectly balanced
 partitioning) is then lower than for use of Tukey's "ninther" as used in
 Bentley & McIlroy's qsort ("Engineering a Sort Function").
 Moreover, the comparisons are better distributed among the various
 subarray sizes, with the sample size increasing for larger arrays, and an
 improved (and O (log(N)) rather than O(1)) guarantee of pivot rank.
 Elements sampled from the array for use by the pivot selection methods are
 chosen to provide good overall performance, avoiding choices that would fare
 poorly for commonly-seen input sequences (e.g. organ-pipe).
 Partitioning uses a method described by Bentley & McIlroy.
 Comparisons are made between array elements; there is no special-case code nor
 initialization macro.  
 Partitioning can still result in an unfavorable split of the initial subarray;
 when this happens, an emergency "break-glass" pivot selection function is used
 to ensure a better split, avoiding quadratic behavior even when handling a
 worst-case input array, such as can be generated by an adversary function
 (M. D. McIlroy "A Killer Adversary for Quicksort").
 Break-glass pivot selection uses median-of-medians using sets of 3 elements
 (ignoring leftovers) and using a call to quickselect to find the median of
 medians, rather than recursion.  Aside from those details, it is similar to the
 method described by Blum, Floyd, Pratt, Rivest, & Tarjan in "Time Bounds for
 Selection".
 Swapping of elements is handled by an efficient inline general-purpose swap
 function.  No attempt is made to optimize for particular array element types.
 The swap function avoids useless work (e.g. when given two pointers to the
 same element).  No specialized macros are required; the swap function requires
 no initialization.
******************************************************************************/

/* compile-time configuration options */
#define ASSERT_CODE         0 /* Adds size and cost to aid debugging.
                                 0 for tested production code. */

/* analysis at small N indicates an INSERTION_CUTOFF of 6 is optimal */
#ifndef INSERTION_CUTOFF
# define INSERTION_CUTOFF   6UL /* insertion sort arrays this size or smaller */
#endif

/* Repivoting parameters REPIVOT_FACTOR and REPIVOT_CUTOFF:
   Subarrays with more than REPIVOT_CUTOFF elements are checked for a large
   region which is more than (REPIVOT_FACTOR-1)/REPIVOT_FACTOR times the
   total number of elements in the subarray.
   To avoid integer overflow, the number of elements in the large region is
   divided by REPIVOT_FACTOR for comparison (bit shifts are used for
   REPIVOT_FACTOR at powers of 2).
   Median-of-3 pivot selection guarantees at least 1 element in the small
   region.  That plus the pivot guarantees that the large region has at most
   nmemb-2 elements.
   Therefore, as long as REPIVOT_CUTOFF is greater than median-of-3 cutoff (and
   it should be), REPIVOT_CUTOFF should be at least REPIVOT_FACTOR+2 to avoid
   unnecessary division and comparison.
   Small REPIVOT_FACTOR (e.g. 13UL) keeps adverse inputs from requiring
   excessive comparisons due to poor partition splits, but causes extra
   comparisons for random inputs due to an occasional lopsided partition.
   Large REPIVOT_FACTOR (e.g. 64UL) allows adverse inputs to require many
   comparisons to resolve marginally poor (not bad enough to repivot)
   partition splits, but has negligible effect on random sequences which
   rarely have extremely lopsided partitions.
   Examples for REPIVOT_FACTOR,REPIVOT_CUTOFF:
       16,27 32Ki integers 1.0214 peak random, 1.6988@79 peak adversary
       huge  16Ki integers 1.01899 peak random
*/
#ifndef REPIVOT_FACTOR
# define REPIVOT_FACTOR             16UL
#endif
#ifndef REPIVOT_CUTOFF
# define REPIVOT_CUTOFF             27UL
#endif

/* For selection, the array of desired ranks is searched linearly if the array
   size is small, but binary search is used on the (sorted) array if it is
   large.  NK_CUTOFF sets the size at which binary search in a sorted array
   is first used. Recommended value 16UL.
*/
#define NK_CUTOFF                   16UL

/* Nothing to configure below this line. */

/* defaults */
#if ! NK_CUTOFF
# ifdef NK_CUTOFF
#  undef NK_CUTOFF
# endif
# define NK_CUTOFF                   16UL
#endif
#if ! REPIVOT_FACTOR
# ifdef REPIVOT_FACTOR
#  undef REPIVOT_FACTOR
#  define REPIVOT_FACTOR             16UL
# endif
#endif
#if ! REPIVOT_CUTOFF
# ifdef REPIVOT_CUTOFF
#  undef REPIVOT_CUTOFF
#  define REPIVOT_CUTOFF             27UL
# endif
#endif

/* for assert.h */
#if ! ASSERT_CODE
# define NDEBUG 1
#endif

/* Minimum _XOPEN_SOURCE version for C99 (else illumos compilation fails) */
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
# define MIN_XOPEN_SOURCE_VERSION 600
#else
# define MIN_XOPEN_SOURCE_VERSION 500
#endif

/* feature test macros defined before any header files are included */
#ifndef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#if defined(_XOPEN_SOURCE) && ( _XOPEN_SOURCE < MIN_XOPEN_SOURCE_VERSION )
# undef _XOPEN_SOURCE
# define _XOPEN_SOURCE MIN_XOPEN_SOURCE_VERSION
#endif
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif

/* ID_STRING_PREFIX file name and COPYRIGHT_DATE are constant, other components
   are version control fields.
*/
#undef ID_STRING_PREFIX
#undef SOURCE_MODULE
#undef MODULE_VERSION
#undef MODULE_DATE
#undef COPYRIGHT_HOLDER
#undef COPYRIGHT_DATE
#define ID_STRING_PREFIX "$Id: quickselect.c ~|^` @(#)"
#define SOURCE_MODULE "quickselect.c"
#define MODULE_VERSION "1.64"
#define MODULE_DATE "2017-02-16T14:20:17Z"
#define COPYRIGHT_HOLDER "Bruce Lilly"
/* Although the implementation is different, several concepts are adapted from:
   qsort -- qsort interface implemented by faster quicksort.
   J. L. Bentley and M. D. McIlroy, SPE 23 (1993) 1249-1265.
   Copyright 1993, John Wiley.
*/
#define COPYRIGHT_DATE "2016-2017"

/* local header files needed */
#include "quickselect.h"        /* quickselect QSORT_FUNCTION_NAME */
#include "zz_build_str.h"       /* build_id build_strings_registered
                                   copyright_id register_build_strings */

#include <sys/types.h>          /* *_t */
#include <assert.h>             /* assert */
#include <errno.h>              /* errno E* */
#include <limits.h>             /* *_MAX */
#include <stddef.h>             /* NULL */
#if ASSERT_CODE
#include <stdio.h>              /* fprintf stderr */
#endif /* ASSERT_CODE */
#include <string.h>             /* strrchr */

/* macros */
/* Shared stack and array LONG_BIT is enough for the stack, 3 is sufficient for
   the array, 8 is generous.
*/
#undef NREGIONS
#define NREGIONS (LONG_BIT)+8

/* space-saving */
#undef V
#define V void
#undef A
#define A(me) assert(me)

/* stringification (don't change!) */
#undef xbuildstr
#define xbuildstr(s) buildstr(s)
#undef buildstr
#define buildstr(s) #s

/* static data (for version tracking for debugging/error reports) */
static char quickselect_initialized=(char)0;
static const char *filenamebuf= __FILE__ ;
static const char *source_file= NULL;
const char *quickselect_build_options="@(#)quickselect.c: "
    "built with configuration options: "
    "ASSERT_CODE=" xbuildstr(ASSERT_CODE)
#ifdef BUILD_NOTES
    ", BUILD_NOTES=" BUILD_NOTES
#endif
#ifdef INSERTION_CUTOFF
    ", INSERTION_CUTOFF=" xbuildstr(INSERTION_CUTOFF)
#endif
#if NK_CUTOFF
    ", NK_CUTOFF=" xbuildstr(NK_CUTOFF)
#endif
#if REPIVOT_FACTOR
    ", REPIVOT_FACTOR=" xbuildstr(REPIVOT_FACTOR)
#endif
#if REPIVOT_CUTOFF
    ", REPIVOT_CUTOFF=" xbuildstr(REPIVOT_CUTOFF)
#endif
    ;

#ifndef SIZE_T_MAX /* not defined on Solaris */
# define SIZE_T_MAX ULONG_MAX
#endif

/* data structures */

/* Region (resulting from partitioning) information is stored in an array of
   structures.  This might seem like overkill (it does increase object code size
   somewhat), but it makes for simpler, more compact, more easily understood and
   maintained source code, and is easily extensible (e.g. for handling the
   additional regions resulting from multiple pivots).
   The same structure is used in the implementation of a program stack, without
   which an additional function parameter would be required so that order
   statistic ranks could be correlated with array item positions.
   The partitioning regions and the program stack share a common array.
*/
struct region_struct {
    char   *p;  /* pointer to the start of the (sub)array */
    size_t n;   /* number of (sub)array elements */
    /* n may be set to 0UL to indicate no processing */
};

/* To avoid repeatedly calculating the number of samples required for pivot
   element selection vs. nmemb, which is expensive, a table is used; then
   determining the number of samples simply requires a search of the (small)
   table.  As the number of samples in each table entry is a power of 3, the
   table may also be used to avoid multiplication and/or division by 3.
*/
struct sampling_table_struct {
    size_t min_nmemb;
    size_t samples;
};
#define SAMPLING_TABLE_SIZE 10
static struct sampling_table_struct sampling_table[SAMPLING_TABLE_SIZE] = {
   {          1UL,      1UL }, /* single sample, 1/4 position */
   {         13UL,      3UL }, /* median-of-3 1/4,1/2,3/4 */
   {         64UL,      9UL }, /* ninther */
   {        525UL,     27UL }, /* remedian of samples */
   {       4120UL,     81UL },
   {      34000UL,    243UL },
   {     230000UL,    729UL },
   {    5000000UL,   2187UL },
   {    8000000UL,   6561UL }, /* tiny additional benefit */
   { (SIZE_T_MAX),  19683UL } /* no need for > 6561 samples */
};

/* assume sizeof(foo) etc. are powers of 2 */
#define NTYPES 6 /* double, pointer, long, int, short, char */
/* logarithms of two for index as sizeof */
/* table in lieu of calculation for speed */
/* valid up to sizeof(foo) = 32 */
static const
int log2s[]={0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5};
/* Type sizes. It is assumed that sizeof(double)>=sizeof(char *)... */
static const size_t typsz[NTYPES] = {
    sizeof(double),sizeof(char *),sizeof(long),sizeof(int),sizeof(short),1UL
};
/* mask off low-order bits, indexed by log of type size  */
static const unsigned long bitmask[NTYPES] = {
    0x0UL, 0x01UL, 0x03UL, 0x07UL, 0x0fUL, 0x01fUL
};
/* log of type size, indexed by type index */
/* initialized at first run */
static int log2t[NTYPES];

/* alignment; no fiddly bits */
#define is_aligned(var,shift) (0U==(((unsigned long)(var))&bitmask[(shift)]))

/* static functions */

/* initialization of static strings and log2t table at run-time */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void initialize_quickselect(V)
{
    size_t q;
    const char *s;

    /* Initialize log2t table */
    for (q=0UL; (NTYPES)>q; q++)
        log2t[q]=log2s[typsz[q]];
    /* Initialize strings */
    s=strrchr(filenamebuf,'/');
    if (NULL==s) s=filenamebuf; else s++;
    quickselect_initialized=register_build_strings(quickselect_build_options,
        &source_file,s);
}

/* array element swaps */
/* called many times from quickslect_internal, medians3 */
/* count is in chars */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void swap(char *pa, char *pb, size_t count, int swaptype)
{
# define CHAR_SWAP \
    while (1) {                   \
        t=*pa, *pa=*pb, *pb=t;    \
        if (0UL==--count) break;  \
        pa++, pb++;               \
    }
# define GENERIC_SWAP \
    while (1) {                   \
        t=*px, *px=*py, *py=t;    \
        if (0UL==--count) break;  \
        px++, py++;               \
    }
    if ((pa!=pb)&&(0UL<count)) { /* else nothing to do */
        if (5==swaptype) { /* char */
            char t;
            CHAR_SWAP
        } else {
            count >>= (log2t[swaptype]);
            switch (swaptype) {
                case 0 : /* double */
                    {   double *px=(double *)pa, *py=(double *)pb, t;
                        GENERIC_SWAP
                    }
                break;
                case 3 : /* int */
                    {   int *px=(int *)pa, *py=(int *)pb, t;
                        GENERIC_SWAP
                    }
                break;
                case 4 : /* short */
                    {   short *px=(short *)pa, *py=(short *)pb, t;
                        GENERIC_SWAP
                    }
                break;
            }
        }
    }
}

/* region manipulation */

/* Compute the effective size (as count of elements) of a region.  The size is
   zero if the region is not needed to find requested order statistics.
   N.B. argument pu points past the last element in the region.
*/
/* pk[k] is the 0-based rank of an array element, based on the full array
   (origin has been saved in pointer po).  The pk array is scanned for
   each region unless/until an order statistic is found that requires processing
   the region.  Therefore, uniqueness is not required of the order statistic
   values in the pk array.
*/
/* If the elements of pk are in sorted order, binary search is possible,
   but linear search is faster for small numbers of order statistics
   (<= NK_CUTOFF).  A large number of order statistics is not expected.
*/
/* called twice from process_regions() */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
size_t effective_size(char *pl, char *pu, char *po,
    const size_t size, const size_t *pk, const size_t nk)
{
    size_t n=0UL;

    if (pu>pl) {
        n=(pu-pl)/size; /* # elements */
        if (NULL!=pk) {/* selection: is region required? */
            size_t k, bigrank, minrank;

            /* Smallest ranks in region and just beyond. */
            minrank=(pl-po)/size, bigrank=(pu-po)/size;
            if ((NK_CUTOFF) > nk) { /* linear search */
                /* Loop through requested order statistics, break if/when an
                   order statistic in region is requested.
                */
                for (k=0UL; (k<nk)&&((pk[k]<minrank)||(pk[k]>=bigrank)); k++)
                    ;
                if (k>=nk) n=0UL; /* no requested rank in region */
            } else { /* binary search */
                size_t lk=0UL, rk=nk-1UL;

                while (lk<=rk) {
                    k=lk+((rk-lk)>>1); /* avoid overflow */
                    if (pk[k]<minrank) lk=k+1UL;
                    else if (pk[k]>=bigrank) {
                        if (0UL<k) rk=k-1UL; else lk=rk+1UL;
                    } else break; /* pk[k] is in region */
                }
                if (lk>rk) n=0UL; /* no requested rank in region */
            }
        }
    }
    return n;
}

/* medians of sets of 3 elements */
/* Given base, size, and compar as for qsort, plus a row offset and sample
   offset, both in chars, find medians of sets of 3 elements where the three
   elements for each median are taken from three rows starting with base, and
   each subsequent set of three elements is offset from the previous set by
   sample_offset. As each median is determined, it is placed in the position of
   the middle element of the set.
   The return value is a pointer to the first median (which has been moved as
   described above).
   N.B. base is not necessarily the first element in the array passed to qsort.
*/
/* called three times from quickselect_internal() */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
char *medians3(char *base, size_t size,
    int(*compar)(const void *, const void *), size_t row_offset,
    size_t sample_offset, size_t row_samples, int swaptype)
{
    int c;
    char *pa, *pb;
    size_t n, o;

    for (n=o=0UL; n<row_samples; n++,o+=sample_offset) {
        pa=base+o;
        pb=pa+row_offset; /* middle element */
        /* Optimized ternary median-of-3: 1-3 comparisons.
           Minimum number of comparisons (because in the qsort model (external
           function for comparison), comparisons are expensive).  If any two
           elements (of the 3) compare equal, either can be chosen for the
           median (the value is the median of the 3, regardless of the value of
           the third element).  Likewise, the median may be determined by the
           first two comparisons, e.g. a < b and b < c.  In the worst case, 3
           comparisons are required. The median element is swapped to the middle
           position.
        */
        c=compar(pa,pb);
        if (0!=c) {
            char *pc=pb+row_offset;
            int d=compar(pb,pc);
            if (0!=d) {
                if ((0<d)&&(0>c)) {
                    if (0>compar(pa,pc)) swap(pb,pc,size,swaptype);
                    else swap(pa,pb,size,swaptype);
                } else if ((0>d)&&(0<c)) {
                    if (0<compar(pa,pc)) swap(pb,pc,size,swaptype);
                    else swap(pa,pb,size,swaptype);
                }
            }
        }
    }
    return base+row_offset; /* middle row */
}

/* array partitioning */

/* Set *pbig to the size of the larger region (in elements).  If the
   (N.B.) effective size of the smaller region is more than one, add it to the
   list of regions.  If the larger region does not need to be repivoted, also
   add it to the list of regions and return 0.  But if the larger region does
   need to be repivoted, set pointer pointed to be ppb to the start of the
   larger region and return 1.
   plg and slg are start and size (chars) of the large region; psm, ssm for
   the small region.
*/
/* called twice from quickselect_internal() */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
int process_regions(char *plg, size_t slg, char *psm,
    size_t ssm, size_t nmemb, const size_t size, char *po, const size_t *pk,
    const size_t nk, char **ppb, size_t *pbig, struct region_struct *pr,
    int *pnr, int ns)
{
    int t;
    size_t n;

    *pbig=slg/size; /* large region elements */
    /* maybe add small region to regions list */
    n=effective_size(psm,psm+ssm,po,size,pk,nk);
    if (1UL<n) {
        t=ns+*pnr; pr[t].p=psm, pr[t].n=n; ++*pnr;
    }
    /* process large region */
    n=effective_size(plg,plg+slg,po,size,pk,nk);
    if (1UL<n) {
        /* Determine whether or not to repivot/repartition region of size n
           elements (large region) resulting from a partition of nmemb elements.
           Assumed that continued processing of the region w/o repivoting will
           yield a similar split.  Repivot if the cost of repivoting plus
           processing the resulting regions is expected to be less than the cost
           of processing the region w/o repivoting.  Tuning parameters used here
           are defined near the top of this file.
        */
        if ( ((REPIVOT_CUTOFF)<=nmemb)
          && (
#if REPIVOT_FACTOR == 16UL
              (n>>4)
#elif REPIVOT_FACTOR == 32UL
              (n>>5)
#elif REPIVOT_FACTOR == 64UL
              (n>>6)
#else
              (n/(REPIVOT_FACTOR))
#endif
                              >=nmemb-n-1UL)
        ) { /* repivot large region */
            *ppb=plg; return 1;
        } else {
            t=ns+*pnr; pr[t].p=plg, pr[t].n=n; ++*pnr;
        }
    }
    return 0;
}

/* quickselect definition (internal interface) */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
void quickselect_internal(void *base, size_t nmemb,
    const size_t size, int (*compar)(const void *,const void *),
    const size_t *pk, const size_t nk
   )
{
    char *pl;  /* left (or lowest) end of array being processed */
    char *po;  /* origin of array (maintained so that ranks can be computed) */
    int top=0; /* stack: regions[0..top-1], partition regions above stack */
    int swaptype; /* index into array of type sizes for swapping size */
    int i;     /* general integer variable */
    size_t s;  /* general size_t variable */

    if (2UL>nmemb) return; /* Return early if there's nothing to do. */

    /* Save the original pointer to the start of the (entire) array, so that
       element ranks can be determined for selection.  Also initialize the
       character pointer pl to the start (left side) of the array.  And save
       the original number of elements so that the original end of the array
       can be recomputed.
    */
    pl=po=(char *)base;

    /* Determine size of data chunks to copy for element swapping.  Size is
       determined by element size and alignment. swaptype is an index into an
       array of type sizes (double, pointer, long, int, short, char).
       Types char, short, int, double have sizes 1, 2, 4, 8 on most (all?)
       32-bit and 64-bit architectures.  Types long and pointer sizes vary
       by architecture.
    */
    s=typsz[swaptype=0]; /* double */
    if ((size<s)||(!(is_aligned(size,i=log2s[s])))||(!(is_aligned(po,i)))) {
        s=typsz[swaptype=3]; /* int */
        if ((size<s)||(!(is_aligned(size,i=log2s[s])))||(!(is_aligned(po,i)))) {
            s=typsz[swaptype=4]; /* short */
            if ((size<s)||(!(is_aligned(size,i=log2s[s])))
            ||(!(is_aligned(po,i))))
                swaptype=5; /* char */
        }
    }

    /* Outer processing loop: process regions on the stack */
    /* When there is nothing left to do in the inner loop, the outer processing
       loop pops a pointer and size from the stack of regions to be processed
       unless the stack is empty, in which case the sort or selection is
       complete.
    */
    while (1) { /* stack-not-empty loop: break out when stack is empty */
        struct region_struct regions[(NREGIONS)], *pr;
        int nregions;       /* number of partition regions above stack */

        /* The inner processing loop iterates while there is a region of size
           2 or greater to be processed (regions of size 1 are by definition
           already sorted).
        */
        for (nregions=0; 1UL<nmemb;) { /* current region iteration loop */
            int c, d, j;              /* general integer variables */
            char *pa, *pb, *pc, *pe, *pf, *pivot, *pu;
            size_t n, p, q, r, t;

            if ((NULL==pk) /* sorting only */
            && (nmemb<=(INSERTION_CUTOFF))) {
                /* Handle small regions with insertion sort. */
                /* At the end of insertion sort, break out of the inner loop. */
                for (pa=pl,pu=pl+(nmemb-1UL)*size; pa<pu; pa+=size)
                    for (pb=pa; (pb>=pl)&&(0<compar(pb,pc=pb+size)); pb-=size)
                        swap(pb,pc,size,swaptype);
        /* <- */break; /* Done; break out of inner loop, check stack. */
            }

            /* Partition the array into <, =, and > regions. */
            /* Modified (for fast_pivot initialization, deferred pivot swap,
               cache-friendly comparison, good_pivot break-glass, swap2,
               final blockmoves) Bentley&McIlroy "split end" partition.
            */
            /* Initially: */
            /* +------------------------------------------------------------+ */
            /* |                             ?                              | */
            /* +------------------------------------------------------------+ */
            /*  a                                                            e*/
            /*  b                                                            f*/
            /*  c                                                            u*/
            /* Invariant pointer pl -> first [sub-]array element.    */
            /* = elements (by comparison to pivot) are in a region on the left,
                  delimited by pl (first element) and pb (past last element.
            */
            /* Elements comparing small vs. pivot are in region delimited by pb
                  (first element) and pc (past last element).
            */
            /* Unknown region delimited by pc (first element) and pe (past last
                  element.  pb<=pc (always; they are equal if there are no ?
                  elements)
            */
            /* Elements comparing large vs. pivot are in region [pe,pf).
                  Pointer pu points past the last element.
            */
            /* A second = region is [pf,pu).                                  */
            /* Pointer pd may be used to scan from pc or pe into the unknown
                  region.  pc<=pd<=pe
            */
            /* After the optimized inner loops, pointer pe is a pointer
               to the start of the > region rather than the end of the unknown
               region; this is to facilitate calls to blockmove
            */
            /* +------------------------------------------------------------+ */
            /* |     =  |      <     | = |    ?      | = |    >    |   =    | */
            /* +------------------------------------------------------------+ */
            /*  pl     a b            c   d   or    d   E e         f        u*/
            /* Upper and lower diagram lines henceforth omitted for brevity. */
            /* Select a pivot element using a fast method w/ only poor rank
               guarantee.  Adaptive pivot selection: remedian of samples,
               ninther, median-of-3, singleton.  The number of samples depends
               on array size and sampling base for remedian of samples.
            */
            /* Determine how many samples to take from the array for pivot
               selection.  Find sampling_table entry appropriate for array size.
            */
            for (q=0UL; q<SAMPLING_TABLE_SIZE; q++)
                if (nmemb<sampling_table[q].min_nmemb)
                    break; /* stop looking */
            if (0UL<q) q--; /* sampling table index */
            n=sampling_table[q].samples; /* total samples (a power of 3) */
            /* Samples uniformly spaced in rows (which are also uniformly
               spaced), but N.B. sample spacing from the end of one row to the
               first sample on the next row is NOT necessarily the same as
               sample spacing within a row.  Always 3 rows. Set s to chars
               sample spacing within rows. Set r to row spacing in chars.
            */
            if (1UL==n) {
                pivot=pl+(nmemb>>2)*size; /* best for organ-pipe, OK others */
                s=r=0UL;
#if ASSERT_CODE
                t=n;
#endif /* ASSERT_CODE */
            } else {
                t = n/3UL;                                 /* samples per row */
                if (0UL<t) s=(p=nmemb>>2)/t; else s=0UL;    /* sample spacing */
                if (1UL>=t) r=((nmemb+2UL)>>2); else r=p+s;    /* row spacing */
                s*=size, r*=size;                         /* spacing in chars */
                pivot=pl+size*(nmemb>>1)                    /* middle element */
                    -r                                 /* -> middle first row */
                    -(t>>1)*s;                          /* - half row samples */
            }
#if ASSERT_CODE
            A(pl<=pivot);A(pivot<pl+nmemb*size); /* pivot is in the array */
            /* assertion below asserts that last sample < pu
               i.e. pl+(r<<1)*(t-1UL)*s<pl+nmemb*size
            */
            if (0UL!=t); A((r<<1)+(t-1UL)*s<nmemb*size);
#endif /* ASSERT_CODE */
            /* Select a pivot element from the array samples */
            if (1UL<n) { /* median or remedian of (at least 3) samples */
                /* First stage may have r!=3*s */
                n=sampling_table[--q].samples;
                pivot=medians3(pivot,size,compar,r,s,n,swaptype);
                /* remaining stages start with r=s*n, then r/=3 */
                /* loop control using sampling_table sample sizes */
                while (0UL<q) {
                    n=sampling_table[--q].samples;
                    /* For each set of 3 samples, set one element to the median
                       of the set. medians3 returns a pointer to the first
                       element of the resulting set of medians, which are
                       uniformly offset by the sample spacing s.
                    */
                    pivot=medians3(pivot,size,compar,n*s,s,n,swaptype);
                    /* Repeat for the samples in the medians row (i.e. the
                       medians of this group of sets) until only a single median
                       remains (i.e. row spacing < sample spacing). That final
                       median (the pivot element) is located at pivot.
                    */
                }
            }
            pe=(pf=pu=(pa=pb=pc=pl)+nmemb*size)-size;
            /* Partitioning per se. */
            /* NO disorder-causing swap of pivot initially */
            while (1) { /* outer loop: repivot/repartition until satisfactory */
                while (1) { /* middle loop - partitioning */
                    /* pivot updated when swapped */
                    while ((pc<=pe)&&(0<=(c=compar(pivot,pc)))) { /* scan -> */
                        if (c==0) { swap(pivot=pb,pc,size,swaptype); pb+=size; }
                        pc+=size;
                    }
                    while ((pc<=pe)&&(0>=(d=compar(pivot,pe)))) { /* scan <- */
                        if (d==0) { pf-=size; swap(pe,pivot=pf,size,swaptype); }
                        pe-=size;
                    }
                    if (pc>pe) break;
                    swap(pc,pe,size,swaptype); /* <, > */
                    pc+=size; pe-=size;
                }
                pe+=size; /* now start of > region */
                /* |    =  |      <             |             >    |   =    | */
                /*  pl    a b                    c=e                f        u*/
                /* swap > and upper = regions, set pd to start of > */
                if (pf<pu) { /* pe unchanged if pf>=pu */
                    if (pe<pf) { /* pe= original pu if pf>=pe */
                        p=pu-pf, n=pf-pe; if (p<n) n=p;
                        swap(pe,pu-n,n,swaptype); pe+=p;
                    } else pe=pu;
                }
                /* |    =  |      <           |        =      |      >      | */
                /*  pl    a b                  c               e             u*/
                /* swap left = and < regions */
                if (pb<pc) { /* pb= original pl if pb>=pc */
                    if (pl<pb) { /* pb= original pc if pb>=pa */
                        p=pc-pb, n=pb-pl; if (p<n) n=p;
                        swap(pl,pc-n,n,swaptype); pb=pl+p;
                    } else pb=pc;
                } else pb=pl;
                /* |       <            |         =           |      >      | */
                /*  pl                   b                     e             u*/
                /* Examine <, > region sizes, determine whether to repivot. */
                q=pb-pl; /* size of the < region, in chars */
                r=pu-pe;  /* size of the > region, in chars */
                if ((q)<(r)) /* > region is larger */
                    d=process_regions(pe,r,pl,q,nmemb,size,po,pk,nk,&pl,&n,
                        regions,&nregions, top);
                else /* < region is larger, or regions are the same size */
                    d=process_regions(pl,q,pe,r,nmemb,size,po,pk,nk,&pl,&n,
                        regions,&nregions, top);
                if (0==d) break; /* repivot not required */
                /* repivot/partition big region w/ pl,n from process_regions */
                /* |        <           |         =           |      >      | */
                /*  pl                   b                     e             u*/
                /* Finding a pivot with guaranteed intermediate rank. Ideally,
                   median (50%).  Blum, Floyd, Pratt, Rivest, Tarjan
                   median-of-medians using sets of 5 elements with recursion
                   guarantees rank in (asymptotically) 30-70% range, often
                   better; can guarantee linear median-finding, N log(N)
                   sorting. Simplification ignores "leftover" elements with a
                   slight increase in rank range.  Non-recursive method (using
                   separate linear median finding) can use sets of 3 elements to
                   provide a tighter 33.33% to 66.67% range (again, slightly
                   wider if "leftover" elements are ignored) at lower
                   computational cost.
                */
                nmemb=n; pivot=pl;
                n/=3UL;    /* number of complete sets */
                if (1UL<=n)
                    pivot=medians3(pl,size,compar,n*size,size,n,swaptype);
                if (1UL<n) { /* median of medians */
                    size_t karray[1];
                    karray[0]=n>>1; /* upper-median for even size arrays */
                    quickselect_internal(pivot,n,size,compar,karray,1UL);
                    pivot+=karray[0]*size; /* pointer to median */
                }
                /* |   ?   : < :=p=: > :   ?   | */
                /*          a   b   c   d       u*/
                /* reinitialize for repartitioning */
                /* |   ?   : < :=p=: > :   ?   | */
                /*  pl                  d       u*/
                /*  a=b=c                     e f*/
                pe=(pf=pu=(pa=pb=pc=pl)+nmemb*size)-size;
                /* partial partitioning information is lost */
            }

            /* Array is partitioned into 3 or more regions around pivot element;
               some regions may require processing.  Sort regions by effective
               size.
            */
            /* Sorting the regions by size (with regions not requiring
               processing counted as zero size) provides for processing the
               regions in an appropriate order, i.e. the largest region to be
               processed will be at regions[top], and regions[top+nregions-1]
               either requires no processing or is the smallest region.
               Et cetera.
               An in-line selection sort is used as the number of regions is
               expected to be small, and the region size is compared directly
               (selection sort uses minimum swaps, which dominate the cost when
               comparisons are cheap, as in this case).
            */
            for (c=top,j=top+nregions; c<j; c++) {
                for (i=d=c; d<j; d++)
                    if (regions[d].n>regions[i].n) i=d;
                if (i!=c) {
                    /* dedicated swap */
                    struct region_struct temp;
                    temp=regions[i], regions[i]=regions[c], regions[c]=temp;
                }
            }

            /* Process partitioned regions.
               Push the largest region(s) on a stack for later processing, and
               process the smallest region first, iteratively.  The smallest
               region (which is expected to use less stack depth to process) is
               disposed of first; after it has been processed, the stack
               resources used in processing it have been released, the problem
               size has been reduced, and the large region(s) can be processed.
               If processing only one region, do so iteratively.
               If no region needs to be processed, the sort (or selection) is
               complete.
            */
            /* Regions have been sorted: largest first.  */
            /* process smallest size >1 region iteratively, defer other(s) */
            for (i=top+nregions-1; top<=i; i--)
                if (1UL<regions[i].n) break;
            if (top<=i) {
                pl=regions[i].p, nmemb=regions[i].n; /* process iteratively */
                if (i>top) top=i;  /* others become part of the stack */
            } else break;
            nregions=0;

            /* The inner loop handles iterative processing, while nmemb > 1 */
        } /* 1UL<nmemb loop */
        /* Check stack for more work; if the stack is empty, quickselect is
           finished.  Otherwise, pop a region from the stack and process it.
        */
        if (0>=top) break; /* Done; function returns to caller. */
        /* Pop a set of parameters for a sub-array to be processed */
        pr=&(regions[--top]); pl=pr->p, nmemb=pr->n;
    } /* stack not empty loop */
    /* Done. */
}

/* comparison function for sorting order statistic ranks */
static
#if defined(__STDC__) && ( __STDC_VERSION__ >= 199901L)
inline
#endif /* C99 */
int size_t_cmp(const void *p1, const void *p2)
{
    if ((NULL != p1) && (NULL != p2) && (p1 != p2)) {
        const size_t a = *((const size_t *)p1), b = *((const size_t *)p2);

        if (a > b) return 1;
        if (a < b) return -1;
    }
    return 0;
}

/* public quickselect definition */
void quickselect(void *base, size_t nmemb, const size_t size,
    int (*compar)(const void *,const void *), size_t *pk, const size_t nk)
{
    /* Validate supplied parameters.  Provide a hint by setting errno if
       supplied parameters are invalid.
    */
    if ((NULL==base) || (0UL==size) || (NULL==compar)) {
        errno=EINVAL;
        return;
    }
    /* Initialization of strings is performed here (rather than in
       quickselect_internal) so that quickselect_internal can be made inline.
    */
    if ((char)0==quickselect_initialized) initialize_quickselect();
    /* Simplify tests for selection vs. sorting by ensuring a NULL pointer when
       sorting.
    */
    if (0UL==nk) pk=NULL;
    else if ((NK_CUTOFF) >= nk) /* binary search requires sorted pk */
        quickselect_internal((void *)pk,nk,sizeof(size_t),size_t_cmp,NULL,0UL);
    quickselect_internal(base,nmemb,size,compar,pk,nk);
}

/* Using quickselect to replace qsort: */
void QSORT_FUNCTION_NAME (void *base, size_t nmemb, size_t size,
    int (*compar)(const void *,const void *))
{
    /* Validate supplied parameters.  Provide a hint by setting errno if
       supplied parameters are invalid.
    */
    if ((NULL==base) || (0UL==size) || (NULL==compar)) {
        errno=EINVAL;
        return;
    }
    /* Initialization of strings is performed here (rather than in
       quickselect_internal) so that quickselect_internal can be made inline.
    */
    if ((char)0==quickselect_initialized) initialize_quickselect();
    quickselect_internal(base,nmemb,size,compar,NULL,0UL);
}
